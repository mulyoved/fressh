// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
import nativeModule, {
	type UniffiRustFutureContinuationCallback,
	type UniffiForeignFuture,
	type UniffiForeignFutureStructU8,
	type UniffiForeignFutureCompleteU8,
	type UniffiForeignFutureStructI8,
	type UniffiForeignFutureCompleteI8,
	type UniffiForeignFutureStructU16,
	type UniffiForeignFutureCompleteU16,
	type UniffiForeignFutureStructI16,
	type UniffiForeignFutureCompleteI16,
	type UniffiForeignFutureStructU32,
	type UniffiForeignFutureCompleteU32,
	type UniffiForeignFutureStructI32,
	type UniffiForeignFutureCompleteI32,
	type UniffiForeignFutureStructU64,
	type UniffiForeignFutureCompleteU64,
	type UniffiForeignFutureStructI64,
	type UniffiForeignFutureCompleteI64,
	type UniffiForeignFutureStructF32,
	type UniffiForeignFutureCompleteF32,
	type UniffiForeignFutureStructF64,
	type UniffiForeignFutureCompleteF64,
	type UniffiForeignFutureStructPointer,
	type UniffiForeignFutureCompletePointer,
	type UniffiForeignFutureStructRustBuffer,
	type UniffiForeignFutureCompleteRustBuffer,
	type UniffiForeignFutureStructVoid,
	type UniffiForeignFutureCompleteVoid,
	type UniffiVTableCallbackInterfaceConnectProgressCallback,
	type UniffiVTableCallbackInterfaceConnectionDisconnectedCallback,
	type UniffiVTableCallbackInterfaceServerKeyCallback,
	type UniffiVTableCallbackInterfaceShellClosedCallback,
	type UniffiVTableCallbackInterfaceShellListener,
} from './uniffi_russh-ffi';
import {
	type FfiConverter,
	type UniffiByteArray,
	type UniffiHandle,
	type UniffiObjectFactory,
	type UniffiReferenceHolder,
	type UniffiRustArcPtr,
	type UniffiRustCallStatus,
	type UnsafeMutableRawPointer,
	AbstractFfiConverterByteArray,
	FfiConverterArray,
	FfiConverterArrayBuffer,
	FfiConverterBool,
	FfiConverterFloat64,
	FfiConverterInt32,
	FfiConverterObject,
	FfiConverterObjectWithCallbacks,
	FfiConverterOptional,
	FfiConverterUInt16,
	FfiConverterUInt32,
	FfiConverterUInt64,
	FfiConverterUInt8,
	RustBuffer,
	UniffiAbstractObject,
	UniffiEnum,
	UniffiError,
	UniffiInternalError,
	UniffiResult,
	UniffiRustCaller,
	destructorGuardSymbol,
	pointerLiteralSymbol,
	uniffiCreateFfiConverterString,
	uniffiCreateRecord,
	uniffiRustCallAsync,
	uniffiTraitInterfaceCall,
	uniffiTraitInterfaceCallAsync,
	uniffiTypeNameSymbol,
	variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
	// @ts-ignore -- The process global might not be defined
	typeof process !== 'object' ||
	// @ts-ignore -- The process global might not be defined
	process?.env?.NODE_ENV !== 'production' ||
	false;
// Public interface members begin here.

export async function connect(
	options: ConnectOptions,
	asyncOpts_?: { signal: AbortSignal },
): Promise<SshConnectionInterface> /*throws*/ {
	const __stack = uniffiIsDebug ? new Error().stack : undefined;
	try {
		return await uniffiRustCallAsync(
			/*rustCaller:*/ uniffiCaller,
			/*rustFutureFunc:*/ () => {
				return nativeModule().ubrn_uniffi_uniffi_russh_fn_func_connect(
					FfiConverterTypeConnectOptions.lower(options),
				);
			},
			/*pollFunc:*/ nativeModule()
				.ubrn_ffi_uniffi_russh_rust_future_poll_pointer,
			/*cancelFunc:*/ nativeModule()
				.ubrn_ffi_uniffi_russh_rust_future_cancel_pointer,
			/*completeFunc:*/ nativeModule()
				.ubrn_ffi_uniffi_russh_rust_future_complete_pointer,
			/*freeFunc:*/ nativeModule()
				.ubrn_ffi_uniffi_russh_rust_future_free_pointer,
			/*liftFunc:*/ FfiConverterTypeSshConnection.lift.bind(
				FfiConverterTypeSshConnection,
			),
			/*liftString:*/ FfiConverterString.lift,
			/*asyncOpts:*/ asyncOpts_,
			/*errorHandler:*/ FfiConverterTypeSshError.lift.bind(
				FfiConverterTypeSshError,
			),
		);
	} catch (__error: any) {
		if (uniffiIsDebug && __error instanceof Error) {
			__error.stack = __stack;
		}
		throw __error;
	}
}
/**
 * Extract the public key from a private key in OpenSSH format.
 * Returns the public key in the standard "ssh-xxx AAAA... comment" format.
 */
export function extractPublicKey(privateKeyContent: string): string /*throws*/ {
	return FfiConverterString.lift(
		uniffiCaller.rustCallWithError(
			/*liftError:*/ FfiConverterTypeSshError.lift.bind(
				FfiConverterTypeSshError,
			),
			/*caller:*/ (callStatus) => {
				return nativeModule().ubrn_uniffi_uniffi_russh_fn_func_extract_public_key(
					FfiConverterString.lower(privateKeyContent),
					callStatus,
				);
			},
			/*liftString:*/ FfiConverterString.lift,
		),
	);
}
export function generateKeyPair(keyType: KeyType): string /*throws*/ {
	return FfiConverterString.lift(
		uniffiCaller.rustCallWithError(
			/*liftError:*/ FfiConverterTypeSshError.lift.bind(
				FfiConverterTypeSshError,
			),
			/*caller:*/ (callStatus) => {
				return nativeModule().ubrn_uniffi_uniffi_russh_fn_func_generate_key_pair(
					FfiConverterTypeKeyType.lower(keyType),
					callStatus,
				);
			},
			/*liftString:*/ FfiConverterString.lift,
		),
	);
}
export function validatePrivateKey(
	privateKeyContent: string,
): string /*throws*/ {
	return FfiConverterString.lift(
		uniffiCaller.rustCallWithError(
			/*liftError:*/ FfiConverterTypeSshError.lift.bind(
				FfiConverterTypeSshError,
			),
			/*caller:*/ (callStatus) => {
				return nativeModule().ubrn_uniffi_uniffi_russh_fn_func_validate_private_key(
					FfiConverterString.lower(privateKeyContent),
					callStatus,
				);
			},
			/*liftString:*/ FfiConverterString.lift,
		),
	);
}

export type BufferReadResult = {
	chunks: Array<TerminalChunk>;
	nextSeq: /*u64*/ bigint;
	dropped: DroppedRange | undefined;
};

/**
 * Generated factory for {@link BufferReadResult} record objects.
 */
export const BufferReadResult = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<BufferReadResult, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link BufferReadResult}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link BufferReadResult}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<BufferReadResult>,
	});
})();

const FfiConverterTypeBufferReadResult = (() => {
	type TypeName = BufferReadResult;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				chunks: FfiConverterArrayTypeTerminalChunk.read(from),
				nextSeq: FfiConverterUInt64.read(from),
				dropped: FfiConverterOptionalTypeDroppedRange.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterArrayTypeTerminalChunk.write(value.chunks, into);
			FfiConverterUInt64.write(value.nextSeq, into);
			FfiConverterOptionalTypeDroppedRange.write(value.dropped, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterArrayTypeTerminalChunk.allocationSize(value.chunks) +
				FfiConverterUInt64.allocationSize(value.nextSeq) +
				FfiConverterOptionalTypeDroppedRange.allocationSize(value.dropped)
			);
		}
	}
	return new FFIConverter();
})();

export type BufferStats = {
	ringBytesCount: /*u64*/ bigint;
	usedBytes: /*u64*/ bigint;
	headSeq: /*u64*/ bigint;
	tailSeq: /*u64*/ bigint;
	droppedBytesTotal: /*u64*/ bigint;
	chunksCount: /*u64*/ bigint;
};

/**
 * Generated factory for {@link BufferStats} record objects.
 */
export const BufferStats = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<BufferStats, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link BufferStats}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link BufferStats}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<BufferStats>,
	});
})();

const FfiConverterTypeBufferStats = (() => {
	type TypeName = BufferStats;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				ringBytesCount: FfiConverterUInt64.read(from),
				usedBytes: FfiConverterUInt64.read(from),
				headSeq: FfiConverterUInt64.read(from),
				tailSeq: FfiConverterUInt64.read(from),
				droppedBytesTotal: FfiConverterUInt64.read(from),
				chunksCount: FfiConverterUInt64.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterUInt64.write(value.ringBytesCount, into);
			FfiConverterUInt64.write(value.usedBytes, into);
			FfiConverterUInt64.write(value.headSeq, into);
			FfiConverterUInt64.write(value.tailSeq, into);
			FfiConverterUInt64.write(value.droppedBytesTotal, into);
			FfiConverterUInt64.write(value.chunksCount, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterUInt64.allocationSize(value.ringBytesCount) +
				FfiConverterUInt64.allocationSize(value.usedBytes) +
				FfiConverterUInt64.allocationSize(value.headSeq) +
				FfiConverterUInt64.allocationSize(value.tailSeq) +
				FfiConverterUInt64.allocationSize(value.droppedBytesTotal) +
				FfiConverterUInt64.allocationSize(value.chunksCount)
			);
		}
	}
	return new FFIConverter();
})();

export type ConnectOptions = {
	connectionDetails: ConnectionDetails;
	onConnectionProgressCallback: ConnectProgressCallback | undefined;
	onDisconnectedCallback: ConnectionDisconnectedCallback | undefined;
	onServerKeyCallback: ServerKeyCallback;
};

/**
 * Generated factory for {@link ConnectOptions} record objects.
 */
export const ConnectOptions = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<ConnectOptions, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link ConnectOptions}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link ConnectOptions}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<ConnectOptions>,
	});
})();

const FfiConverterTypeConnectOptions = (() => {
	type TypeName = ConnectOptions;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				connectionDetails: FfiConverterTypeConnectionDetails.read(from),
				onConnectionProgressCallback:
					FfiConverterOptionalTypeConnectProgressCallback.read(from),
				onDisconnectedCallback:
					FfiConverterOptionalTypeConnectionDisconnectedCallback.read(from),
				onServerKeyCallback: FfiConverterTypeServerKeyCallback.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterTypeConnectionDetails.write(value.connectionDetails, into);
			FfiConverterOptionalTypeConnectProgressCallback.write(
				value.onConnectionProgressCallback,
				into,
			);
			FfiConverterOptionalTypeConnectionDisconnectedCallback.write(
				value.onDisconnectedCallback,
				into,
			);
			FfiConverterTypeServerKeyCallback.write(value.onServerKeyCallback, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterTypeConnectionDetails.allocationSize(
					value.connectionDetails,
				) +
				FfiConverterOptionalTypeConnectProgressCallback.allocationSize(
					value.onConnectionProgressCallback,
				) +
				FfiConverterOptionalTypeConnectionDisconnectedCallback.allocationSize(
					value.onDisconnectedCallback,
				) +
				FfiConverterTypeServerKeyCallback.allocationSize(
					value.onServerKeyCallback,
				)
			);
		}
	}
	return new FFIConverter();
})();

export type ConnectionDetails = {
	host: string;
	port: /*u16*/ number;
	username: string;
	security: Security;
};

/**
 * Generated factory for {@link ConnectionDetails} record objects.
 */
export const ConnectionDetails = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<ConnectionDetails, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link ConnectionDetails}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link ConnectionDetails}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<ConnectionDetails>,
	});
})();

const FfiConverterTypeConnectionDetails = (() => {
	type TypeName = ConnectionDetails;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				host: FfiConverterString.read(from),
				port: FfiConverterUInt16.read(from),
				username: FfiConverterString.read(from),
				security: FfiConverterTypeSecurity.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterString.write(value.host, into);
			FfiConverterUInt16.write(value.port, into);
			FfiConverterString.write(value.username, into);
			FfiConverterTypeSecurity.write(value.security, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterString.allocationSize(value.host) +
				FfiConverterUInt16.allocationSize(value.port) +
				FfiConverterString.allocationSize(value.username) +
				FfiConverterTypeSecurity.allocationSize(value.security)
			);
		}
	}
	return new FFIConverter();
})();

export type DroppedRange = {
	fromSeq: /*u64*/ bigint;
	toSeq: /*u64*/ bigint;
};

/**
 * Generated factory for {@link DroppedRange} record objects.
 */
export const DroppedRange = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<DroppedRange, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link DroppedRange}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link DroppedRange}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<DroppedRange>,
	});
})();

const FfiConverterTypeDroppedRange = (() => {
	type TypeName = DroppedRange;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				fromSeq: FfiConverterUInt64.read(from),
				toSeq: FfiConverterUInt64.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterUInt64.write(value.fromSeq, into);
			FfiConverterUInt64.write(value.toSeq, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterUInt64.allocationSize(value.fromSeq) +
				FfiConverterUInt64.allocationSize(value.toSeq)
			);
		}
	}
	return new FFIConverter();
})();

export type ListenerOptions = {
	cursor: Cursor;
	coalesceMs: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link ListenerOptions} record objects.
 */
export const ListenerOptions = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<ListenerOptions, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link ListenerOptions}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link ListenerOptions}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<ListenerOptions>,
	});
})();

const FfiConverterTypeListenerOptions = (() => {
	type TypeName = ListenerOptions;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				cursor: FfiConverterTypeCursor.read(from),
				coalesceMs: FfiConverterOptionalUInt32.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterTypeCursor.write(value.cursor, into);
			FfiConverterOptionalUInt32.write(value.coalesceMs, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterTypeCursor.allocationSize(value.cursor) +
				FfiConverterOptionalUInt32.allocationSize(value.coalesceMs)
			);
		}
	}
	return new FFIConverter();
})();

export type ServerPublicKeyInfo = {
	host: string;
	port: /*u16*/ number;
	remoteIp: string | undefined;
	algorithm: string;
	fingerprintSha256: string;
	keyBase64: string;
};

/**
 * Generated factory for {@link ServerPublicKeyInfo} record objects.
 */
export const ServerPublicKeyInfo = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<ServerPublicKeyInfo, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link ServerPublicKeyInfo}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link ServerPublicKeyInfo}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<ServerPublicKeyInfo>,
	});
})();

const FfiConverterTypeServerPublicKeyInfo = (() => {
	type TypeName = ServerPublicKeyInfo;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				host: FfiConverterString.read(from),
				port: FfiConverterUInt16.read(from),
				remoteIp: FfiConverterOptionalString.read(from),
				algorithm: FfiConverterString.read(from),
				fingerprintSha256: FfiConverterString.read(from),
				keyBase64: FfiConverterString.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterString.write(value.host, into);
			FfiConverterUInt16.write(value.port, into);
			FfiConverterOptionalString.write(value.remoteIp, into);
			FfiConverterString.write(value.algorithm, into);
			FfiConverterString.write(value.fingerprintSha256, into);
			FfiConverterString.write(value.keyBase64, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterString.allocationSize(value.host) +
				FfiConverterUInt16.allocationSize(value.port) +
				FfiConverterOptionalString.allocationSize(value.remoteIp) +
				FfiConverterString.allocationSize(value.algorithm) +
				FfiConverterString.allocationSize(value.fingerprintSha256) +
				FfiConverterString.allocationSize(value.keyBase64)
			);
		}
	}
	return new FFIConverter();
})();

/**
 * Snapshot of shell session info for property-like access in TS.
 */
export type ShellSessionInfo = {
	channelId: /*u32*/ number;
	createdAtMs: /*f64*/ number;
	connectedAtMs: /*f64*/ number;
	term: TerminalType;
	connectionId: string;
};

/**
 * Generated factory for {@link ShellSessionInfo} record objects.
 */
export const ShellSessionInfo = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<ShellSessionInfo, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link ShellSessionInfo}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link ShellSessionInfo}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<ShellSessionInfo>,
	});
})();

const FfiConverterTypeShellSessionInfo = (() => {
	type TypeName = ShellSessionInfo;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				channelId: FfiConverterUInt32.read(from),
				createdAtMs: FfiConverterFloat64.read(from),
				connectedAtMs: FfiConverterFloat64.read(from),
				term: FfiConverterTypeTerminalType.read(from),
				connectionId: FfiConverterString.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterUInt32.write(value.channelId, into);
			FfiConverterFloat64.write(value.createdAtMs, into);
			FfiConverterFloat64.write(value.connectedAtMs, into);
			FfiConverterTypeTerminalType.write(value.term, into);
			FfiConverterString.write(value.connectionId, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterUInt32.allocationSize(value.channelId) +
				FfiConverterFloat64.allocationSize(value.createdAtMs) +
				FfiConverterFloat64.allocationSize(value.connectedAtMs) +
				FfiConverterTypeTerminalType.allocationSize(value.term) +
				FfiConverterString.allocationSize(value.connectionId)
			);
		}
	}
	return new FFIConverter();
})();

export type SshConnectionInfo = {
	connectionId: string;
	connectionDetails: ConnectionDetails;
	createdAtMs: /*f64*/ number;
	connectedAtMs: /*f64*/ number;
	progressTimings: SshConnectionInfoProgressTimings;
};

/**
 * Generated factory for {@link SshConnectionInfo} record objects.
 */
export const SshConnectionInfo = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<SshConnectionInfo, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link SshConnectionInfo}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link SshConnectionInfo}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<SshConnectionInfo>,
	});
})();

const FfiConverterTypeSshConnectionInfo = (() => {
	type TypeName = SshConnectionInfo;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				connectionId: FfiConverterString.read(from),
				connectionDetails: FfiConverterTypeConnectionDetails.read(from),
				createdAtMs: FfiConverterFloat64.read(from),
				connectedAtMs: FfiConverterFloat64.read(from),
				progressTimings:
					FfiConverterTypeSshConnectionInfoProgressTimings.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterString.write(value.connectionId, into);
			FfiConverterTypeConnectionDetails.write(value.connectionDetails, into);
			FfiConverterFloat64.write(value.createdAtMs, into);
			FfiConverterFloat64.write(value.connectedAtMs, into);
			FfiConverterTypeSshConnectionInfoProgressTimings.write(
				value.progressTimings,
				into,
			);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterString.allocationSize(value.connectionId) +
				FfiConverterTypeConnectionDetails.allocationSize(
					value.connectionDetails,
				) +
				FfiConverterFloat64.allocationSize(value.createdAtMs) +
				FfiConverterFloat64.allocationSize(value.connectedAtMs) +
				FfiConverterTypeSshConnectionInfoProgressTimings.allocationSize(
					value.progressTimings,
				)
			);
		}
	}
	return new FFIConverter();
})();

export type SshConnectionInfoProgressTimings = {
	tcpEstablishedAtMs: /*f64*/ number;
	sshHandshakeAtMs: /*f64*/ number;
};

/**
 * Generated factory for {@link SshConnectionInfoProgressTimings} record objects.
 */
export const SshConnectionInfoProgressTimings = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<
			SshConnectionInfoProgressTimings,
			ReturnType<typeof defaults>
		>(defaults);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link SshConnectionInfoProgressTimings}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link SshConnectionInfoProgressTimings}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () =>
			Object.freeze(defaults()) as Partial<SshConnectionInfoProgressTimings>,
	});
})();

const FfiConverterTypeSshConnectionInfoProgressTimings = (() => {
	type TypeName = SshConnectionInfoProgressTimings;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				tcpEstablishedAtMs: FfiConverterFloat64.read(from),
				sshHandshakeAtMs: FfiConverterFloat64.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterFloat64.write(value.tcpEstablishedAtMs, into);
			FfiConverterFloat64.write(value.sshHandshakeAtMs, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterFloat64.allocationSize(value.tcpEstablishedAtMs) +
				FfiConverterFloat64.allocationSize(value.sshHandshakeAtMs)
			);
		}
	}
	return new FFIConverter();
})();

export type StartShellOptions = {
	term: TerminalType;
	terminalMode: Array<TerminalMode> | undefined;
	terminalSize: TerminalSize | undefined;
	terminalPixelSize: TerminalPixelSize | undefined;
	onClosedCallback: ShellClosedCallback | undefined;
};

/**
 * Generated factory for {@link StartShellOptions} record objects.
 */
export const StartShellOptions = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<StartShellOptions, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link StartShellOptions}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link StartShellOptions}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<StartShellOptions>,
	});
})();

const FfiConverterTypeStartShellOptions = (() => {
	type TypeName = StartShellOptions;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				term: FfiConverterTypeTerminalType.read(from),
				terminalMode: FfiConverterOptionalArrayTypeTerminalMode.read(from),
				terminalSize: FfiConverterOptionalTypeTerminalSize.read(from),
				terminalPixelSize: FfiConverterOptionalTypeTerminalPixelSize.read(from),
				onClosedCallback:
					FfiConverterOptionalTypeShellClosedCallback.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterTypeTerminalType.write(value.term, into);
			FfiConverterOptionalArrayTypeTerminalMode.write(value.terminalMode, into);
			FfiConverterOptionalTypeTerminalSize.write(value.terminalSize, into);
			FfiConverterOptionalTypeTerminalPixelSize.write(
				value.terminalPixelSize,
				into,
			);
			FfiConverterOptionalTypeShellClosedCallback.write(
				value.onClosedCallback,
				into,
			);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterTypeTerminalType.allocationSize(value.term) +
				FfiConverterOptionalArrayTypeTerminalMode.allocationSize(
					value.terminalMode,
				) +
				FfiConverterOptionalTypeTerminalSize.allocationSize(
					value.terminalSize,
				) +
				FfiConverterOptionalTypeTerminalPixelSize.allocationSize(
					value.terminalPixelSize,
				) +
				FfiConverterOptionalTypeShellClosedCallback.allocationSize(
					value.onClosedCallback,
				)
			);
		}
	}
	return new FFIConverter();
})();

export type TerminalChunk = {
	seq: /*u64*/ bigint;
	tMs: /*f64*/ number;
	stream: StreamKind;
	bytes: ArrayBuffer;
};

/**
 * Generated factory for {@link TerminalChunk} record objects.
 */
export const TerminalChunk = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<TerminalChunk, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link TerminalChunk}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link TerminalChunk}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<TerminalChunk>,
	});
})();

const FfiConverterTypeTerminalChunk = (() => {
	type TypeName = TerminalChunk;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				seq: FfiConverterUInt64.read(from),
				tMs: FfiConverterFloat64.read(from),
				stream: FfiConverterTypeStreamKind.read(from),
				bytes: FfiConverterArrayBuffer.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterUInt64.write(value.seq, into);
			FfiConverterFloat64.write(value.tMs, into);
			FfiConverterTypeStreamKind.write(value.stream, into);
			FfiConverterArrayBuffer.write(value.bytes, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterUInt64.allocationSize(value.seq) +
				FfiConverterFloat64.allocationSize(value.tMs) +
				FfiConverterTypeStreamKind.allocationSize(value.stream) +
				FfiConverterArrayBuffer.allocationSize(value.bytes)
			);
		}
	}
	return new FFIConverter();
})();

export type TerminalMode = {
	opcode: /*u8*/ number;
	value: /*u32*/ number;
};

/**
 * Generated factory for {@link TerminalMode} record objects.
 */
export const TerminalMode = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<TerminalMode, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link TerminalMode}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link TerminalMode}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<TerminalMode>,
	});
})();

const FfiConverterTypeTerminalMode = (() => {
	type TypeName = TerminalMode;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				opcode: FfiConverterUInt8.read(from),
				value: FfiConverterUInt32.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterUInt8.write(value.opcode, into);
			FfiConverterUInt32.write(value.value, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterUInt8.allocationSize(value.opcode) +
				FfiConverterUInt32.allocationSize(value.value)
			);
		}
	}
	return new FFIConverter();
})();

export type TerminalPixelSize = {
	pixelWidth: /*u32*/ number | undefined;
	pixelHeight: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link TerminalPixelSize} record objects.
 */
export const TerminalPixelSize = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<TerminalPixelSize, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link TerminalPixelSize}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link TerminalPixelSize}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<TerminalPixelSize>,
	});
})();

const FfiConverterTypeTerminalPixelSize = (() => {
	type TypeName = TerminalPixelSize;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				pixelWidth: FfiConverterOptionalUInt32.read(from),
				pixelHeight: FfiConverterOptionalUInt32.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterOptionalUInt32.write(value.pixelWidth, into);
			FfiConverterOptionalUInt32.write(value.pixelHeight, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterOptionalUInt32.allocationSize(value.pixelWidth) +
				FfiConverterOptionalUInt32.allocationSize(value.pixelHeight)
			);
		}
	}
	return new FFIConverter();
})();

export type TerminalSize = {
	rowHeight: /*u32*/ number | undefined;
	colWidth: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link TerminalSize} record objects.
 */
export const TerminalSize = (() => {
	const defaults = () => ({});
	const create = (() => {
		return uniffiCreateRecord<TerminalSize, ReturnType<typeof defaults>>(
			defaults,
		);
	})();
	return Object.freeze({
		/**
		 * Create a frozen instance of {@link TerminalSize}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		create,

		/**
		 * Create a frozen instance of {@link TerminalSize}, with defaults specified
		 * in Rust, in the {@link uniffi_russh} crate.
		 */
		new: create,

		/**
		 * Defaults specified in the {@link uniffi_russh} crate.
		 */
		defaults: () => Object.freeze(defaults()) as Partial<TerminalSize>,
	});
})();

const FfiConverterTypeTerminalSize = (() => {
	type TypeName = TerminalSize;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			return {
				rowHeight: FfiConverterOptionalUInt32.read(from),
				colWidth: FfiConverterOptionalUInt32.read(from),
			};
		}
		write(value: TypeName, into: RustBuffer): void {
			FfiConverterOptionalUInt32.write(value.rowHeight, into);
			FfiConverterOptionalUInt32.write(value.colWidth, into);
		}
		allocationSize(value: TypeName): number {
			return (
				FfiConverterOptionalUInt32.allocationSize(value.rowHeight) +
				FfiConverterOptionalUInt32.allocationSize(value.colWidth)
			);
		}
	}
	return new FFIConverter();
})();

const stringConverter = {
	stringToBytes: (s: string) =>
		uniffiCaller.rustCall((status) =>
			nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
				s,
				status,
			),
		),
	bytesToString: (ab: UniffiByteArray) =>
		uniffiCaller.rustCall((status) =>
			nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
				ab,
				status,
			),
		),
	stringByteLength: (s: string) =>
		uniffiCaller.rustCall((status) =>
			nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
				s,
				status,
			),
		),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Enum: Cursor
export enum Cursor_Tags {
	Head = 'Head',
	TailBytes = 'TailBytes',
	Seq = 'Seq',
	TimeMs = 'TimeMs',
	Live = 'Live',
}
export const Cursor = (() => {
	type Head__interface = {
		tag: Cursor_Tags.Head;
	};

	class Head_ extends UniffiEnum implements Head__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'Cursor';
		readonly tag = Cursor_Tags.Head;
		constructor() {
			super('Cursor', 'Head');
		}

		static new(): Head_ {
			return new Head_();
		}

		static instanceOf(obj: any): obj is Head_ {
			return obj.tag === Cursor_Tags.Head;
		}
	}

	type TailBytes__interface = {
		tag: Cursor_Tags.TailBytes;
		inner: Readonly<{ bytes: /*u64*/ bigint }>;
	};

	class TailBytes_ extends UniffiEnum implements TailBytes__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'Cursor';
		readonly tag = Cursor_Tags.TailBytes;
		readonly inner: Readonly<{ bytes: /*u64*/ bigint }>;
		constructor(inner: { bytes: /*u64*/ bigint }) {
			super('Cursor', 'TailBytes');
			this.inner = Object.freeze(inner);
		}

		static new(inner: { bytes: /*u64*/ bigint }): TailBytes_ {
			return new TailBytes_(inner);
		}

		static instanceOf(obj: any): obj is TailBytes_ {
			return obj.tag === Cursor_Tags.TailBytes;
		}
	}

	type Seq__interface = {
		tag: Cursor_Tags.Seq;
		inner: Readonly<{ seq: /*u64*/ bigint }>;
	};

	class Seq_ extends UniffiEnum implements Seq__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'Cursor';
		readonly tag = Cursor_Tags.Seq;
		readonly inner: Readonly<{ seq: /*u64*/ bigint }>;
		constructor(inner: { seq: /*u64*/ bigint }) {
			super('Cursor', 'Seq');
			this.inner = Object.freeze(inner);
		}

		static new(inner: { seq: /*u64*/ bigint }): Seq_ {
			return new Seq_(inner);
		}

		static instanceOf(obj: any): obj is Seq_ {
			return obj.tag === Cursor_Tags.Seq;
		}
	}

	type TimeMs__interface = {
		tag: Cursor_Tags.TimeMs;
		inner: Readonly<{ tMs: /*f64*/ number }>;
	};

	class TimeMs_ extends UniffiEnum implements TimeMs__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'Cursor';
		readonly tag = Cursor_Tags.TimeMs;
		readonly inner: Readonly<{ tMs: /*f64*/ number }>;
		constructor(inner: { tMs: /*f64*/ number }) {
			super('Cursor', 'TimeMs');
			this.inner = Object.freeze(inner);
		}

		static new(inner: { tMs: /*f64*/ number }): TimeMs_ {
			return new TimeMs_(inner);
		}

		static instanceOf(obj: any): obj is TimeMs_ {
			return obj.tag === Cursor_Tags.TimeMs;
		}
	}

	type Live__interface = {
		tag: Cursor_Tags.Live;
	};

	class Live_ extends UniffiEnum implements Live__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'Cursor';
		readonly tag = Cursor_Tags.Live;
		constructor() {
			super('Cursor', 'Live');
		}

		static new(): Live_ {
			return new Live_();
		}

		static instanceOf(obj: any): obj is Live_ {
			return obj.tag === Cursor_Tags.Live;
		}
	}

	function instanceOf(obj: any): obj is Cursor {
		return obj[uniffiTypeNameSymbol] === 'Cursor';
	}

	return Object.freeze({
		instanceOf,
		Head: Head_,
		TailBytes: TailBytes_,
		Seq: Seq_,
		TimeMs: TimeMs_,
		Live: Live_,
	});
})();

export type Cursor = InstanceType<
	(typeof Cursor)[keyof Omit<typeof Cursor, 'instanceOf'>]
>;

// FfiConverter for enum Cursor
const FfiConverterTypeCursor = (() => {
	const ordinalConverter = FfiConverterInt32;
	type TypeName = Cursor;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			switch (ordinalConverter.read(from)) {
				case 1:
					return new Cursor.Head();
				case 2:
					return new Cursor.TailBytes({ bytes: FfiConverterUInt64.read(from) });
				case 3:
					return new Cursor.Seq({ seq: FfiConverterUInt64.read(from) });
				case 4:
					return new Cursor.TimeMs({ tMs: FfiConverterFloat64.read(from) });
				case 5:
					return new Cursor.Live();
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		write(value: TypeName, into: RustBuffer): void {
			switch (value.tag) {
				case Cursor_Tags.Head: {
					ordinalConverter.write(1, into);
					return;
				}
				case Cursor_Tags.TailBytes: {
					ordinalConverter.write(2, into);
					const inner = value.inner;
					FfiConverterUInt64.write(inner.bytes, into);
					return;
				}
				case Cursor_Tags.Seq: {
					ordinalConverter.write(3, into);
					const inner = value.inner;
					FfiConverterUInt64.write(inner.seq, into);
					return;
				}
				case Cursor_Tags.TimeMs: {
					ordinalConverter.write(4, into);
					const inner = value.inner;
					FfiConverterFloat64.write(inner.tMs, into);
					return;
				}
				case Cursor_Tags.Live: {
					ordinalConverter.write(5, into);
					return;
				}
				default:
					// Throwing from here means that Cursor_Tags hasn't matched an ordinal.
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		allocationSize(value: TypeName): number {
			switch (value.tag) {
				case Cursor_Tags.Head: {
					return ordinalConverter.allocationSize(1);
				}
				case Cursor_Tags.TailBytes: {
					const inner = value.inner;
					let size = ordinalConverter.allocationSize(2);
					size += FfiConverterUInt64.allocationSize(inner.bytes);
					return size;
				}
				case Cursor_Tags.Seq: {
					const inner = value.inner;
					let size = ordinalConverter.allocationSize(3);
					size += FfiConverterUInt64.allocationSize(inner.seq);
					return size;
				}
				case Cursor_Tags.TimeMs: {
					const inner = value.inner;
					let size = ordinalConverter.allocationSize(4);
					size += FfiConverterFloat64.allocationSize(inner.tMs);
					return size;
				}
				case Cursor_Tags.Live: {
					return ordinalConverter.allocationSize(5);
				}
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
	}
	return new FFIConverter();
})();

export enum KeyType {
	Rsa,
	Ecdsa,
	Ed25519,
	Ed448,
}

const FfiConverterTypeKeyType = (() => {
	const ordinalConverter = FfiConverterInt32;
	type TypeName = KeyType;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			switch (ordinalConverter.read(from)) {
				case 1:
					return KeyType.Rsa;
				case 2:
					return KeyType.Ecdsa;
				case 3:
					return KeyType.Ed25519;
				case 4:
					return KeyType.Ed448;
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		write(value: TypeName, into: RustBuffer): void {
			switch (value) {
				case KeyType.Rsa:
					return ordinalConverter.write(1, into);
				case KeyType.Ecdsa:
					return ordinalConverter.write(2, into);
				case KeyType.Ed25519:
					return ordinalConverter.write(3, into);
				case KeyType.Ed448:
					return ordinalConverter.write(4, into);
			}
		}
		allocationSize(value: TypeName): number {
			return ordinalConverter.allocationSize(0);
		}
	}
	return new FFIConverter();
})();

// Enum: Security
export enum Security_Tags {
	Password = 'Password',
	Key = 'Key',
}
export const Security = (() => {
	type Password__interface = {
		tag: Security_Tags.Password;
		inner: Readonly<{ password: string }>;
	};

	class Password_ extends UniffiEnum implements Password__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'Security';
		readonly tag = Security_Tags.Password;
		readonly inner: Readonly<{ password: string }>;
		constructor(inner: { password: string }) {
			super('Security', 'Password');
			this.inner = Object.freeze(inner);
		}

		static new(inner: { password: string }): Password_ {
			return new Password_(inner);
		}

		static instanceOf(obj: any): obj is Password_ {
			return obj.tag === Security_Tags.Password;
		}
	}

	type Key__interface = {
		tag: Security_Tags.Key;
		inner: Readonly<{ privateKeyContent: string }>;
	};

	class Key_ extends UniffiEnum implements Key__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'Security';
		readonly tag = Security_Tags.Key;
		readonly inner: Readonly<{ privateKeyContent: string }>;
		constructor(inner: { privateKeyContent: string }) {
			super('Security', 'Key');
			this.inner = Object.freeze(inner);
		}

		static new(inner: { privateKeyContent: string }): Key_ {
			return new Key_(inner);
		}

		static instanceOf(obj: any): obj is Key_ {
			return obj.tag === Security_Tags.Key;
		}
	}

	function instanceOf(obj: any): obj is Security {
		return obj[uniffiTypeNameSymbol] === 'Security';
	}

	return Object.freeze({
		instanceOf,
		Password: Password_,
		Key: Key_,
	});
})();

export type Security = InstanceType<
	(typeof Security)[keyof Omit<typeof Security, 'instanceOf'>]
>;

// FfiConverter for enum Security
const FfiConverterTypeSecurity = (() => {
	const ordinalConverter = FfiConverterInt32;
	type TypeName = Security;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			switch (ordinalConverter.read(from)) {
				case 1:
					return new Security.Password({
						password: FfiConverterString.read(from),
					});
				case 2:
					return new Security.Key({
						privateKeyContent: FfiConverterString.read(from),
					});
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		write(value: TypeName, into: RustBuffer): void {
			switch (value.tag) {
				case Security_Tags.Password: {
					ordinalConverter.write(1, into);
					const inner = value.inner;
					FfiConverterString.write(inner.password, into);
					return;
				}
				case Security_Tags.Key: {
					ordinalConverter.write(2, into);
					const inner = value.inner;
					FfiConverterString.write(inner.privateKeyContent, into);
					return;
				}
				default:
					// Throwing from here means that Security_Tags hasn't matched an ordinal.
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		allocationSize(value: TypeName): number {
			switch (value.tag) {
				case Security_Tags.Password: {
					const inner = value.inner;
					let size = ordinalConverter.allocationSize(1);
					size += FfiConverterString.allocationSize(inner.password);
					return size;
				}
				case Security_Tags.Key: {
					const inner = value.inner;
					let size = ordinalConverter.allocationSize(2);
					size += FfiConverterString.allocationSize(inner.privateKeyContent);
					return size;
				}
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
	}
	return new FFIConverter();
})();

// Enum: ShellEvent
export enum ShellEvent_Tags {
	Chunk = 'Chunk',
	Dropped = 'Dropped',
}
export const ShellEvent = (() => {
	type Chunk__interface = {
		tag: ShellEvent_Tags.Chunk;
		inner: Readonly<[TerminalChunk]>;
	};

	class Chunk_ extends UniffiEnum implements Chunk__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'ShellEvent';
		readonly tag = ShellEvent_Tags.Chunk;
		readonly inner: Readonly<[TerminalChunk]>;
		constructor(v0: TerminalChunk) {
			super('ShellEvent', 'Chunk');
			this.inner = Object.freeze([v0]);
		}

		static new(v0: TerminalChunk): Chunk_ {
			return new Chunk_(v0);
		}

		static instanceOf(obj: any): obj is Chunk_ {
			return obj.tag === ShellEvent_Tags.Chunk;
		}
	}

	type Dropped__interface = {
		tag: ShellEvent_Tags.Dropped;
		inner: Readonly<{ fromSeq: /*u64*/ bigint; toSeq: /*u64*/ bigint }>;
	};

	class Dropped_ extends UniffiEnum implements Dropped__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'ShellEvent';
		readonly tag = ShellEvent_Tags.Dropped;
		readonly inner: Readonly<{
			fromSeq: /*u64*/ bigint;
			toSeq: /*u64*/ bigint;
		}>;
		constructor(inner: { fromSeq: /*u64*/ bigint; toSeq: /*u64*/ bigint }) {
			super('ShellEvent', 'Dropped');
			this.inner = Object.freeze(inner);
		}

		static new(inner: {
			fromSeq: /*u64*/ bigint;
			toSeq: /*u64*/ bigint;
		}): Dropped_ {
			return new Dropped_(inner);
		}

		static instanceOf(obj: any): obj is Dropped_ {
			return obj.tag === ShellEvent_Tags.Dropped;
		}
	}

	function instanceOf(obj: any): obj is ShellEvent {
		return obj[uniffiTypeNameSymbol] === 'ShellEvent';
	}

	return Object.freeze({
		instanceOf,
		Chunk: Chunk_,
		Dropped: Dropped_,
	});
})();

export type ShellEvent = InstanceType<
	(typeof ShellEvent)[keyof Omit<typeof ShellEvent, 'instanceOf'>]
>;

// FfiConverter for enum ShellEvent
const FfiConverterTypeShellEvent = (() => {
	const ordinalConverter = FfiConverterInt32;
	type TypeName = ShellEvent;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			switch (ordinalConverter.read(from)) {
				case 1:
					return new ShellEvent.Chunk(FfiConverterTypeTerminalChunk.read(from));
				case 2:
					return new ShellEvent.Dropped({
						fromSeq: FfiConverterUInt64.read(from),
						toSeq: FfiConverterUInt64.read(from),
					});
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		write(value: TypeName, into: RustBuffer): void {
			switch (value.tag) {
				case ShellEvent_Tags.Chunk: {
					ordinalConverter.write(1, into);
					const inner = value.inner;
					FfiConverterTypeTerminalChunk.write(inner[0], into);
					return;
				}
				case ShellEvent_Tags.Dropped: {
					ordinalConverter.write(2, into);
					const inner = value.inner;
					FfiConverterUInt64.write(inner.fromSeq, into);
					FfiConverterUInt64.write(inner.toSeq, into);
					return;
				}
				default:
					// Throwing from here means that ShellEvent_Tags hasn't matched an ordinal.
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		allocationSize(value: TypeName): number {
			switch (value.tag) {
				case ShellEvent_Tags.Chunk: {
					const inner = value.inner;
					let size = ordinalConverter.allocationSize(1);
					size += FfiConverterTypeTerminalChunk.allocationSize(inner[0]);
					return size;
				}
				case ShellEvent_Tags.Dropped: {
					const inner = value.inner;
					let size = ordinalConverter.allocationSize(2);
					size += FfiConverterUInt64.allocationSize(inner.fromSeq);
					size += FfiConverterUInt64.allocationSize(inner.toSeq);
					return size;
				}
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
	}
	return new FFIConverter();
})();

export enum SshConnectionProgressEvent {
	TcpConnected,
	SshHandshake,
}

const FfiConverterTypeSshConnectionProgressEvent = (() => {
	const ordinalConverter = FfiConverterInt32;
	type TypeName = SshConnectionProgressEvent;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			switch (ordinalConverter.read(from)) {
				case 1:
					return SshConnectionProgressEvent.TcpConnected;
				case 2:
					return SshConnectionProgressEvent.SshHandshake;
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		write(value: TypeName, into: RustBuffer): void {
			switch (value) {
				case SshConnectionProgressEvent.TcpConnected:
					return ordinalConverter.write(1, into);
				case SshConnectionProgressEvent.SshHandshake:
					return ordinalConverter.write(2, into);
			}
		}
		allocationSize(value: TypeName): number {
			return ordinalConverter.allocationSize(0);
		}
	}
	return new FFIConverter();
})();

// Error type: SshError

// Enum: SshError
export enum SshError_Tags {
	Disconnected = 'Disconnected',
	UnsupportedKeyType = 'UnsupportedKeyType',
	Auth = 'Auth',
	ShellAlreadyRunning = 'ShellAlreadyRunning',
	Russh = 'Russh',
	RusshKeys = 'RusshKeys',
}
export const SshError = (() => {
	type Disconnected__interface = {
		tag: SshError_Tags.Disconnected;
	};

	class Disconnected_ extends UniffiError implements Disconnected__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'SshError';
		readonly tag = SshError_Tags.Disconnected;
		constructor() {
			super('SshError', 'Disconnected');
		}

		static new(): Disconnected_ {
			return new Disconnected_();
		}

		static instanceOf(obj: any): obj is Disconnected_ {
			return obj.tag === SshError_Tags.Disconnected;
		}

		static hasInner(obj: any): obj is Disconnected_ {
			return false;
		}
	}

	type UnsupportedKeyType__interface = {
		tag: SshError_Tags.UnsupportedKeyType;
	};

	class UnsupportedKeyType_
		extends UniffiError
		implements UnsupportedKeyType__interface
	{
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'SshError';
		readonly tag = SshError_Tags.UnsupportedKeyType;
		constructor() {
			super('SshError', 'UnsupportedKeyType');
		}

		static new(): UnsupportedKeyType_ {
			return new UnsupportedKeyType_();
		}

		static instanceOf(obj: any): obj is UnsupportedKeyType_ {
			return obj.tag === SshError_Tags.UnsupportedKeyType;
		}

		static hasInner(obj: any): obj is UnsupportedKeyType_ {
			return false;
		}
	}

	type Auth__interface = {
		tag: SshError_Tags.Auth;
		inner: Readonly<[string]>;
	};

	class Auth_ extends UniffiError implements Auth__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'SshError';
		readonly tag = SshError_Tags.Auth;
		readonly inner: Readonly<[string]>;
		constructor(v0: string) {
			super('SshError', 'Auth');
			this.inner = Object.freeze([v0]);
		}

		static new(v0: string): Auth_ {
			return new Auth_(v0);
		}

		static instanceOf(obj: any): obj is Auth_ {
			return obj.tag === SshError_Tags.Auth;
		}

		static hasInner(obj: any): obj is Auth_ {
			return Auth_.instanceOf(obj);
		}

		static getInner(obj: Auth_): Readonly<[string]> {
			return obj.inner;
		}
	}

	type ShellAlreadyRunning__interface = {
		tag: SshError_Tags.ShellAlreadyRunning;
	};

	class ShellAlreadyRunning_
		extends UniffiError
		implements ShellAlreadyRunning__interface
	{
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'SshError';
		readonly tag = SshError_Tags.ShellAlreadyRunning;
		constructor() {
			super('SshError', 'ShellAlreadyRunning');
		}

		static new(): ShellAlreadyRunning_ {
			return new ShellAlreadyRunning_();
		}

		static instanceOf(obj: any): obj is ShellAlreadyRunning_ {
			return obj.tag === SshError_Tags.ShellAlreadyRunning;
		}

		static hasInner(obj: any): obj is ShellAlreadyRunning_ {
			return false;
		}
	}

	type Russh__interface = {
		tag: SshError_Tags.Russh;
		inner: Readonly<[string]>;
	};

	class Russh_ extends UniffiError implements Russh__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'SshError';
		readonly tag = SshError_Tags.Russh;
		readonly inner: Readonly<[string]>;
		constructor(v0: string) {
			super('SshError', 'Russh');
			this.inner = Object.freeze([v0]);
		}

		static new(v0: string): Russh_ {
			return new Russh_(v0);
		}

		static instanceOf(obj: any): obj is Russh_ {
			return obj.tag === SshError_Tags.Russh;
		}

		static hasInner(obj: any): obj is Russh_ {
			return Russh_.instanceOf(obj);
		}

		static getInner(obj: Russh_): Readonly<[string]> {
			return obj.inner;
		}
	}

	type RusshKeys__interface = {
		tag: SshError_Tags.RusshKeys;
		inner: Readonly<[string]>;
	};

	class RusshKeys_ extends UniffiError implements RusshKeys__interface {
		/**
		 * @private
		 * This field is private and should not be used, use `tag` instead.
		 */
		readonly [uniffiTypeNameSymbol] = 'SshError';
		readonly tag = SshError_Tags.RusshKeys;
		readonly inner: Readonly<[string]>;
		constructor(v0: string) {
			super('SshError', 'RusshKeys');
			this.inner = Object.freeze([v0]);
		}

		static new(v0: string): RusshKeys_ {
			return new RusshKeys_(v0);
		}

		static instanceOf(obj: any): obj is RusshKeys_ {
			return obj.tag === SshError_Tags.RusshKeys;
		}

		static hasInner(obj: any): obj is RusshKeys_ {
			return RusshKeys_.instanceOf(obj);
		}

		static getInner(obj: RusshKeys_): Readonly<[string]> {
			return obj.inner;
		}
	}

	function instanceOf(obj: any): obj is SshError {
		return obj[uniffiTypeNameSymbol] === 'SshError';
	}

	return Object.freeze({
		instanceOf,
		Disconnected: Disconnected_,
		UnsupportedKeyType: UnsupportedKeyType_,
		Auth: Auth_,
		ShellAlreadyRunning: ShellAlreadyRunning_,
		Russh: Russh_,
		RusshKeys: RusshKeys_,
	});
})();

export type SshError = InstanceType<
	(typeof SshError)[keyof Omit<typeof SshError, 'instanceOf'>]
>;

// FfiConverter for enum SshError
const FfiConverterTypeSshError = (() => {
	const ordinalConverter = FfiConverterInt32;
	type TypeName = SshError;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			switch (ordinalConverter.read(from)) {
				case 1:
					return new SshError.Disconnected();
				case 2:
					return new SshError.UnsupportedKeyType();
				case 3:
					return new SshError.Auth(FfiConverterString.read(from));
				case 4:
					return new SshError.ShellAlreadyRunning();
				case 5:
					return new SshError.Russh(FfiConverterString.read(from));
				case 6:
					return new SshError.RusshKeys(FfiConverterString.read(from));
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		write(value: TypeName, into: RustBuffer): void {
			switch (value.tag) {
				case SshError_Tags.Disconnected: {
					ordinalConverter.write(1, into);
					return;
				}
				case SshError_Tags.UnsupportedKeyType: {
					ordinalConverter.write(2, into);
					return;
				}
				case SshError_Tags.Auth: {
					ordinalConverter.write(3, into);
					const inner = value.inner;
					FfiConverterString.write(inner[0], into);
					return;
				}
				case SshError_Tags.ShellAlreadyRunning: {
					ordinalConverter.write(4, into);
					return;
				}
				case SshError_Tags.Russh: {
					ordinalConverter.write(5, into);
					const inner = value.inner;
					FfiConverterString.write(inner[0], into);
					return;
				}
				case SshError_Tags.RusshKeys: {
					ordinalConverter.write(6, into);
					const inner = value.inner;
					FfiConverterString.write(inner[0], into);
					return;
				}
				default:
					// Throwing from here means that SshError_Tags hasn't matched an ordinal.
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		allocationSize(value: TypeName): number {
			switch (value.tag) {
				case SshError_Tags.Disconnected: {
					return ordinalConverter.allocationSize(1);
				}
				case SshError_Tags.UnsupportedKeyType: {
					return ordinalConverter.allocationSize(2);
				}
				case SshError_Tags.Auth: {
					const inner = value.inner;
					let size = ordinalConverter.allocationSize(3);
					size += FfiConverterString.allocationSize(inner[0]);
					return size;
				}
				case SshError_Tags.ShellAlreadyRunning: {
					return ordinalConverter.allocationSize(4);
				}
				case SshError_Tags.Russh: {
					const inner = value.inner;
					let size = ordinalConverter.allocationSize(5);
					size += FfiConverterString.allocationSize(inner[0]);
					return size;
				}
				case SshError_Tags.RusshKeys: {
					const inner = value.inner;
					let size = ordinalConverter.allocationSize(6);
					size += FfiConverterString.allocationSize(inner[0]);
					return size;
				}
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
	}
	return new FFIConverter();
})();

export enum StreamKind {
	Stdout,
	Stderr,
}

const FfiConverterTypeStreamKind = (() => {
	const ordinalConverter = FfiConverterInt32;
	type TypeName = StreamKind;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			switch (ordinalConverter.read(from)) {
				case 1:
					return StreamKind.Stdout;
				case 2:
					return StreamKind.Stderr;
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		write(value: TypeName, into: RustBuffer): void {
			switch (value) {
				case StreamKind.Stdout:
					return ordinalConverter.write(1, into);
				case StreamKind.Stderr:
					return ordinalConverter.write(2, into);
			}
		}
		allocationSize(value: TypeName): number {
			return ordinalConverter.allocationSize(0);
		}
	}
	return new FFIConverter();
})();

export enum TerminalType {
	Vanilla,
	Vt100,
	Vt102,
	Vt220,
	Ansi,
	Xterm,
	Xterm256,
}

const FfiConverterTypeTerminalType = (() => {
	const ordinalConverter = FfiConverterInt32;
	type TypeName = TerminalType;
	class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
		read(from: RustBuffer): TypeName {
			switch (ordinalConverter.read(from)) {
				case 1:
					return TerminalType.Vanilla;
				case 2:
					return TerminalType.Vt100;
				case 3:
					return TerminalType.Vt102;
				case 4:
					return TerminalType.Vt220;
				case 5:
					return TerminalType.Ansi;
				case 6:
					return TerminalType.Xterm;
				case 7:
					return TerminalType.Xterm256;
				default:
					throw new UniffiInternalError.UnexpectedEnumCase();
			}
		}
		write(value: TypeName, into: RustBuffer): void {
			switch (value) {
				case TerminalType.Vanilla:
					return ordinalConverter.write(1, into);
				case TerminalType.Vt100:
					return ordinalConverter.write(2, into);
				case TerminalType.Vt102:
					return ordinalConverter.write(3, into);
				case TerminalType.Vt220:
					return ordinalConverter.write(4, into);
				case TerminalType.Ansi:
					return ordinalConverter.write(5, into);
				case TerminalType.Xterm:
					return ordinalConverter.write(6, into);
				case TerminalType.Xterm256:
					return ordinalConverter.write(7, into);
			}
		}
		allocationSize(value: TypeName): number {
			return ordinalConverter.allocationSize(0);
		}
	}
	return new FFIConverter();
})();

export interface ConnectProgressCallback {
	onChange(status: SshConnectionProgressEvent): void;
}

export class ConnectProgressCallbackImpl
	extends UniffiAbstractObject
	implements ConnectProgressCallback
{
	readonly [uniffiTypeNameSymbol] = 'ConnectProgressCallbackImpl';
	readonly [destructorGuardSymbol]: UniffiRustArcPtr;
	readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
	// No primary constructor declared for this class.
	private constructor(pointer: UnsafeMutableRawPointer) {
		super();
		this[pointerLiteralSymbol] = pointer;
		this[destructorGuardSymbol] =
			uniffiTypeConnectProgressCallbackImplObjectFactory.bless(pointer);
	}

	public onChange(status: SshConnectionProgressEvent): void {
		uniffiCaller.rustCall(
			/*caller:*/ (callStatus) => {
				nativeModule().ubrn_uniffi_uniffi_russh_fn_method_connectprogresscallback_on_change(
					uniffiTypeConnectProgressCallbackImplObjectFactory.clonePointer(this),
					FfiConverterTypeSshConnectionProgressEvent.lower(status),
					callStatus,
				);
			},
			/*liftString:*/ FfiConverterString.lift,
		);
	}

	/**
	 * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
	 */
	uniffiDestroy(): void {
		const ptr = (this as any)[destructorGuardSymbol];
		if (ptr !== undefined) {
			const pointer =
				uniffiTypeConnectProgressCallbackImplObjectFactory.pointer(this);
			uniffiTypeConnectProgressCallbackImplObjectFactory.freePointer(pointer);
			uniffiTypeConnectProgressCallbackImplObjectFactory.unbless(ptr);
			delete (this as any)[destructorGuardSymbol];
		}
	}

	static instanceOf(obj: any): obj is ConnectProgressCallbackImpl {
		return uniffiTypeConnectProgressCallbackImplObjectFactory.isConcreteType(
			obj,
		);
	}
}

const uniffiTypeConnectProgressCallbackImplObjectFactory: UniffiObjectFactory<ConnectProgressCallback> =
	(() => {
		return {
			create(pointer: UnsafeMutableRawPointer): ConnectProgressCallback {
				const instance = Object.create(ConnectProgressCallbackImpl.prototype);
				instance[pointerLiteralSymbol] = pointer;
				instance[destructorGuardSymbol] = this.bless(pointer);
				instance[uniffiTypeNameSymbol] = 'ConnectProgressCallbackImpl';
				return instance;
			},

			bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
				return uniffiCaller.rustCall(
					/*caller:*/ (status) =>
						nativeModule().ubrn_uniffi_internal_fn_method_connectprogresscallback_ffi__bless_pointer(
							p,
							status,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			unbless(ptr: UniffiRustArcPtr) {
				ptr.markDestroyed();
			},

			pointer(obj: ConnectProgressCallback): UnsafeMutableRawPointer {
				if ((obj as any)[destructorGuardSymbol] === undefined) {
					throw new UniffiInternalError.UnexpectedNullPointer();
				}
				return (obj as any)[pointerLiteralSymbol];
			},

			clonePointer(obj: ConnectProgressCallback): UnsafeMutableRawPointer {
				const pointer = this.pointer(obj);
				return uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_connectprogresscallback(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			freePointer(pointer: UnsafeMutableRawPointer): void {
				uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_free_connectprogresscallback(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			isConcreteType(obj: any): obj is ConnectProgressCallback {
				return (
					obj[destructorGuardSymbol] &&
					obj[uniffiTypeNameSymbol] === 'ConnectProgressCallbackImpl'
				);
			},
		};
	})();
// FfiConverter for ConnectProgressCallback
const FfiConverterTypeConnectProgressCallback =
	new FfiConverterObjectWithCallbacks(
		uniffiTypeConnectProgressCallbackImplObjectFactory,
	);

// Add a vtavble for the callbacks that go in ConnectProgressCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceConnectProgressCallback: {
	vtable: UniffiVTableCallbackInterfaceConnectProgressCallback;
	register: () => void;
} = {
	// Create the VTable using a series of closures.
	// ts automatically converts these into C callback functions.
	vtable: {
		onChange: (uniffiHandle: bigint, status: Uint8Array) => {
			const uniffiMakeCall = (): void => {
				const jsCallback =
					FfiConverterTypeConnectProgressCallback.lift(uniffiHandle);
				return jsCallback.onChange(
					FfiConverterTypeSshConnectionProgressEvent.lift(status),
				);
			};
			const uniffiResult = UniffiResult.ready<void>();
			const uniffiHandleSuccess = (obj: any) => {};
			const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
				UniffiResult.writeError(uniffiResult, code, errBuf);
			};
			uniffiTraitInterfaceCall(
				/*makeCall:*/ uniffiMakeCall,
				/*handleSuccess:*/ uniffiHandleSuccess,
				/*handleError:*/ uniffiHandleError,
				/*lowerString:*/ FfiConverterString.lower,
			);
			return uniffiResult;
		},
		uniffiFree: (uniffiHandle: UniffiHandle): void => {
			// ConnectProgressCallback: this will throw a stale handle error if the handle isn't found.
			FfiConverterTypeConnectProgressCallback.drop(uniffiHandle);
		},
	},
	register: () => {
		nativeModule().ubrn_uniffi_uniffi_russh_fn_init_callback_vtable_connectprogresscallback(
			uniffiCallbackInterfaceConnectProgressCallback.vtable,
		);
	},
};

export interface ConnectionDisconnectedCallback {
	onChange(connectionId: string): void;
}

export class ConnectionDisconnectedCallbackImpl
	extends UniffiAbstractObject
	implements ConnectionDisconnectedCallback
{
	readonly [uniffiTypeNameSymbol] = 'ConnectionDisconnectedCallbackImpl';
	readonly [destructorGuardSymbol]: UniffiRustArcPtr;
	readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
	// No primary constructor declared for this class.
	private constructor(pointer: UnsafeMutableRawPointer) {
		super();
		this[pointerLiteralSymbol] = pointer;
		this[destructorGuardSymbol] =
			uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.bless(pointer);
	}

	public onChange(connectionId: string): void {
		uniffiCaller.rustCall(
			/*caller:*/ (callStatus) => {
				nativeModule().ubrn_uniffi_uniffi_russh_fn_method_connectiondisconnectedcallback_on_change(
					uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.clonePointer(
						this,
					),
					FfiConverterString.lower(connectionId),
					callStatus,
				);
			},
			/*liftString:*/ FfiConverterString.lift,
		);
	}

	/**
	 * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
	 */
	uniffiDestroy(): void {
		const ptr = (this as any)[destructorGuardSymbol];
		if (ptr !== undefined) {
			const pointer =
				uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.pointer(this);
			uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.freePointer(
				pointer,
			);
			uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.unbless(ptr);
			delete (this as any)[destructorGuardSymbol];
		}
	}

	static instanceOf(obj: any): obj is ConnectionDisconnectedCallbackImpl {
		return uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.isConcreteType(
			obj,
		);
	}
}

const uniffiTypeConnectionDisconnectedCallbackImplObjectFactory: UniffiObjectFactory<ConnectionDisconnectedCallback> =
	(() => {
		return {
			create(pointer: UnsafeMutableRawPointer): ConnectionDisconnectedCallback {
				const instance = Object.create(
					ConnectionDisconnectedCallbackImpl.prototype,
				);
				instance[pointerLiteralSymbol] = pointer;
				instance[destructorGuardSymbol] = this.bless(pointer);
				instance[uniffiTypeNameSymbol] = 'ConnectionDisconnectedCallbackImpl';
				return instance;
			},

			bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
				return uniffiCaller.rustCall(
					/*caller:*/ (status) =>
						nativeModule().ubrn_uniffi_internal_fn_method_connectiondisconnectedcallback_ffi__bless_pointer(
							p,
							status,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			unbless(ptr: UniffiRustArcPtr) {
				ptr.markDestroyed();
			},

			pointer(obj: ConnectionDisconnectedCallback): UnsafeMutableRawPointer {
				if ((obj as any)[destructorGuardSymbol] === undefined) {
					throw new UniffiInternalError.UnexpectedNullPointer();
				}
				return (obj as any)[pointerLiteralSymbol];
			},

			clonePointer(
				obj: ConnectionDisconnectedCallback,
			): UnsafeMutableRawPointer {
				const pointer = this.pointer(obj);
				return uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_connectiondisconnectedcallback(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			freePointer(pointer: UnsafeMutableRawPointer): void {
				uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_free_connectiondisconnectedcallback(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			isConcreteType(obj: any): obj is ConnectionDisconnectedCallback {
				return (
					obj[destructorGuardSymbol] &&
					obj[uniffiTypeNameSymbol] === 'ConnectionDisconnectedCallbackImpl'
				);
			},
		};
	})();
// FfiConverter for ConnectionDisconnectedCallback
const FfiConverterTypeConnectionDisconnectedCallback =
	new FfiConverterObjectWithCallbacks(
		uniffiTypeConnectionDisconnectedCallbackImplObjectFactory,
	);

// Add a vtavble for the callbacks that go in ConnectionDisconnectedCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceConnectionDisconnectedCallback: {
	vtable: UniffiVTableCallbackInterfaceConnectionDisconnectedCallback;
	register: () => void;
} = {
	// Create the VTable using a series of closures.
	// ts automatically converts these into C callback functions.
	vtable: {
		onChange: (uniffiHandle: bigint, connectionId: Uint8Array) => {
			const uniffiMakeCall = (): void => {
				const jsCallback =
					FfiConverterTypeConnectionDisconnectedCallback.lift(uniffiHandle);
				return jsCallback.onChange(FfiConverterString.lift(connectionId));
			};
			const uniffiResult = UniffiResult.ready<void>();
			const uniffiHandleSuccess = (obj: any) => {};
			const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
				UniffiResult.writeError(uniffiResult, code, errBuf);
			};
			uniffiTraitInterfaceCall(
				/*makeCall:*/ uniffiMakeCall,
				/*handleSuccess:*/ uniffiHandleSuccess,
				/*handleError:*/ uniffiHandleError,
				/*lowerString:*/ FfiConverterString.lower,
			);
			return uniffiResult;
		},
		uniffiFree: (uniffiHandle: UniffiHandle): void => {
			// ConnectionDisconnectedCallback: this will throw a stale handle error if the handle isn't found.
			FfiConverterTypeConnectionDisconnectedCallback.drop(uniffiHandle);
		},
	},
	register: () => {
		nativeModule().ubrn_uniffi_uniffi_russh_fn_init_callback_vtable_connectiondisconnectedcallback(
			uniffiCallbackInterfaceConnectionDisconnectedCallback.vtable,
		);
	},
};

export interface ServerKeyCallback {
	onChange(
		serverKeyInfo: ServerPublicKeyInfo,
		asyncOpts_?: { signal: AbortSignal },
	): Promise<boolean>;
}

export class ServerKeyCallbackImpl
	extends UniffiAbstractObject
	implements ServerKeyCallback
{
	readonly [uniffiTypeNameSymbol] = 'ServerKeyCallbackImpl';
	readonly [destructorGuardSymbol]: UniffiRustArcPtr;
	readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
	// No primary constructor declared for this class.
	private constructor(pointer: UnsafeMutableRawPointer) {
		super();
		this[pointerLiteralSymbol] = pointer;
		this[destructorGuardSymbol] =
			uniffiTypeServerKeyCallbackImplObjectFactory.bless(pointer);
	}

	public async onChange(
		serverKeyInfo: ServerPublicKeyInfo,
		asyncOpts_?: { signal: AbortSignal },
	): Promise<boolean> {
		const __stack = uniffiIsDebug ? new Error().stack : undefined;
		try {
			return await uniffiRustCallAsync(
				/*rustCaller:*/ uniffiCaller,
				/*rustFutureFunc:*/ () => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_serverkeycallback_on_change(
						uniffiTypeServerKeyCallbackImplObjectFactory.clonePointer(this),
						FfiConverterTypeServerPublicKeyInfo.lower(serverKeyInfo),
					);
				},
				/*pollFunc:*/ nativeModule().ubrn_ffi_uniffi_russh_rust_future_poll_i8,
				/*cancelFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_cancel_i8,
				/*completeFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_complete_i8,
				/*freeFunc:*/ nativeModule().ubrn_ffi_uniffi_russh_rust_future_free_i8,
				/*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
				/*liftString:*/ FfiConverterString.lift,
				/*asyncOpts:*/ asyncOpts_,
			);
		} catch (__error: any) {
			if (uniffiIsDebug && __error instanceof Error) {
				__error.stack = __stack;
			}
			throw __error;
		}
	}

	/**
	 * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
	 */
	uniffiDestroy(): void {
		const ptr = (this as any)[destructorGuardSymbol];
		if (ptr !== undefined) {
			const pointer =
				uniffiTypeServerKeyCallbackImplObjectFactory.pointer(this);
			uniffiTypeServerKeyCallbackImplObjectFactory.freePointer(pointer);
			uniffiTypeServerKeyCallbackImplObjectFactory.unbless(ptr);
			delete (this as any)[destructorGuardSymbol];
		}
	}

	static instanceOf(obj: any): obj is ServerKeyCallbackImpl {
		return uniffiTypeServerKeyCallbackImplObjectFactory.isConcreteType(obj);
	}
}

const uniffiTypeServerKeyCallbackImplObjectFactory: UniffiObjectFactory<ServerKeyCallback> =
	(() => {
		return {
			create(pointer: UnsafeMutableRawPointer): ServerKeyCallback {
				const instance = Object.create(ServerKeyCallbackImpl.prototype);
				instance[pointerLiteralSymbol] = pointer;
				instance[destructorGuardSymbol] = this.bless(pointer);
				instance[uniffiTypeNameSymbol] = 'ServerKeyCallbackImpl';
				return instance;
			},

			bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
				return uniffiCaller.rustCall(
					/*caller:*/ (status) =>
						nativeModule().ubrn_uniffi_internal_fn_method_serverkeycallback_ffi__bless_pointer(
							p,
							status,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			unbless(ptr: UniffiRustArcPtr) {
				ptr.markDestroyed();
			},

			pointer(obj: ServerKeyCallback): UnsafeMutableRawPointer {
				if ((obj as any)[destructorGuardSymbol] === undefined) {
					throw new UniffiInternalError.UnexpectedNullPointer();
				}
				return (obj as any)[pointerLiteralSymbol];
			},

			clonePointer(obj: ServerKeyCallback): UnsafeMutableRawPointer {
				const pointer = this.pointer(obj);
				return uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_serverkeycallback(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			freePointer(pointer: UnsafeMutableRawPointer): void {
				uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_free_serverkeycallback(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			isConcreteType(obj: any): obj is ServerKeyCallback {
				return (
					obj[destructorGuardSymbol] &&
					obj[uniffiTypeNameSymbol] === 'ServerKeyCallbackImpl'
				);
			},
		};
	})();
// FfiConverter for ServerKeyCallback
const FfiConverterTypeServerKeyCallback = new FfiConverterObjectWithCallbacks(
	uniffiTypeServerKeyCallbackImplObjectFactory,
);

// Add a vtavble for the callbacks that go in ServerKeyCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceServerKeyCallback: {
	vtable: UniffiVTableCallbackInterfaceServerKeyCallback;
	register: () => void;
} = {
	// Create the VTable using a series of closures.
	// ts automatically converts these into C callback functions.
	vtable: {
		onChange: (
			uniffiHandle: bigint,
			serverKeyInfo: Uint8Array,
			uniffiFutureCallback: UniffiForeignFutureCompleteI8,
			uniffiCallbackData: bigint,
		) => {
			const uniffiMakeCall = async (signal: AbortSignal): Promise<boolean> => {
				const jsCallback = FfiConverterTypeServerKeyCallback.lift(uniffiHandle);
				return await jsCallback.onChange(
					FfiConverterTypeServerPublicKeyInfo.lift(serverKeyInfo),
					{ signal },
				);
			};
			const uniffiHandleSuccess = (returnValue: boolean) => {
				uniffiFutureCallback.call(
					uniffiFutureCallback,
					uniffiCallbackData,
					/* UniffiForeignFutureStructI8 */ {
						returnValue: FfiConverterBool.lower(returnValue),
						callStatus: uniffiCaller.createCallStatus(),
					},
				);
			};
			const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
				uniffiFutureCallback.call(
					uniffiFutureCallback,
					uniffiCallbackData,
					/* UniffiForeignFutureStructI8 */ {
						returnValue: 0,
						// TODO create callstatus with error.
						callStatus: uniffiCaller.createErrorStatus(code, errorBuf),
					},
				);
			};
			const uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
				/*makeCall:*/ uniffiMakeCall,
				/*handleSuccess:*/ uniffiHandleSuccess,
				/*handleError:*/ uniffiHandleError,
				/*lowerString:*/ FfiConverterString.lower,
			);
			return uniffiForeignFuture;
		},
		uniffiFree: (uniffiHandle: UniffiHandle): void => {
			// ServerKeyCallback: this will throw a stale handle error if the handle isn't found.
			FfiConverterTypeServerKeyCallback.drop(uniffiHandle);
		},
	},
	register: () => {
		nativeModule().ubrn_uniffi_uniffi_russh_fn_init_callback_vtable_serverkeycallback(
			uniffiCallbackInterfaceServerKeyCallback.vtable,
		);
	},
};

export interface ShellClosedCallback {
	onChange(channelId: /*u32*/ number): void;
}

export class ShellClosedCallbackImpl
	extends UniffiAbstractObject
	implements ShellClosedCallback
{
	readonly [uniffiTypeNameSymbol] = 'ShellClosedCallbackImpl';
	readonly [destructorGuardSymbol]: UniffiRustArcPtr;
	readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
	// No primary constructor declared for this class.
	private constructor(pointer: UnsafeMutableRawPointer) {
		super();
		this[pointerLiteralSymbol] = pointer;
		this[destructorGuardSymbol] =
			uniffiTypeShellClosedCallbackImplObjectFactory.bless(pointer);
	}

	public onChange(channelId: /*u32*/ number): void {
		uniffiCaller.rustCall(
			/*caller:*/ (callStatus) => {
				nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellclosedcallback_on_change(
					uniffiTypeShellClosedCallbackImplObjectFactory.clonePointer(this),
					FfiConverterUInt32.lower(channelId),
					callStatus,
				);
			},
			/*liftString:*/ FfiConverterString.lift,
		);
	}

	/**
	 * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
	 */
	uniffiDestroy(): void {
		const ptr = (this as any)[destructorGuardSymbol];
		if (ptr !== undefined) {
			const pointer =
				uniffiTypeShellClosedCallbackImplObjectFactory.pointer(this);
			uniffiTypeShellClosedCallbackImplObjectFactory.freePointer(pointer);
			uniffiTypeShellClosedCallbackImplObjectFactory.unbless(ptr);
			delete (this as any)[destructorGuardSymbol];
		}
	}

	static instanceOf(obj: any): obj is ShellClosedCallbackImpl {
		return uniffiTypeShellClosedCallbackImplObjectFactory.isConcreteType(obj);
	}
}

const uniffiTypeShellClosedCallbackImplObjectFactory: UniffiObjectFactory<ShellClosedCallback> =
	(() => {
		return {
			create(pointer: UnsafeMutableRawPointer): ShellClosedCallback {
				const instance = Object.create(ShellClosedCallbackImpl.prototype);
				instance[pointerLiteralSymbol] = pointer;
				instance[destructorGuardSymbol] = this.bless(pointer);
				instance[uniffiTypeNameSymbol] = 'ShellClosedCallbackImpl';
				return instance;
			},

			bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
				return uniffiCaller.rustCall(
					/*caller:*/ (status) =>
						nativeModule().ubrn_uniffi_internal_fn_method_shellclosedcallback_ffi__bless_pointer(
							p,
							status,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			unbless(ptr: UniffiRustArcPtr) {
				ptr.markDestroyed();
			},

			pointer(obj: ShellClosedCallback): UnsafeMutableRawPointer {
				if ((obj as any)[destructorGuardSymbol] === undefined) {
					throw new UniffiInternalError.UnexpectedNullPointer();
				}
				return (obj as any)[pointerLiteralSymbol];
			},

			clonePointer(obj: ShellClosedCallback): UnsafeMutableRawPointer {
				const pointer = this.pointer(obj);
				return uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_shellclosedcallback(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			freePointer(pointer: UnsafeMutableRawPointer): void {
				uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_free_shellclosedcallback(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			isConcreteType(obj: any): obj is ShellClosedCallback {
				return (
					obj[destructorGuardSymbol] &&
					obj[uniffiTypeNameSymbol] === 'ShellClosedCallbackImpl'
				);
			},
		};
	})();
// FfiConverter for ShellClosedCallback
const FfiConverterTypeShellClosedCallback = new FfiConverterObjectWithCallbacks(
	uniffiTypeShellClosedCallbackImplObjectFactory,
);

// Add a vtavble for the callbacks that go in ShellClosedCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceShellClosedCallback: {
	vtable: UniffiVTableCallbackInterfaceShellClosedCallback;
	register: () => void;
} = {
	// Create the VTable using a series of closures.
	// ts automatically converts these into C callback functions.
	vtable: {
		onChange: (uniffiHandle: bigint, channelId: number) => {
			const uniffiMakeCall = (): void => {
				const jsCallback =
					FfiConverterTypeShellClosedCallback.lift(uniffiHandle);
				return jsCallback.onChange(FfiConverterUInt32.lift(channelId));
			};
			const uniffiResult = UniffiResult.ready<void>();
			const uniffiHandleSuccess = (obj: any) => {};
			const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
				UniffiResult.writeError(uniffiResult, code, errBuf);
			};
			uniffiTraitInterfaceCall(
				/*makeCall:*/ uniffiMakeCall,
				/*handleSuccess:*/ uniffiHandleSuccess,
				/*handleError:*/ uniffiHandleError,
				/*lowerString:*/ FfiConverterString.lower,
			);
			return uniffiResult;
		},
		uniffiFree: (uniffiHandle: UniffiHandle): void => {
			// ShellClosedCallback: this will throw a stale handle error if the handle isn't found.
			FfiConverterTypeShellClosedCallback.drop(uniffiHandle);
		},
	},
	register: () => {
		nativeModule().ubrn_uniffi_uniffi_russh_fn_init_callback_vtable_shellclosedcallback(
			uniffiCallbackInterfaceShellClosedCallback.vtable,
		);
	},
};

export interface ShellListener {
	onEvent(ev: ShellEvent): void;
}

export class ShellListenerImpl
	extends UniffiAbstractObject
	implements ShellListener
{
	readonly [uniffiTypeNameSymbol] = 'ShellListenerImpl';
	readonly [destructorGuardSymbol]: UniffiRustArcPtr;
	readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
	// No primary constructor declared for this class.
	private constructor(pointer: UnsafeMutableRawPointer) {
		super();
		this[pointerLiteralSymbol] = pointer;
		this[destructorGuardSymbol] =
			uniffiTypeShellListenerImplObjectFactory.bless(pointer);
	}

	public onEvent(ev: ShellEvent): void {
		uniffiCaller.rustCall(
			/*caller:*/ (callStatus) => {
				nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shelllistener_on_event(
					uniffiTypeShellListenerImplObjectFactory.clonePointer(this),
					FfiConverterTypeShellEvent.lower(ev),
					callStatus,
				);
			},
			/*liftString:*/ FfiConverterString.lift,
		);
	}

	/**
	 * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
	 */
	uniffiDestroy(): void {
		const ptr = (this as any)[destructorGuardSymbol];
		if (ptr !== undefined) {
			const pointer = uniffiTypeShellListenerImplObjectFactory.pointer(this);
			uniffiTypeShellListenerImplObjectFactory.freePointer(pointer);
			uniffiTypeShellListenerImplObjectFactory.unbless(ptr);
			delete (this as any)[destructorGuardSymbol];
		}
	}

	static instanceOf(obj: any): obj is ShellListenerImpl {
		return uniffiTypeShellListenerImplObjectFactory.isConcreteType(obj);
	}
}

const uniffiTypeShellListenerImplObjectFactory: UniffiObjectFactory<ShellListener> =
	(() => {
		return {
			create(pointer: UnsafeMutableRawPointer): ShellListener {
				const instance = Object.create(ShellListenerImpl.prototype);
				instance[pointerLiteralSymbol] = pointer;
				instance[destructorGuardSymbol] = this.bless(pointer);
				instance[uniffiTypeNameSymbol] = 'ShellListenerImpl';
				return instance;
			},

			bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
				return uniffiCaller.rustCall(
					/*caller:*/ (status) =>
						nativeModule().ubrn_uniffi_internal_fn_method_shelllistener_ffi__bless_pointer(
							p,
							status,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			unbless(ptr: UniffiRustArcPtr) {
				ptr.markDestroyed();
			},

			pointer(obj: ShellListener): UnsafeMutableRawPointer {
				if ((obj as any)[destructorGuardSymbol] === undefined) {
					throw new UniffiInternalError.UnexpectedNullPointer();
				}
				return (obj as any)[pointerLiteralSymbol];
			},

			clonePointer(obj: ShellListener): UnsafeMutableRawPointer {
				const pointer = this.pointer(obj);
				return uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_shelllistener(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			freePointer(pointer: UnsafeMutableRawPointer): void {
				uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_free_shelllistener(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			isConcreteType(obj: any): obj is ShellListener {
				return (
					obj[destructorGuardSymbol] &&
					obj[uniffiTypeNameSymbol] === 'ShellListenerImpl'
				);
			},
		};
	})();
// FfiConverter for ShellListener
const FfiConverterTypeShellListener = new FfiConverterObjectWithCallbacks(
	uniffiTypeShellListenerImplObjectFactory,
);

// Add a vtavble for the callbacks that go in ShellListener.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceShellListener: {
	vtable: UniffiVTableCallbackInterfaceShellListener;
	register: () => void;
} = {
	// Create the VTable using a series of closures.
	// ts automatically converts these into C callback functions.
	vtable: {
		onEvent: (uniffiHandle: bigint, ev: Uint8Array) => {
			const uniffiMakeCall = (): void => {
				const jsCallback = FfiConverterTypeShellListener.lift(uniffiHandle);
				return jsCallback.onEvent(FfiConverterTypeShellEvent.lift(ev));
			};
			const uniffiResult = UniffiResult.ready<void>();
			const uniffiHandleSuccess = (obj: any) => {};
			const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
				UniffiResult.writeError(uniffiResult, code, errBuf);
			};
			uniffiTraitInterfaceCall(
				/*makeCall:*/ uniffiMakeCall,
				/*handleSuccess:*/ uniffiHandleSuccess,
				/*handleError:*/ uniffiHandleError,
				/*lowerString:*/ FfiConverterString.lower,
			);
			return uniffiResult;
		},
		uniffiFree: (uniffiHandle: UniffiHandle): void => {
			// ShellListener: this will throw a stale handle error if the handle isn't found.
			FfiConverterTypeShellListener.drop(uniffiHandle);
		},
	},
	register: () => {
		nativeModule().ubrn_uniffi_uniffi_russh_fn_init_callback_vtable_shelllistener(
			uniffiCallbackInterfaceShellListener.vtable,
		);
	},
};

export interface ShellSessionInterface {
	/**
	 * Add a listener with optional replay and live follow.
	 */
	addListener(
		listener: ShellListener,
		opts: ListenerOptions,
	) /*throws*/ : /*u64*/ bigint;
	/**
	 * Buffer statistics snapshot.
	 */
	bufferStats(): BufferStats;
	/**
	 * Close the associated shell channel and stop its reader task.
	 */
	close(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
	/**
	 * Current next sequence number.
	 */
	currentSeq(): /*u64*/ bigint;
	getInfo(): ShellSessionInfo;
	/**
	 * Read the ring buffer from a cursor.
	 */
	readBuffer(
		cursor: Cursor,
		maxBytes: /*u64*/ bigint | undefined,
	): BufferReadResult;
	removeListener(id: /*u64*/ bigint): void;
	/**
	 * Resize the PTY window. Call when the terminal UI size changes.
	 * This sends an SSH "window-change" request to the server, which will
	 * deliver SIGWINCH to the remote process (e.g., tmux, vim).
	 */
	resizePty(
		cols: /*u32*/ number,
		rows: /*u32*/ number,
		pixelWidth: /*u32*/ number | undefined,
		pixelHeight: /*u32*/ number | undefined,
		asyncOpts_?: { signal: AbortSignal },
	) /*throws*/ : Promise<void>;
	/**
	 * Send bytes to the active shell (stdin).
	 */
	sendData(
		data: ArrayBuffer,
		asyncOpts_?: { signal: AbortSignal },
	) /*throws*/ : Promise<void>;
}

export class ShellSession
	extends UniffiAbstractObject
	implements ShellSessionInterface
{
	readonly [uniffiTypeNameSymbol] = 'ShellSession';
	readonly [destructorGuardSymbol]: UniffiRustArcPtr;
	readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
	// No primary constructor declared for this class.
	private constructor(pointer: UnsafeMutableRawPointer) {
		super();
		this[pointerLiteralSymbol] = pointer;
		this[destructorGuardSymbol] =
			uniffiTypeShellSessionObjectFactory.bless(pointer);
	}

	/**
	 * Add a listener with optional replay and live follow.
	 */
	public addListener(
		listener: ShellListener,
		opts: ListenerOptions,
	): /*u64*/ bigint /*throws*/ {
		return FfiConverterUInt64.lift(
			uniffiCaller.rustCallWithError(
				/*liftError:*/ FfiConverterTypeSshError.lift.bind(
					FfiConverterTypeSshError,
				),
				/*caller:*/ (callStatus) => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_add_listener(
						uniffiTypeShellSessionObjectFactory.clonePointer(this),
						FfiConverterTypeShellListener.lower(listener),
						FfiConverterTypeListenerOptions.lower(opts),
						callStatus,
					);
				},
				/*liftString:*/ FfiConverterString.lift,
			),
		);
	}

	/**
	 * Buffer statistics snapshot.
	 */
	public bufferStats(): BufferStats {
		return FfiConverterTypeBufferStats.lift(
			uniffiCaller.rustCall(
				/*caller:*/ (callStatus) => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_buffer_stats(
						uniffiTypeShellSessionObjectFactory.clonePointer(this),
						callStatus,
					);
				},
				/*liftString:*/ FfiConverterString.lift,
			),
		);
	}

	/**
	 * Close the associated shell channel and stop its reader task.
	 */
	public async close(asyncOpts_?: {
		signal: AbortSignal;
	}): Promise<void> /*throws*/ {
		const __stack = uniffiIsDebug ? new Error().stack : undefined;
		try {
			return await uniffiRustCallAsync(
				/*rustCaller:*/ uniffiCaller,
				/*rustFutureFunc:*/ () => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_close(
						uniffiTypeShellSessionObjectFactory.clonePointer(this),
					);
				},
				/*pollFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_poll_void,
				/*cancelFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_cancel_void,
				/*completeFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_complete_void,
				/*freeFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_free_void,
				/*liftFunc:*/ (_v) => {},
				/*liftString:*/ FfiConverterString.lift,
				/*asyncOpts:*/ asyncOpts_,
				/*errorHandler:*/ FfiConverterTypeSshError.lift.bind(
					FfiConverterTypeSshError,
				),
			);
		} catch (__error: any) {
			if (uniffiIsDebug && __error instanceof Error) {
				__error.stack = __stack;
			}
			throw __error;
		}
	}

	/**
	 * Current next sequence number.
	 */
	public currentSeq(): /*u64*/ bigint {
		return FfiConverterUInt64.lift(
			uniffiCaller.rustCall(
				/*caller:*/ (callStatus) => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_current_seq(
						uniffiTypeShellSessionObjectFactory.clonePointer(this),
						callStatus,
					);
				},
				/*liftString:*/ FfiConverterString.lift,
			),
		);
	}

	public getInfo(): ShellSessionInfo {
		return FfiConverterTypeShellSessionInfo.lift(
			uniffiCaller.rustCall(
				/*caller:*/ (callStatus) => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_get_info(
						uniffiTypeShellSessionObjectFactory.clonePointer(this),
						callStatus,
					);
				},
				/*liftString:*/ FfiConverterString.lift,
			),
		);
	}

	/**
	 * Read the ring buffer from a cursor.
	 */
	public readBuffer(
		cursor: Cursor,
		maxBytes: /*u64*/ bigint | undefined,
	): BufferReadResult {
		return FfiConverterTypeBufferReadResult.lift(
			uniffiCaller.rustCall(
				/*caller:*/ (callStatus) => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_read_buffer(
						uniffiTypeShellSessionObjectFactory.clonePointer(this),
						FfiConverterTypeCursor.lower(cursor),
						FfiConverterOptionalUInt64.lower(maxBytes),
						callStatus,
					);
				},
				/*liftString:*/ FfiConverterString.lift,
			),
		);
	}

	public removeListener(id: /*u64*/ bigint): void {
		uniffiCaller.rustCall(
			/*caller:*/ (callStatus) => {
				nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_remove_listener(
					uniffiTypeShellSessionObjectFactory.clonePointer(this),
					FfiConverterUInt64.lower(id),
					callStatus,
				);
			},
			/*liftString:*/ FfiConverterString.lift,
		);
	}

	/**
	 * Resize the PTY window. Call when the terminal UI size changes.
	 * This sends an SSH "window-change" request to the server, which will
	 * deliver SIGWINCH to the remote process (e.g., tmux, vim).
	 */
	public async resizePty(
		cols: /*u32*/ number,
		rows: /*u32*/ number,
		pixelWidth: /*u32*/ number | undefined,
		pixelHeight: /*u32*/ number | undefined,
		asyncOpts_?: { signal: AbortSignal },
	): Promise<void> /*throws*/ {
		const __stack = uniffiIsDebug ? new Error().stack : undefined;
		try {
			return await uniffiRustCallAsync(
				/*rustCaller:*/ uniffiCaller,
				/*rustFutureFunc:*/ () => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_resize_pty(
						uniffiTypeShellSessionObjectFactory.clonePointer(this),
						FfiConverterUInt32.lower(cols),
						FfiConverterUInt32.lower(rows),
						FfiConverterOptionalUInt32.lower(pixelWidth),
						FfiConverterOptionalUInt32.lower(pixelHeight),
					);
				},
				/*pollFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_poll_void,
				/*cancelFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_cancel_void,
				/*completeFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_complete_void,
				/*freeFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_free_void,
				/*liftFunc:*/ (_v) => {},
				/*liftString:*/ FfiConverterString.lift,
				/*asyncOpts:*/ asyncOpts_,
				/*errorHandler:*/ FfiConverterTypeSshError.lift.bind(
					FfiConverterTypeSshError,
				),
			);
		} catch (__error: any) {
			if (uniffiIsDebug && __error instanceof Error) {
				__error.stack = __stack;
			}
			throw __error;
		}
	}

	/**
	 * Send bytes to the active shell (stdin).
	 */
	public async sendData(
		data: ArrayBuffer,
		asyncOpts_?: { signal: AbortSignal },
	): Promise<void> /*throws*/ {
		const __stack = uniffiIsDebug ? new Error().stack : undefined;
		try {
			return await uniffiRustCallAsync(
				/*rustCaller:*/ uniffiCaller,
				/*rustFutureFunc:*/ () => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_send_data(
						uniffiTypeShellSessionObjectFactory.clonePointer(this),
						FfiConverterArrayBuffer.lower(data),
					);
				},
				/*pollFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_poll_void,
				/*cancelFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_cancel_void,
				/*completeFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_complete_void,
				/*freeFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_free_void,
				/*liftFunc:*/ (_v) => {},
				/*liftString:*/ FfiConverterString.lift,
				/*asyncOpts:*/ asyncOpts_,
				/*errorHandler:*/ FfiConverterTypeSshError.lift.bind(
					FfiConverterTypeSshError,
				),
			);
		} catch (__error: any) {
			if (uniffiIsDebug && __error instanceof Error) {
				__error.stack = __stack;
			}
			throw __error;
		}
	}

	/**
	 * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
	 */
	uniffiDestroy(): void {
		const ptr = (this as any)[destructorGuardSymbol];
		if (ptr !== undefined) {
			const pointer = uniffiTypeShellSessionObjectFactory.pointer(this);
			uniffiTypeShellSessionObjectFactory.freePointer(pointer);
			uniffiTypeShellSessionObjectFactory.unbless(ptr);
			delete (this as any)[destructorGuardSymbol];
		}
	}

	static instanceOf(obj: any): obj is ShellSession {
		return uniffiTypeShellSessionObjectFactory.isConcreteType(obj);
	}
}

const uniffiTypeShellSessionObjectFactory: UniffiObjectFactory<ShellSessionInterface> =
	(() => {
		return {
			create(pointer: UnsafeMutableRawPointer): ShellSessionInterface {
				const instance = Object.create(ShellSession.prototype);
				instance[pointerLiteralSymbol] = pointer;
				instance[destructorGuardSymbol] = this.bless(pointer);
				instance[uniffiTypeNameSymbol] = 'ShellSession';
				return instance;
			},

			bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
				return uniffiCaller.rustCall(
					/*caller:*/ (status) =>
						nativeModule().ubrn_uniffi_internal_fn_method_shellsession_ffi__bless_pointer(
							p,
							status,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			unbless(ptr: UniffiRustArcPtr) {
				ptr.markDestroyed();
			},

			pointer(obj: ShellSessionInterface): UnsafeMutableRawPointer {
				if ((obj as any)[destructorGuardSymbol] === undefined) {
					throw new UniffiInternalError.UnexpectedNullPointer();
				}
				return (obj as any)[pointerLiteralSymbol];
			},

			clonePointer(obj: ShellSessionInterface): UnsafeMutableRawPointer {
				const pointer = this.pointer(obj);
				return uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_shellsession(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			freePointer(pointer: UnsafeMutableRawPointer): void {
				uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_free_shellsession(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			isConcreteType(obj: any): obj is ShellSessionInterface {
				return (
					obj[destructorGuardSymbol] &&
					obj[uniffiTypeNameSymbol] === 'ShellSession'
				);
			},
		};
	})();
// FfiConverter for ShellSessionInterface
const FfiConverterTypeShellSession = new FfiConverterObject(
	uniffiTypeShellSessionObjectFactory,
);

export interface SshConnectionInterface {
	disconnect(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
	/**
	 * Convenience snapshot for property-like access in TS.
	 */
	getInfo(): SshConnectionInfo;
	startShell(
		opts: StartShellOptions,
		asyncOpts_?: { signal: AbortSignal },
	) /*throws*/ : Promise<ShellSessionInterface>;
}

export class SshConnection
	extends UniffiAbstractObject
	implements SshConnectionInterface
{
	readonly [uniffiTypeNameSymbol] = 'SshConnection';
	readonly [destructorGuardSymbol]: UniffiRustArcPtr;
	readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
	// No primary constructor declared for this class.
	private constructor(pointer: UnsafeMutableRawPointer) {
		super();
		this[pointerLiteralSymbol] = pointer;
		this[destructorGuardSymbol] =
			uniffiTypeSshConnectionObjectFactory.bless(pointer);
	}

	public async disconnect(asyncOpts_?: {
		signal: AbortSignal;
	}): Promise<void> /*throws*/ {
		const __stack = uniffiIsDebug ? new Error().stack : undefined;
		try {
			return await uniffiRustCallAsync(
				/*rustCaller:*/ uniffiCaller,
				/*rustFutureFunc:*/ () => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_sshconnection_disconnect(
						uniffiTypeSshConnectionObjectFactory.clonePointer(this),
					);
				},
				/*pollFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_poll_void,
				/*cancelFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_cancel_void,
				/*completeFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_complete_void,
				/*freeFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_free_void,
				/*liftFunc:*/ (_v) => {},
				/*liftString:*/ FfiConverterString.lift,
				/*asyncOpts:*/ asyncOpts_,
				/*errorHandler:*/ FfiConverterTypeSshError.lift.bind(
					FfiConverterTypeSshError,
				),
			);
		} catch (__error: any) {
			if (uniffiIsDebug && __error instanceof Error) {
				__error.stack = __stack;
			}
			throw __error;
		}
	}

	/**
	 * Convenience snapshot for property-like access in TS.
	 */
	public getInfo(): SshConnectionInfo {
		return FfiConverterTypeSshConnectionInfo.lift(
			uniffiCaller.rustCall(
				/*caller:*/ (callStatus) => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_sshconnection_get_info(
						uniffiTypeSshConnectionObjectFactory.clonePointer(this),
						callStatus,
					);
				},
				/*liftString:*/ FfiConverterString.lift,
			),
		);
	}

	public async startShell(
		opts: StartShellOptions,
		asyncOpts_?: { signal: AbortSignal },
	): Promise<ShellSessionInterface> /*throws*/ {
		const __stack = uniffiIsDebug ? new Error().stack : undefined;
		try {
			return await uniffiRustCallAsync(
				/*rustCaller:*/ uniffiCaller,
				/*rustFutureFunc:*/ () => {
					return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_sshconnection_start_shell(
						uniffiTypeSshConnectionObjectFactory.clonePointer(this),
						FfiConverterTypeStartShellOptions.lower(opts),
					);
				},
				/*pollFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_poll_pointer,
				/*cancelFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_cancel_pointer,
				/*completeFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_complete_pointer,
				/*freeFunc:*/ nativeModule()
					.ubrn_ffi_uniffi_russh_rust_future_free_pointer,
				/*liftFunc:*/ FfiConverterTypeShellSession.lift.bind(
					FfiConverterTypeShellSession,
				),
				/*liftString:*/ FfiConverterString.lift,
				/*asyncOpts:*/ asyncOpts_,
				/*errorHandler:*/ FfiConverterTypeSshError.lift.bind(
					FfiConverterTypeSshError,
				),
			);
		} catch (__error: any) {
			if (uniffiIsDebug && __error instanceof Error) {
				__error.stack = __stack;
			}
			throw __error;
		}
	}

	/**
	 * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
	 */
	uniffiDestroy(): void {
		const ptr = (this as any)[destructorGuardSymbol];
		if (ptr !== undefined) {
			const pointer = uniffiTypeSshConnectionObjectFactory.pointer(this);
			uniffiTypeSshConnectionObjectFactory.freePointer(pointer);
			uniffiTypeSshConnectionObjectFactory.unbless(ptr);
			delete (this as any)[destructorGuardSymbol];
		}
	}

	static instanceOf(obj: any): obj is SshConnection {
		return uniffiTypeSshConnectionObjectFactory.isConcreteType(obj);
	}
}

const uniffiTypeSshConnectionObjectFactory: UniffiObjectFactory<SshConnectionInterface> =
	(() => {
		return {
			create(pointer: UnsafeMutableRawPointer): SshConnectionInterface {
				const instance = Object.create(SshConnection.prototype);
				instance[pointerLiteralSymbol] = pointer;
				instance[destructorGuardSymbol] = this.bless(pointer);
				instance[uniffiTypeNameSymbol] = 'SshConnection';
				return instance;
			},

			bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
				return uniffiCaller.rustCall(
					/*caller:*/ (status) =>
						nativeModule().ubrn_uniffi_internal_fn_method_sshconnection_ffi__bless_pointer(
							p,
							status,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			unbless(ptr: UniffiRustArcPtr) {
				ptr.markDestroyed();
			},

			pointer(obj: SshConnectionInterface): UnsafeMutableRawPointer {
				if ((obj as any)[destructorGuardSymbol] === undefined) {
					throw new UniffiInternalError.UnexpectedNullPointer();
				}
				return (obj as any)[pointerLiteralSymbol];
			},

			clonePointer(obj: SshConnectionInterface): UnsafeMutableRawPointer {
				const pointer = this.pointer(obj);
				return uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_sshconnection(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			freePointer(pointer: UnsafeMutableRawPointer): void {
				uniffiCaller.rustCall(
					/*caller:*/ (callStatus) =>
						nativeModule().ubrn_uniffi_uniffi_russh_fn_free_sshconnection(
							pointer,
							callStatus,
						),
					/*liftString:*/ FfiConverterString.lift,
				);
			},

			isConcreteType(obj: any): obj is SshConnectionInterface {
				return (
					obj[destructorGuardSymbol] &&
					obj[uniffiTypeNameSymbol] === 'SshConnection'
				);
			},
		};
	})();
// FfiConverter for SshConnectionInterface
const FfiConverterTypeSshConnection = new FfiConverterObject(
	uniffiTypeSshConnectionObjectFactory,
);

// FfiConverter for DroppedRange | undefined
const FfiConverterOptionalTypeDroppedRange = new FfiConverterOptional(
	FfiConverterTypeDroppedRange,
);

// FfiConverter for TerminalPixelSize | undefined
const FfiConverterOptionalTypeTerminalPixelSize = new FfiConverterOptional(
	FfiConverterTypeTerminalPixelSize,
);

// FfiConverter for TerminalSize | undefined
const FfiConverterOptionalTypeTerminalSize = new FfiConverterOptional(
	FfiConverterTypeTerminalSize,
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for Array<TerminalChunk>
const FfiConverterArrayTypeTerminalChunk = new FfiConverterArray(
	FfiConverterTypeTerminalChunk,
);

// FfiConverter for Array<TerminalMode>
const FfiConverterArrayTypeTerminalMode = new FfiConverterArray(
	FfiConverterTypeTerminalMode,
);

// FfiConverter for ConnectProgressCallback | undefined
const FfiConverterOptionalTypeConnectProgressCallback =
	new FfiConverterOptional(FfiConverterTypeConnectProgressCallback);

// FfiConverter for ConnectionDisconnectedCallback | undefined
const FfiConverterOptionalTypeConnectionDisconnectedCallback =
	new FfiConverterOptional(FfiConverterTypeConnectionDisconnectedCallback);

// FfiConverter for ShellClosedCallback | undefined
const FfiConverterOptionalTypeShellClosedCallback = new FfiConverterOptional(
	FfiConverterTypeShellClosedCallback,
);

// FfiConverter for Array<TerminalMode> | undefined
const FfiConverterOptionalArrayTypeTerminalMode = new FfiConverterOptional(
	FfiConverterArrayTypeTerminalMode,
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
	// Get the bindings contract version from our ComponentInterface
	const bindingsContractVersion = 29;
	// Get the scaffolding contract version by calling the into the dylib
	const scaffoldingContractVersion =
		nativeModule().ubrn_ffi_uniffi_russh_uniffi_contract_version();
	if (bindingsContractVersion !== scaffoldingContractVersion) {
		throw new UniffiInternalError.ContractVersionMismatch(
			scaffoldingContractVersion,
			bindingsContractVersion,
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_func_connect() !== 33247
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_func_connect',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_func_extract_public_key() !==
		41250
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_func_extract_public_key',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_func_generate_key_pair() !==
		37501
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_func_generate_key_pair',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_func_validate_private_key() !==
		49309
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_func_validate_private_key',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_connectprogresscallback_on_change() !==
		17699
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_connectprogresscallback_on_change',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_connectiondisconnectedcallback_on_change() !==
		43914
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_connectiondisconnectedcallback_on_change',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_serverkeycallback_on_change() !==
		5111
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_serverkeycallback_on_change',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellclosedcallback_on_change() !==
		56252
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_shellclosedcallback_on_change',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shelllistener_on_event() !==
		12161
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_shelllistener_on_event',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_add_listener() !==
		43852
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_shellsession_add_listener',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_buffer_stats() !==
		11878
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_shellsession_buffer_stats',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_close() !==
		22391
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_shellsession_close',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_current_seq() !==
		5967
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_shellsession_current_seq',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_get_info() !==
		45659
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_shellsession_get_info',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_read_buffer() !==
		52380
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_shellsession_read_buffer',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_remove_listener() !==
		24718
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_shellsession_remove_listener',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_resize_pty() !==
		27901
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_shellsession_resize_pty',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_send_data() !==
		12893
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_shellsession_send_data',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_sshconnection_disconnect() !==
		1510
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_sshconnection_disconnect',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_sshconnection_get_info() !==
		31556
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_sshconnection_get_info',
		);
	}
	if (
		nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_sshconnection_start_shell() !==
		21163
	) {
		throw new UniffiInternalError.ApiChecksumMismatch(
			'uniffi_uniffi_russh_checksum_method_sshconnection_start_shell',
		);
	}

	uniffiCallbackInterfaceConnectProgressCallback.register();
	uniffiCallbackInterfaceConnectionDisconnectedCallback.register();
	uniffiCallbackInterfaceServerKeyCallback.register();
	uniffiCallbackInterfaceShellClosedCallback.register();
	uniffiCallbackInterfaceShellListener.register();
}

export default Object.freeze({
	initialize: uniffiEnsureInitialized,
	converters: {
		FfiConverterTypeBufferReadResult,
		FfiConverterTypeBufferStats,
		FfiConverterTypeConnectOptions,
		FfiConverterTypeConnectProgressCallback,
		FfiConverterTypeConnectionDetails,
		FfiConverterTypeConnectionDisconnectedCallback,
		FfiConverterTypeCursor,
		FfiConverterTypeDroppedRange,
		FfiConverterTypeKeyType,
		FfiConverterTypeListenerOptions,
		FfiConverterTypeSecurity,
		FfiConverterTypeServerKeyCallback,
		FfiConverterTypeServerPublicKeyInfo,
		FfiConverterTypeShellClosedCallback,
		FfiConverterTypeShellEvent,
		FfiConverterTypeShellListener,
		FfiConverterTypeShellSession,
		FfiConverterTypeShellSessionInfo,
		FfiConverterTypeSshConnection,
		FfiConverterTypeSshConnectionInfo,
		FfiConverterTypeSshConnectionInfoProgressTimings,
		FfiConverterTypeSshConnectionProgressEvent,
		FfiConverterTypeSshError,
		FfiConverterTypeStartShellOptions,
		FfiConverterTypeStreamKind,
		FfiConverterTypeTerminalChunk,
		FfiConverterTypeTerminalMode,
		FfiConverterTypeTerminalPixelSize,
		FfiConverterTypeTerminalSize,
		FfiConverterTypeTerminalType,
	},
});
