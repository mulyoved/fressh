"use strict";

// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!

/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
import nativeModule from "./uniffi_russh-ffi.js";
import { AbstractFfiConverterByteArray, FfiConverterArray, FfiConverterArrayBuffer, FfiConverterBool, FfiConverterFloat64, FfiConverterInt32, FfiConverterObject, FfiConverterObjectWithCallbacks, FfiConverterOptional, FfiConverterUInt16, FfiConverterUInt32, FfiConverterUInt64, FfiConverterUInt8, UniffiAbstractObject, UniffiEnum, UniffiError, UniffiInternalError, UniffiResult, UniffiRustCaller, destructorGuardSymbol, pointerLiteralSymbol, uniffiCreateFfiConverterString, uniffiCreateRecord, uniffiRustCallAsync, uniffiTraitInterfaceCall, uniffiTraitInterfaceCallAsync, uniffiTypeNameSymbol } from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({
  code: 0
}));
const uniffiIsDebug =
// @ts-ignore -- The process global might not be defined
typeof process !== 'object' ||
// @ts-ignore -- The process global might not be defined
process?.env?.NODE_ENV !== 'production' || false;
// Public interface members begin here.

export async function connect(options, asyncOpts_) /*throws*/{
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller, /*rustFutureFunc:*/() => {
      return nativeModule().ubrn_uniffi_uniffi_russh_fn_func_connect(FfiConverterTypeConnectOptions.lower(options));
    }, /*pollFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_poll_pointer, /*cancelFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_cancel_pointer, /*completeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_complete_pointer, /*freeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_free_pointer, /*liftFunc:*/FfiConverterTypeSshConnection.lift.bind(FfiConverterTypeSshConnection), /*liftString:*/FfiConverterString.lift, /*asyncOpts:*/asyncOpts_, /*errorHandler:*/FfiConverterTypeSshError.lift.bind(FfiConverterTypeSshError));
  } catch (__error) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * Extract the public key from a private key in OpenSSH format.
 * Returns the public key in the standard "ssh-xxx AAAA... comment" format.
 */
export function extractPublicKey(privateKeyContent) /*throws*/{
  return FfiConverterString.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeSshError.lift.bind(FfiConverterTypeSshError), /*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_uniffi_russh_fn_func_extract_public_key(FfiConverterString.lower(privateKeyContent), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
export function generateKeyPair(keyType) /*throws*/{
  return FfiConverterString.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeSshError.lift.bind(FfiConverterTypeSshError), /*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_uniffi_russh_fn_func_generate_key_pair(FfiConverterTypeKeyType.lower(keyType), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
export function validatePrivateKey(privateKeyContent) /*throws*/{
  return FfiConverterString.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeSshError.lift.bind(FfiConverterTypeSshError), /*caller:*/callStatus => {
    return nativeModule().ubrn_uniffi_uniffi_russh_fn_func_validate_private_key(FfiConverterString.lower(privateKeyContent), callStatus);
  }, /*liftString:*/FfiConverterString.lift));
}
/**
 * Generated factory for {@link BufferReadResult} record objects.
 */
export const BufferReadResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BufferReadResult}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link BufferReadResult}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeBufferReadResult = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        chunks: FfiConverterArrayTypeTerminalChunk.read(from),
        nextSeq: FfiConverterUInt64.read(from),
        dropped: FfiConverterOptionalTypeDroppedRange.read(from)
      };
    }
    write(value, into) {
      FfiConverterArrayTypeTerminalChunk.write(value.chunks, into);
      FfiConverterUInt64.write(value.nextSeq, into);
      FfiConverterOptionalTypeDroppedRange.write(value.dropped, into);
    }
    allocationSize(value) {
      return FfiConverterArrayTypeTerminalChunk.allocationSize(value.chunks) + FfiConverterUInt64.allocationSize(value.nextSeq) + FfiConverterOptionalTypeDroppedRange.allocationSize(value.dropped);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link BufferStats} record objects.
 */
export const BufferStats = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BufferStats}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link BufferStats}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeBufferStats = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        ringBytesCount: FfiConverterUInt64.read(from),
        usedBytes: FfiConverterUInt64.read(from),
        headSeq: FfiConverterUInt64.read(from),
        tailSeq: FfiConverterUInt64.read(from),
        droppedBytesTotal: FfiConverterUInt64.read(from),
        chunksCount: FfiConverterUInt64.read(from)
      };
    }
    write(value, into) {
      FfiConverterUInt64.write(value.ringBytesCount, into);
      FfiConverterUInt64.write(value.usedBytes, into);
      FfiConverterUInt64.write(value.headSeq, into);
      FfiConverterUInt64.write(value.tailSeq, into);
      FfiConverterUInt64.write(value.droppedBytesTotal, into);
      FfiConverterUInt64.write(value.chunksCount, into);
    }
    allocationSize(value) {
      return FfiConverterUInt64.allocationSize(value.ringBytesCount) + FfiConverterUInt64.allocationSize(value.usedBytes) + FfiConverterUInt64.allocationSize(value.headSeq) + FfiConverterUInt64.allocationSize(value.tailSeq) + FfiConverterUInt64.allocationSize(value.droppedBytesTotal) + FfiConverterUInt64.allocationSize(value.chunksCount);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link ConnectOptions} record objects.
 */
export const ConnectOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ConnectOptions}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link ConnectOptions}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeConnectOptions = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        connectionDetails: FfiConverterTypeConnectionDetails.read(from),
        onConnectionProgressCallback: FfiConverterOptionalTypeConnectProgressCallback.read(from),
        onDisconnectedCallback: FfiConverterOptionalTypeConnectionDisconnectedCallback.read(from),
        onServerKeyCallback: FfiConverterTypeServerKeyCallback.read(from)
      };
    }
    write(value, into) {
      FfiConverterTypeConnectionDetails.write(value.connectionDetails, into);
      FfiConverterOptionalTypeConnectProgressCallback.write(value.onConnectionProgressCallback, into);
      FfiConverterOptionalTypeConnectionDisconnectedCallback.write(value.onDisconnectedCallback, into);
      FfiConverterTypeServerKeyCallback.write(value.onServerKeyCallback, into);
    }
    allocationSize(value) {
      return FfiConverterTypeConnectionDetails.allocationSize(value.connectionDetails) + FfiConverterOptionalTypeConnectProgressCallback.allocationSize(value.onConnectionProgressCallback) + FfiConverterOptionalTypeConnectionDisconnectedCallback.allocationSize(value.onDisconnectedCallback) + FfiConverterTypeServerKeyCallback.allocationSize(value.onServerKeyCallback);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link ConnectionDetails} record objects.
 */
export const ConnectionDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ConnectionDetails}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link ConnectionDetails}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeConnectionDetails = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        host: FfiConverterString.read(from),
        port: FfiConverterUInt16.read(from),
        username: FfiConverterString.read(from),
        security: FfiConverterTypeSecurity.read(from)
      };
    }
    write(value, into) {
      FfiConverterString.write(value.host, into);
      FfiConverterUInt16.write(value.port, into);
      FfiConverterString.write(value.username, into);
      FfiConverterTypeSecurity.write(value.security, into);
    }
    allocationSize(value) {
      return FfiConverterString.allocationSize(value.host) + FfiConverterUInt16.allocationSize(value.port) + FfiConverterString.allocationSize(value.username) + FfiConverterTypeSecurity.allocationSize(value.security);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link DroppedRange} record objects.
 */
export const DroppedRange = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link DroppedRange}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link DroppedRange}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeDroppedRange = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        fromSeq: FfiConverterUInt64.read(from),
        toSeq: FfiConverterUInt64.read(from)
      };
    }
    write(value, into) {
      FfiConverterUInt64.write(value.fromSeq, into);
      FfiConverterUInt64.write(value.toSeq, into);
    }
    allocationSize(value) {
      return FfiConverterUInt64.allocationSize(value.fromSeq) + FfiConverterUInt64.allocationSize(value.toSeq);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link ListenerOptions} record objects.
 */
export const ListenerOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListenerOptions}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link ListenerOptions}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeListenerOptions = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        cursor: FfiConverterTypeCursor.read(from),
        coalesceMs: FfiConverterOptionalUInt32.read(from)
      };
    }
    write(value, into) {
      FfiConverterTypeCursor.write(value.cursor, into);
      FfiConverterOptionalUInt32.write(value.coalesceMs, into);
    }
    allocationSize(value) {
      return FfiConverterTypeCursor.allocationSize(value.cursor) + FfiConverterOptionalUInt32.allocationSize(value.coalesceMs);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link ServerPublicKeyInfo} record objects.
 */
export const ServerPublicKeyInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ServerPublicKeyInfo}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link ServerPublicKeyInfo}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeServerPublicKeyInfo = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        host: FfiConverterString.read(from),
        port: FfiConverterUInt16.read(from),
        remoteIp: FfiConverterOptionalString.read(from),
        algorithm: FfiConverterString.read(from),
        fingerprintSha256: FfiConverterString.read(from),
        keyBase64: FfiConverterString.read(from)
      };
    }
    write(value, into) {
      FfiConverterString.write(value.host, into);
      FfiConverterUInt16.write(value.port, into);
      FfiConverterOptionalString.write(value.remoteIp, into);
      FfiConverterString.write(value.algorithm, into);
      FfiConverterString.write(value.fingerprintSha256, into);
      FfiConverterString.write(value.keyBase64, into);
    }
    allocationSize(value) {
      return FfiConverterString.allocationSize(value.host) + FfiConverterUInt16.allocationSize(value.port) + FfiConverterOptionalString.allocationSize(value.remoteIp) + FfiConverterString.allocationSize(value.algorithm) + FfiConverterString.allocationSize(value.fingerprintSha256) + FfiConverterString.allocationSize(value.keyBase64);
    }
  }
  return new FFIConverter();
})();

/**
 * Snapshot of shell session info for property-like access in TS.
 */

/**
 * Generated factory for {@link ShellSessionInfo} record objects.
 */
export const ShellSessionInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ShellSessionInfo}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link ShellSessionInfo}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeShellSessionInfo = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        channelId: FfiConverterUInt32.read(from),
        createdAtMs: FfiConverterFloat64.read(from),
        connectedAtMs: FfiConverterFloat64.read(from),
        term: FfiConverterTypeTerminalType.read(from),
        connectionId: FfiConverterString.read(from)
      };
    }
    write(value, into) {
      FfiConverterUInt32.write(value.channelId, into);
      FfiConverterFloat64.write(value.createdAtMs, into);
      FfiConverterFloat64.write(value.connectedAtMs, into);
      FfiConverterTypeTerminalType.write(value.term, into);
      FfiConverterString.write(value.connectionId, into);
    }
    allocationSize(value) {
      return FfiConverterUInt32.allocationSize(value.channelId) + FfiConverterFloat64.allocationSize(value.createdAtMs) + FfiConverterFloat64.allocationSize(value.connectedAtMs) + FfiConverterTypeTerminalType.allocationSize(value.term) + FfiConverterString.allocationSize(value.connectionId);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link SshConnectionInfo} record objects.
 */
export const SshConnectionInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SshConnectionInfo}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link SshConnectionInfo}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeSshConnectionInfo = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        connectionId: FfiConverterString.read(from),
        connectionDetails: FfiConverterTypeConnectionDetails.read(from),
        createdAtMs: FfiConverterFloat64.read(from),
        connectedAtMs: FfiConverterFloat64.read(from),
        progressTimings: FfiConverterTypeSshConnectionInfoProgressTimings.read(from)
      };
    }
    write(value, into) {
      FfiConverterString.write(value.connectionId, into);
      FfiConverterTypeConnectionDetails.write(value.connectionDetails, into);
      FfiConverterFloat64.write(value.createdAtMs, into);
      FfiConverterFloat64.write(value.connectedAtMs, into);
      FfiConverterTypeSshConnectionInfoProgressTimings.write(value.progressTimings, into);
    }
    allocationSize(value) {
      return FfiConverterString.allocationSize(value.connectionId) + FfiConverterTypeConnectionDetails.allocationSize(value.connectionDetails) + FfiConverterFloat64.allocationSize(value.createdAtMs) + FfiConverterFloat64.allocationSize(value.connectedAtMs) + FfiConverterTypeSshConnectionInfoProgressTimings.allocationSize(value.progressTimings);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link SshConnectionInfoProgressTimings} record objects.
 */
export const SshConnectionInfoProgressTimings = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SshConnectionInfoProgressTimings}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link SshConnectionInfoProgressTimings}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeSshConnectionInfoProgressTimings = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        tcpEstablishedAtMs: FfiConverterFloat64.read(from),
        sshHandshakeAtMs: FfiConverterFloat64.read(from)
      };
    }
    write(value, into) {
      FfiConverterFloat64.write(value.tcpEstablishedAtMs, into);
      FfiConverterFloat64.write(value.sshHandshakeAtMs, into);
    }
    allocationSize(value) {
      return FfiConverterFloat64.allocationSize(value.tcpEstablishedAtMs) + FfiConverterFloat64.allocationSize(value.sshHandshakeAtMs);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link StartShellOptions} record objects.
 */
export const StartShellOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link StartShellOptions}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link StartShellOptions}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeStartShellOptions = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        term: FfiConverterTypeTerminalType.read(from),
        terminalMode: FfiConverterOptionalArrayTypeTerminalMode.read(from),
        terminalSize: FfiConverterOptionalTypeTerminalSize.read(from),
        terminalPixelSize: FfiConverterOptionalTypeTerminalPixelSize.read(from),
        useTmux: FfiConverterBool.read(from),
        tmuxSessionName: FfiConverterOptionalString.read(from),
        onClosedCallback: FfiConverterOptionalTypeShellClosedCallback.read(from)
      };
    }
    write(value, into) {
      FfiConverterTypeTerminalType.write(value.term, into);
      FfiConverterOptionalArrayTypeTerminalMode.write(value.terminalMode, into);
      FfiConverterOptionalTypeTerminalSize.write(value.terminalSize, into);
      FfiConverterOptionalTypeTerminalPixelSize.write(value.terminalPixelSize, into);
      FfiConverterBool.write(value.useTmux, into);
      FfiConverterOptionalString.write(value.tmuxSessionName, into);
      FfiConverterOptionalTypeShellClosedCallback.write(value.onClosedCallback, into);
    }
    allocationSize(value) {
      return FfiConverterTypeTerminalType.allocationSize(value.term) + FfiConverterOptionalArrayTypeTerminalMode.allocationSize(value.terminalMode) + FfiConverterOptionalTypeTerminalSize.allocationSize(value.terminalSize) + FfiConverterOptionalTypeTerminalPixelSize.allocationSize(value.terminalPixelSize) + FfiConverterBool.allocationSize(value.useTmux) + FfiConverterOptionalString.allocationSize(value.tmuxSessionName) + FfiConverterOptionalTypeShellClosedCallback.allocationSize(value.onClosedCallback);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link TerminalChunk} record objects.
 */
export const TerminalChunk = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TerminalChunk}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link TerminalChunk}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeTerminalChunk = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        seq: FfiConverterUInt64.read(from),
        tMs: FfiConverterFloat64.read(from),
        stream: FfiConverterTypeStreamKind.read(from),
        bytes: FfiConverterArrayBuffer.read(from)
      };
    }
    write(value, into) {
      FfiConverterUInt64.write(value.seq, into);
      FfiConverterFloat64.write(value.tMs, into);
      FfiConverterTypeStreamKind.write(value.stream, into);
      FfiConverterArrayBuffer.write(value.bytes, into);
    }
    allocationSize(value) {
      return FfiConverterUInt64.allocationSize(value.seq) + FfiConverterFloat64.allocationSize(value.tMs) + FfiConverterTypeStreamKind.allocationSize(value.stream) + FfiConverterArrayBuffer.allocationSize(value.bytes);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link TerminalMode} record objects.
 */
export const TerminalMode = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TerminalMode}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link TerminalMode}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeTerminalMode = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        opcode: FfiConverterUInt8.read(from),
        value: FfiConverterUInt32.read(from)
      };
    }
    write(value, into) {
      FfiConverterUInt8.write(value.opcode, into);
      FfiConverterUInt32.write(value.value, into);
    }
    allocationSize(value) {
      return FfiConverterUInt8.allocationSize(value.opcode) + FfiConverterUInt32.allocationSize(value.value);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link TerminalPixelSize} record objects.
 */
export const TerminalPixelSize = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TerminalPixelSize}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link TerminalPixelSize}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeTerminalPixelSize = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        pixelWidth: FfiConverterOptionalUInt32.read(from),
        pixelHeight: FfiConverterOptionalUInt32.read(from)
      };
    }
    write(value, into) {
      FfiConverterOptionalUInt32.write(value.pixelWidth, into);
      FfiConverterOptionalUInt32.write(value.pixelHeight, into);
    }
    allocationSize(value) {
      return FfiConverterOptionalUInt32.allocationSize(value.pixelWidth) + FfiConverterOptionalUInt32.allocationSize(value.pixelHeight);
    }
  }
  return new FFIConverter();
})();
/**
 * Generated factory for {@link TerminalSize} record objects.
 */
export const TerminalSize = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TerminalSize}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    create,
    /**
     * Create a frozen instance of {@link TerminalSize}, with defaults specified
     * in Rust, in the {@link uniffi_russh} crate.
     */
    new: create,
    /**
     * Defaults specified in the {@link uniffi_russh} crate.
     */
    defaults: () => Object.freeze(defaults())
  });
})();
const FfiConverterTypeTerminalSize = (() => {
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      return {
        rowHeight: FfiConverterOptionalUInt32.read(from),
        colWidth: FfiConverterOptionalUInt32.read(from)
      };
    }
    write(value, into) {
      FfiConverterOptionalUInt32.write(value.rowHeight, into);
      FfiConverterOptionalUInt32.write(value.colWidth, into);
    }
    allocationSize(value) {
      return FfiConverterOptionalUInt32.allocationSize(value.rowHeight) + FfiConverterOptionalUInt32.allocationSize(value.colWidth);
    }
  }
  return new FFIConverter();
})();
const stringConverter = {
  stringToBytes: s => uniffiCaller.rustCall(status => nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(s, status)),
  bytesToString: ab => uniffiCaller.rustCall(status => nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(ab, status)),
  stringByteLength: s => uniffiCaller.rustCall(status => nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(s, status))
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Enum: Cursor
export let Cursor_Tags = /*#__PURE__*/function (Cursor_Tags) {
  Cursor_Tags["Head"] = "Head";
  Cursor_Tags["TailBytes"] = "TailBytes";
  Cursor_Tags["Seq"] = "Seq";
  Cursor_Tags["TimeMs"] = "TimeMs";
  Cursor_Tags["Live"] = "Live";
  return Cursor_Tags;
}({});
export const Cursor = (() => {
  class Head_ extends UniffiEnum {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'Cursor';
    tag = Cursor_Tags.Head;
    constructor() {
      super('Cursor', 'Head');
    }
    static new() {
      return new Head_();
    }
    static instanceOf(obj) {
      return obj.tag === Cursor_Tags.Head;
    }
  }
  class TailBytes_ extends UniffiEnum {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'Cursor';
    tag = Cursor_Tags.TailBytes;
    constructor(inner) {
      super('Cursor', 'TailBytes');
      this.inner = Object.freeze(inner);
    }
    static new(inner) {
      return new TailBytes_(inner);
    }
    static instanceOf(obj) {
      return obj.tag === Cursor_Tags.TailBytes;
    }
  }
  class Seq_ extends UniffiEnum {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'Cursor';
    tag = Cursor_Tags.Seq;
    constructor(inner) {
      super('Cursor', 'Seq');
      this.inner = Object.freeze(inner);
    }
    static new(inner) {
      return new Seq_(inner);
    }
    static instanceOf(obj) {
      return obj.tag === Cursor_Tags.Seq;
    }
  }
  class TimeMs_ extends UniffiEnum {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'Cursor';
    tag = Cursor_Tags.TimeMs;
    constructor(inner) {
      super('Cursor', 'TimeMs');
      this.inner = Object.freeze(inner);
    }
    static new(inner) {
      return new TimeMs_(inner);
    }
    static instanceOf(obj) {
      return obj.tag === Cursor_Tags.TimeMs;
    }
  }
  class Live_ extends UniffiEnum {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'Cursor';
    tag = Cursor_Tags.Live;
    constructor() {
      super('Cursor', 'Live');
    }
    static new() {
      return new Live_();
    }
    static instanceOf(obj) {
      return obj.tag === Cursor_Tags.Live;
    }
  }
  function instanceOf(obj) {
    return obj[uniffiTypeNameSymbol] === 'Cursor';
  }
  return Object.freeze({
    instanceOf,
    Head: Head_,
    TailBytes: TailBytes_,
    Seq: Seq_,
    TimeMs: TimeMs_,
    Live: Live_
  });
})();
// FfiConverter for enum Cursor
const FfiConverterTypeCursor = (() => {
  const ordinalConverter = FfiConverterInt32;
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Cursor.Head();
        case 2:
          return new Cursor.TailBytes({
            bytes: FfiConverterUInt64.read(from)
          });
        case 3:
          return new Cursor.Seq({
            seq: FfiConverterUInt64.read(from)
          });
        case 4:
          return new Cursor.TimeMs({
            tMs: FfiConverterFloat64.read(from)
          });
        case 5:
          return new Cursor.Live();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value, into) {
      switch (value.tag) {
        case Cursor_Tags.Head:
          {
            ordinalConverter.write(1, into);
            return;
          }
        case Cursor_Tags.TailBytes:
          {
            ordinalConverter.write(2, into);
            const inner = value.inner;
            FfiConverterUInt64.write(inner.bytes, into);
            return;
          }
        case Cursor_Tags.Seq:
          {
            ordinalConverter.write(3, into);
            const inner = value.inner;
            FfiConverterUInt64.write(inner.seq, into);
            return;
          }
        case Cursor_Tags.TimeMs:
          {
            ordinalConverter.write(4, into);
            const inner = value.inner;
            FfiConverterFloat64.write(inner.tMs, into);
            return;
          }
        case Cursor_Tags.Live:
          {
            ordinalConverter.write(5, into);
            return;
          }
        default:
          // Throwing from here means that Cursor_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value) {
      switch (value.tag) {
        case Cursor_Tags.Head:
          {
            return ordinalConverter.allocationSize(1);
          }
        case Cursor_Tags.TailBytes:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(2);
            size += FfiConverterUInt64.allocationSize(inner.bytes);
            return size;
          }
        case Cursor_Tags.Seq:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(3);
            size += FfiConverterUInt64.allocationSize(inner.seq);
            return size;
          }
        case Cursor_Tags.TimeMs:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(4);
            size += FfiConverterFloat64.allocationSize(inner.tMs);
            return size;
          }
        case Cursor_Tags.Live:
          {
            return ordinalConverter.allocationSize(5);
          }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();
export let KeyType = /*#__PURE__*/function (KeyType) {
  KeyType[KeyType["Rsa"] = 0] = "Rsa";
  KeyType[KeyType["Ecdsa"] = 1] = "Ecdsa";
  KeyType[KeyType["Ed25519"] = 2] = "Ed25519";
  KeyType[KeyType["Ed448"] = 3] = "Ed448";
  return KeyType;
}({});
const FfiConverterTypeKeyType = (() => {
  const ordinalConverter = FfiConverterInt32;
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      switch (ordinalConverter.read(from)) {
        case 1:
          return KeyType.Rsa;
        case 2:
          return KeyType.Ecdsa;
        case 3:
          return KeyType.Ed25519;
        case 4:
          return KeyType.Ed448;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value, into) {
      switch (value) {
        case KeyType.Rsa:
          return ordinalConverter.write(1, into);
        case KeyType.Ecdsa:
          return ordinalConverter.write(2, into);
        case KeyType.Ed25519:
          return ordinalConverter.write(3, into);
        case KeyType.Ed448:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value) {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: Security
export let Security_Tags = /*#__PURE__*/function (Security_Tags) {
  Security_Tags["Password"] = "Password";
  Security_Tags["Key"] = "Key";
  return Security_Tags;
}({});
export const Security = (() => {
  class Password_ extends UniffiEnum {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'Security';
    tag = Security_Tags.Password;
    constructor(inner) {
      super('Security', 'Password');
      this.inner = Object.freeze(inner);
    }
    static new(inner) {
      return new Password_(inner);
    }
    static instanceOf(obj) {
      return obj.tag === Security_Tags.Password;
    }
  }
  class Key_ extends UniffiEnum {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'Security';
    tag = Security_Tags.Key;
    constructor(inner) {
      super('Security', 'Key');
      this.inner = Object.freeze(inner);
    }
    static new(inner) {
      return new Key_(inner);
    }
    static instanceOf(obj) {
      return obj.tag === Security_Tags.Key;
    }
  }
  function instanceOf(obj) {
    return obj[uniffiTypeNameSymbol] === 'Security';
  }
  return Object.freeze({
    instanceOf,
    Password: Password_,
    Key: Key_
  });
})();
// FfiConverter for enum Security
const FfiConverterTypeSecurity = (() => {
  const ordinalConverter = FfiConverterInt32;
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Security.Password({
            password: FfiConverterString.read(from)
          });
        case 2:
          return new Security.Key({
            privateKeyContent: FfiConverterString.read(from)
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value, into) {
      switch (value.tag) {
        case Security_Tags.Password:
          {
            ordinalConverter.write(1, into);
            const inner = value.inner;
            FfiConverterString.write(inner.password, into);
            return;
          }
        case Security_Tags.Key:
          {
            ordinalConverter.write(2, into);
            const inner = value.inner;
            FfiConverterString.write(inner.privateKeyContent, into);
            return;
          }
        default:
          // Throwing from here means that Security_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value) {
      switch (value.tag) {
        case Security_Tags.Password:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(1);
            size += FfiConverterString.allocationSize(inner.password);
            return size;
          }
        case Security_Tags.Key:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(2);
            size += FfiConverterString.allocationSize(inner.privateKeyContent);
            return size;
          }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: ShellEvent
export let ShellEvent_Tags = /*#__PURE__*/function (ShellEvent_Tags) {
  ShellEvent_Tags["Chunk"] = "Chunk";
  ShellEvent_Tags["Dropped"] = "Dropped";
  return ShellEvent_Tags;
}({});
export const ShellEvent = (() => {
  class Chunk_ extends UniffiEnum {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'ShellEvent';
    tag = ShellEvent_Tags.Chunk;
    constructor(v0) {
      super('ShellEvent', 'Chunk');
      this.inner = Object.freeze([v0]);
    }
    static new(v0) {
      return new Chunk_(v0);
    }
    static instanceOf(obj) {
      return obj.tag === ShellEvent_Tags.Chunk;
    }
  }
  class Dropped_ extends UniffiEnum {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'ShellEvent';
    tag = ShellEvent_Tags.Dropped;
    constructor(inner) {
      super('ShellEvent', 'Dropped');
      this.inner = Object.freeze(inner);
    }
    static new(inner) {
      return new Dropped_(inner);
    }
    static instanceOf(obj) {
      return obj.tag === ShellEvent_Tags.Dropped;
    }
  }
  function instanceOf(obj) {
    return obj[uniffiTypeNameSymbol] === 'ShellEvent';
  }
  return Object.freeze({
    instanceOf,
    Chunk: Chunk_,
    Dropped: Dropped_
  });
})();
// FfiConverter for enum ShellEvent
const FfiConverterTypeShellEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ShellEvent.Chunk(FfiConverterTypeTerminalChunk.read(from));
        case 2:
          return new ShellEvent.Dropped({
            fromSeq: FfiConverterUInt64.read(from),
            toSeq: FfiConverterUInt64.read(from)
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value, into) {
      switch (value.tag) {
        case ShellEvent_Tags.Chunk:
          {
            ordinalConverter.write(1, into);
            const inner = value.inner;
            FfiConverterTypeTerminalChunk.write(inner[0], into);
            return;
          }
        case ShellEvent_Tags.Dropped:
          {
            ordinalConverter.write(2, into);
            const inner = value.inner;
            FfiConverterUInt64.write(inner.fromSeq, into);
            FfiConverterUInt64.write(inner.toSeq, into);
            return;
          }
        default:
          // Throwing from here means that ShellEvent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value) {
      switch (value.tag) {
        case ShellEvent_Tags.Chunk:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(1);
            size += FfiConverterTypeTerminalChunk.allocationSize(inner[0]);
            return size;
          }
        case ShellEvent_Tags.Dropped:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(2);
            size += FfiConverterUInt64.allocationSize(inner.fromSeq);
            size += FfiConverterUInt64.allocationSize(inner.toSeq);
            return size;
          }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();
export let SshConnectionProgressEvent = /*#__PURE__*/function (SshConnectionProgressEvent) {
  SshConnectionProgressEvent[SshConnectionProgressEvent["TcpConnected"] = 0] = "TcpConnected";
  SshConnectionProgressEvent[SshConnectionProgressEvent["SshHandshake"] = 1] = "SshHandshake";
  return SshConnectionProgressEvent;
}({});
const FfiConverterTypeSshConnectionProgressEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      switch (ordinalConverter.read(from)) {
        case 1:
          return SshConnectionProgressEvent.TcpConnected;
        case 2:
          return SshConnectionProgressEvent.SshHandshake;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value, into) {
      switch (value) {
        case SshConnectionProgressEvent.TcpConnected:
          return ordinalConverter.write(1, into);
        case SshConnectionProgressEvent.SshHandshake:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value) {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Error type: SshError

// Enum: SshError
export let SshError_Tags = /*#__PURE__*/function (SshError_Tags) {
  SshError_Tags["Disconnected"] = "Disconnected";
  SshError_Tags["UnsupportedKeyType"] = "UnsupportedKeyType";
  SshError_Tags["Auth"] = "Auth";
  SshError_Tags["ShellAlreadyRunning"] = "ShellAlreadyRunning";
  SshError_Tags["TmuxAttachFailed"] = "TmuxAttachFailed";
  SshError_Tags["Russh"] = "Russh";
  SshError_Tags["RusshKeys"] = "RusshKeys";
  return SshError_Tags;
}({});
export const SshError = (() => {
  class Disconnected_ extends UniffiError {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'SshError';
    tag = SshError_Tags.Disconnected;
    constructor() {
      super('SshError', 'Disconnected');
    }
    static new() {
      return new Disconnected_();
    }
    static instanceOf(obj) {
      return obj.tag === SshError_Tags.Disconnected;
    }
    static hasInner(obj) {
      return false;
    }
  }
  class UnsupportedKeyType_ extends UniffiError {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'SshError';
    tag = SshError_Tags.UnsupportedKeyType;
    constructor() {
      super('SshError', 'UnsupportedKeyType');
    }
    static new() {
      return new UnsupportedKeyType_();
    }
    static instanceOf(obj) {
      return obj.tag === SshError_Tags.UnsupportedKeyType;
    }
    static hasInner(obj) {
      return false;
    }
  }
  class Auth_ extends UniffiError {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'SshError';
    tag = SshError_Tags.Auth;
    constructor(v0) {
      super('SshError', 'Auth');
      this.inner = Object.freeze([v0]);
    }
    static new(v0) {
      return new Auth_(v0);
    }
    static instanceOf(obj) {
      return obj.tag === SshError_Tags.Auth;
    }
    static hasInner(obj) {
      return Auth_.instanceOf(obj);
    }
    static getInner(obj) {
      return obj.inner;
    }
  }
  class ShellAlreadyRunning_ extends UniffiError {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'SshError';
    tag = SshError_Tags.ShellAlreadyRunning;
    constructor() {
      super('SshError', 'ShellAlreadyRunning');
    }
    static new() {
      return new ShellAlreadyRunning_();
    }
    static instanceOf(obj) {
      return obj.tag === SshError_Tags.ShellAlreadyRunning;
    }
    static hasInner(obj) {
      return false;
    }
  }
  class TmuxAttachFailed_ extends UniffiError {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'SshError';
    tag = SshError_Tags.TmuxAttachFailed;
    constructor(v0) {
      super('SshError', 'TmuxAttachFailed');
      this.inner = Object.freeze([v0]);
    }
    static new(v0) {
      return new TmuxAttachFailed_(v0);
    }
    static instanceOf(obj) {
      return obj.tag === SshError_Tags.TmuxAttachFailed;
    }
    static hasInner(obj) {
      return TmuxAttachFailed_.instanceOf(obj);
    }
    static getInner(obj) {
      return obj.inner;
    }
  }
  class Russh_ extends UniffiError {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'SshError';
    tag = SshError_Tags.Russh;
    constructor(v0) {
      super('SshError', 'Russh');
      this.inner = Object.freeze([v0]);
    }
    static new(v0) {
      return new Russh_(v0);
    }
    static instanceOf(obj) {
      return obj.tag === SshError_Tags.Russh;
    }
    static hasInner(obj) {
      return Russh_.instanceOf(obj);
    }
    static getInner(obj) {
      return obj.inner;
    }
  }
  class RusshKeys_ extends UniffiError {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    [uniffiTypeNameSymbol] = 'SshError';
    tag = SshError_Tags.RusshKeys;
    constructor(v0) {
      super('SshError', 'RusshKeys');
      this.inner = Object.freeze([v0]);
    }
    static new(v0) {
      return new RusshKeys_(v0);
    }
    static instanceOf(obj) {
      return obj.tag === SshError_Tags.RusshKeys;
    }
    static hasInner(obj) {
      return RusshKeys_.instanceOf(obj);
    }
    static getInner(obj) {
      return obj.inner;
    }
  }
  function instanceOf(obj) {
    return obj[uniffiTypeNameSymbol] === 'SshError';
  }
  return Object.freeze({
    instanceOf,
    Disconnected: Disconnected_,
    UnsupportedKeyType: UnsupportedKeyType_,
    Auth: Auth_,
    ShellAlreadyRunning: ShellAlreadyRunning_,
    TmuxAttachFailed: TmuxAttachFailed_,
    Russh: Russh_,
    RusshKeys: RusshKeys_
  });
})();
// FfiConverter for enum SshError
const FfiConverterTypeSshError = (() => {
  const ordinalConverter = FfiConverterInt32;
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SshError.Disconnected();
        case 2:
          return new SshError.UnsupportedKeyType();
        case 3:
          return new SshError.Auth(FfiConverterString.read(from));
        case 4:
          return new SshError.ShellAlreadyRunning();
        case 5:
          return new SshError.TmuxAttachFailed(FfiConverterString.read(from));
        case 6:
          return new SshError.Russh(FfiConverterString.read(from));
        case 7:
          return new SshError.RusshKeys(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value, into) {
      switch (value.tag) {
        case SshError_Tags.Disconnected:
          {
            ordinalConverter.write(1, into);
            return;
          }
        case SshError_Tags.UnsupportedKeyType:
          {
            ordinalConverter.write(2, into);
            return;
          }
        case SshError_Tags.Auth:
          {
            ordinalConverter.write(3, into);
            const inner = value.inner;
            FfiConverterString.write(inner[0], into);
            return;
          }
        case SshError_Tags.ShellAlreadyRunning:
          {
            ordinalConverter.write(4, into);
            return;
          }
        case SshError_Tags.TmuxAttachFailed:
          {
            ordinalConverter.write(5, into);
            const inner = value.inner;
            FfiConverterString.write(inner[0], into);
            return;
          }
        case SshError_Tags.Russh:
          {
            ordinalConverter.write(6, into);
            const inner = value.inner;
            FfiConverterString.write(inner[0], into);
            return;
          }
        case SshError_Tags.RusshKeys:
          {
            ordinalConverter.write(7, into);
            const inner = value.inner;
            FfiConverterString.write(inner[0], into);
            return;
          }
        default:
          // Throwing from here means that SshError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value) {
      switch (value.tag) {
        case SshError_Tags.Disconnected:
          {
            return ordinalConverter.allocationSize(1);
          }
        case SshError_Tags.UnsupportedKeyType:
          {
            return ordinalConverter.allocationSize(2);
          }
        case SshError_Tags.Auth:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(3);
            size += FfiConverterString.allocationSize(inner[0]);
            return size;
          }
        case SshError_Tags.ShellAlreadyRunning:
          {
            return ordinalConverter.allocationSize(4);
          }
        case SshError_Tags.TmuxAttachFailed:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(5);
            size += FfiConverterString.allocationSize(inner[0]);
            return size;
          }
        case SshError_Tags.Russh:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(6);
            size += FfiConverterString.allocationSize(inner[0]);
            return size;
          }
        case SshError_Tags.RusshKeys:
          {
            const inner = value.inner;
            let size = ordinalConverter.allocationSize(7);
            size += FfiConverterString.allocationSize(inner[0]);
            return size;
          }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();
export let StreamKind = /*#__PURE__*/function (StreamKind) {
  StreamKind[StreamKind["Stdout"] = 0] = "Stdout";
  StreamKind[StreamKind["Stderr"] = 1] = "Stderr";
  return StreamKind;
}({});
const FfiConverterTypeStreamKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      switch (ordinalConverter.read(from)) {
        case 1:
          return StreamKind.Stdout;
        case 2:
          return StreamKind.Stderr;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value, into) {
      switch (value) {
        case StreamKind.Stdout:
          return ordinalConverter.write(1, into);
        case StreamKind.Stderr:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value) {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();
export let TerminalType = /*#__PURE__*/function (TerminalType) {
  TerminalType[TerminalType["Vanilla"] = 0] = "Vanilla";
  TerminalType[TerminalType["Vt100"] = 1] = "Vt100";
  TerminalType[TerminalType["Vt102"] = 2] = "Vt102";
  TerminalType[TerminalType["Vt220"] = 3] = "Vt220";
  TerminalType[TerminalType["Ansi"] = 4] = "Ansi";
  TerminalType[TerminalType["Xterm"] = 5] = "Xterm";
  TerminalType[TerminalType["Xterm256"] = 6] = "Xterm256";
  return TerminalType;
}({});
const FfiConverterTypeTerminalType = (() => {
  const ordinalConverter = FfiConverterInt32;
  class FFIConverter extends AbstractFfiConverterByteArray {
    read(from) {
      switch (ordinalConverter.read(from)) {
        case 1:
          return TerminalType.Vanilla;
        case 2:
          return TerminalType.Vt100;
        case 3:
          return TerminalType.Vt102;
        case 4:
          return TerminalType.Vt220;
        case 5:
          return TerminalType.Ansi;
        case 6:
          return TerminalType.Xterm;
        case 7:
          return TerminalType.Xterm256;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value, into) {
      switch (value) {
        case TerminalType.Vanilla:
          return ordinalConverter.write(1, into);
        case TerminalType.Vt100:
          return ordinalConverter.write(2, into);
        case TerminalType.Vt102:
          return ordinalConverter.write(3, into);
        case TerminalType.Vt220:
          return ordinalConverter.write(4, into);
        case TerminalType.Ansi:
          return ordinalConverter.write(5, into);
        case TerminalType.Xterm:
          return ordinalConverter.write(6, into);
        case TerminalType.Xterm256:
          return ordinalConverter.write(7, into);
      }
    }
    allocationSize(value) {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();
export class ConnectProgressCallbackImpl extends UniffiAbstractObject {
  [uniffiTypeNameSymbol] = 'ConnectProgressCallbackImpl';
  // No primary constructor declared for this class.
  constructor(pointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeConnectProgressCallbackImplObjectFactory.bless(pointer);
  }
  onChange(status) {
    uniffiCaller.rustCall(/*caller:*/callStatus => {
      nativeModule().ubrn_uniffi_uniffi_russh_fn_method_connectprogresscallback_on_change(uniffiTypeConnectProgressCallbackImplObjectFactory.clonePointer(this), FfiConverterTypeSshConnectionProgressEvent.lower(status), callStatus);
    }, /*liftString:*/FfiConverterString.lift);
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy() {
    const ptr = this[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeConnectProgressCallbackImplObjectFactory.pointer(this);
      uniffiTypeConnectProgressCallbackImplObjectFactory.freePointer(pointer);
      uniffiTypeConnectProgressCallbackImplObjectFactory.unbless(ptr);
      delete this[destructorGuardSymbol];
    }
  }
  static instanceOf(obj) {
    return uniffiTypeConnectProgressCallbackImplObjectFactory.isConcreteType(obj);
  }
}
const uniffiTypeConnectProgressCallbackImplObjectFactory = (() => {
  return {
    create(pointer) {
      const instance = Object.create(ConnectProgressCallbackImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ConnectProgressCallbackImpl';
      return instance;
    },
    bless(p) {
      return uniffiCaller.rustCall(/*caller:*/status => nativeModule().ubrn_uniffi_internal_fn_method_connectprogresscallback_ffi__bless_pointer(p, status), /*liftString:*/FfiConverterString.lift);
    },
    unbless(ptr) {
      ptr.markDestroyed();
    },
    pointer(obj) {
      if (obj[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return obj[pointerLiteralSymbol];
    },
    clonePointer(obj) {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_connectprogresscallback(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    freePointer(pointer) {
      uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_free_connectprogresscallback(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    isConcreteType(obj) {
      return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'ConnectProgressCallbackImpl';
    }
  };
})();
// FfiConverter for ConnectProgressCallback
const FfiConverterTypeConnectProgressCallback = new FfiConverterObjectWithCallbacks(uniffiTypeConnectProgressCallbackImplObjectFactory);

// Add a vtavble for the callbacks that go in ConnectProgressCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceConnectProgressCallback = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onChange: (uniffiHandle, status) => {
      const uniffiMakeCall = () => {
        const jsCallback = FfiConverterTypeConnectProgressCallback.lift(uniffiHandle);
        return jsCallback.onChange(FfiConverterTypeSshConnectionProgressEvent.lift(status));
      };
      const uniffiResult = UniffiResult.ready();
      const uniffiHandleSuccess = obj => {};
      const uniffiHandleError = (code, errBuf) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(/*makeCall:*/uniffiMakeCall, /*handleSuccess:*/uniffiHandleSuccess, /*handleError:*/uniffiHandleError, /*lowerString:*/FfiConverterString.lower);
      return uniffiResult;
    },
    uniffiFree: uniffiHandle => {
      // ConnectProgressCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeConnectProgressCallback.drop(uniffiHandle);
    }
  },
  register: () => {
    nativeModule().ubrn_uniffi_uniffi_russh_fn_init_callback_vtable_connectprogresscallback(uniffiCallbackInterfaceConnectProgressCallback.vtable);
  }
};
export class ConnectionDisconnectedCallbackImpl extends UniffiAbstractObject {
  [uniffiTypeNameSymbol] = 'ConnectionDisconnectedCallbackImpl';
  // No primary constructor declared for this class.
  constructor(pointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.bless(pointer);
  }
  onChange(connectionId) {
    uniffiCaller.rustCall(/*caller:*/callStatus => {
      nativeModule().ubrn_uniffi_uniffi_russh_fn_method_connectiondisconnectedcallback_on_change(uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.clonePointer(this), FfiConverterString.lower(connectionId), callStatus);
    }, /*liftString:*/FfiConverterString.lift);
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy() {
    const ptr = this[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.pointer(this);
      uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.freePointer(pointer);
      uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.unbless(ptr);
      delete this[destructorGuardSymbol];
    }
  }
  static instanceOf(obj) {
    return uniffiTypeConnectionDisconnectedCallbackImplObjectFactory.isConcreteType(obj);
  }
}
const uniffiTypeConnectionDisconnectedCallbackImplObjectFactory = (() => {
  return {
    create(pointer) {
      const instance = Object.create(ConnectionDisconnectedCallbackImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ConnectionDisconnectedCallbackImpl';
      return instance;
    },
    bless(p) {
      return uniffiCaller.rustCall(/*caller:*/status => nativeModule().ubrn_uniffi_internal_fn_method_connectiondisconnectedcallback_ffi__bless_pointer(p, status), /*liftString:*/FfiConverterString.lift);
    },
    unbless(ptr) {
      ptr.markDestroyed();
    },
    pointer(obj) {
      if (obj[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return obj[pointerLiteralSymbol];
    },
    clonePointer(obj) {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_connectiondisconnectedcallback(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    freePointer(pointer) {
      uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_free_connectiondisconnectedcallback(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    isConcreteType(obj) {
      return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'ConnectionDisconnectedCallbackImpl';
    }
  };
})();
// FfiConverter for ConnectionDisconnectedCallback
const FfiConverterTypeConnectionDisconnectedCallback = new FfiConverterObjectWithCallbacks(uniffiTypeConnectionDisconnectedCallbackImplObjectFactory);

// Add a vtavble for the callbacks that go in ConnectionDisconnectedCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceConnectionDisconnectedCallback = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onChange: (uniffiHandle, connectionId) => {
      const uniffiMakeCall = () => {
        const jsCallback = FfiConverterTypeConnectionDisconnectedCallback.lift(uniffiHandle);
        return jsCallback.onChange(FfiConverterString.lift(connectionId));
      };
      const uniffiResult = UniffiResult.ready();
      const uniffiHandleSuccess = obj => {};
      const uniffiHandleError = (code, errBuf) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(/*makeCall:*/uniffiMakeCall, /*handleSuccess:*/uniffiHandleSuccess, /*handleError:*/uniffiHandleError, /*lowerString:*/FfiConverterString.lower);
      return uniffiResult;
    },
    uniffiFree: uniffiHandle => {
      // ConnectionDisconnectedCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeConnectionDisconnectedCallback.drop(uniffiHandle);
    }
  },
  register: () => {
    nativeModule().ubrn_uniffi_uniffi_russh_fn_init_callback_vtable_connectiondisconnectedcallback(uniffiCallbackInterfaceConnectionDisconnectedCallback.vtable);
  }
};
export class ServerKeyCallbackImpl extends UniffiAbstractObject {
  [uniffiTypeNameSymbol] = 'ServerKeyCallbackImpl';
  // No primary constructor declared for this class.
  constructor(pointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeServerKeyCallbackImplObjectFactory.bless(pointer);
  }
  async onChange(serverKeyInfo, asyncOpts_) {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller, /*rustFutureFunc:*/() => {
        return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_serverkeycallback_on_change(uniffiTypeServerKeyCallbackImplObjectFactory.clonePointer(this), FfiConverterTypeServerPublicKeyInfo.lower(serverKeyInfo));
      }, /*pollFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_poll_i8, /*cancelFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_cancel_i8, /*completeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_complete_i8, /*freeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_free_i8, /*liftFunc:*/FfiConverterBool.lift.bind(FfiConverterBool), /*liftString:*/FfiConverterString.lift, /*asyncOpts:*/asyncOpts_);
    } catch (__error) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy() {
    const ptr = this[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeServerKeyCallbackImplObjectFactory.pointer(this);
      uniffiTypeServerKeyCallbackImplObjectFactory.freePointer(pointer);
      uniffiTypeServerKeyCallbackImplObjectFactory.unbless(ptr);
      delete this[destructorGuardSymbol];
    }
  }
  static instanceOf(obj) {
    return uniffiTypeServerKeyCallbackImplObjectFactory.isConcreteType(obj);
  }
}
const uniffiTypeServerKeyCallbackImplObjectFactory = (() => {
  return {
    create(pointer) {
      const instance = Object.create(ServerKeyCallbackImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ServerKeyCallbackImpl';
      return instance;
    },
    bless(p) {
      return uniffiCaller.rustCall(/*caller:*/status => nativeModule().ubrn_uniffi_internal_fn_method_serverkeycallback_ffi__bless_pointer(p, status), /*liftString:*/FfiConverterString.lift);
    },
    unbless(ptr) {
      ptr.markDestroyed();
    },
    pointer(obj) {
      if (obj[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return obj[pointerLiteralSymbol];
    },
    clonePointer(obj) {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_serverkeycallback(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    freePointer(pointer) {
      uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_free_serverkeycallback(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    isConcreteType(obj) {
      return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'ServerKeyCallbackImpl';
    }
  };
})();
// FfiConverter for ServerKeyCallback
const FfiConverterTypeServerKeyCallback = new FfiConverterObjectWithCallbacks(uniffiTypeServerKeyCallbackImplObjectFactory);

// Add a vtavble for the callbacks that go in ServerKeyCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceServerKeyCallback = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onChange: (uniffiHandle, serverKeyInfo, uniffiFutureCallback, uniffiCallbackData) => {
      const uniffiMakeCall = async signal => {
        const jsCallback = FfiConverterTypeServerKeyCallback.lift(uniffiHandle);
        return await jsCallback.onChange(FfiConverterTypeServerPublicKeyInfo.lift(serverKeyInfo), {
          signal
        });
      };
      const uniffiHandleSuccess = returnValue => {
        uniffiFutureCallback.call(uniffiFutureCallback, uniffiCallbackData, /* UniffiForeignFutureStructI8 */{
          returnValue: FfiConverterBool.lower(returnValue),
          callStatus: uniffiCaller.createCallStatus()
        });
      };
      const uniffiHandleError = (code, errorBuf) => {
        uniffiFutureCallback.call(uniffiFutureCallback, uniffiCallbackData, /* UniffiForeignFutureStructI8 */{
          returnValue: 0,
          // TODO create callstatus with error.
          callStatus: uniffiCaller.createErrorStatus(code, errorBuf)
        });
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsync(/*makeCall:*/uniffiMakeCall, /*handleSuccess:*/uniffiHandleSuccess, /*handleError:*/uniffiHandleError, /*lowerString:*/FfiConverterString.lower);
      return uniffiForeignFuture;
    },
    uniffiFree: uniffiHandle => {
      // ServerKeyCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeServerKeyCallback.drop(uniffiHandle);
    }
  },
  register: () => {
    nativeModule().ubrn_uniffi_uniffi_russh_fn_init_callback_vtable_serverkeycallback(uniffiCallbackInterfaceServerKeyCallback.vtable);
  }
};
export class ShellClosedCallbackImpl extends UniffiAbstractObject {
  [uniffiTypeNameSymbol] = 'ShellClosedCallbackImpl';
  // No primary constructor declared for this class.
  constructor(pointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeShellClosedCallbackImplObjectFactory.bless(pointer);
  }
  onChange(channelId) {
    uniffiCaller.rustCall(/*caller:*/callStatus => {
      nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellclosedcallback_on_change(uniffiTypeShellClosedCallbackImplObjectFactory.clonePointer(this), FfiConverterUInt32.lower(channelId), callStatus);
    }, /*liftString:*/FfiConverterString.lift);
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy() {
    const ptr = this[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeShellClosedCallbackImplObjectFactory.pointer(this);
      uniffiTypeShellClosedCallbackImplObjectFactory.freePointer(pointer);
      uniffiTypeShellClosedCallbackImplObjectFactory.unbless(ptr);
      delete this[destructorGuardSymbol];
    }
  }
  static instanceOf(obj) {
    return uniffiTypeShellClosedCallbackImplObjectFactory.isConcreteType(obj);
  }
}
const uniffiTypeShellClosedCallbackImplObjectFactory = (() => {
  return {
    create(pointer) {
      const instance = Object.create(ShellClosedCallbackImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ShellClosedCallbackImpl';
      return instance;
    },
    bless(p) {
      return uniffiCaller.rustCall(/*caller:*/status => nativeModule().ubrn_uniffi_internal_fn_method_shellclosedcallback_ffi__bless_pointer(p, status), /*liftString:*/FfiConverterString.lift);
    },
    unbless(ptr) {
      ptr.markDestroyed();
    },
    pointer(obj) {
      if (obj[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return obj[pointerLiteralSymbol];
    },
    clonePointer(obj) {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_shellclosedcallback(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    freePointer(pointer) {
      uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_free_shellclosedcallback(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    isConcreteType(obj) {
      return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'ShellClosedCallbackImpl';
    }
  };
})();
// FfiConverter for ShellClosedCallback
const FfiConverterTypeShellClosedCallback = new FfiConverterObjectWithCallbacks(uniffiTypeShellClosedCallbackImplObjectFactory);

// Add a vtavble for the callbacks that go in ShellClosedCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceShellClosedCallback = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onChange: (uniffiHandle, channelId) => {
      const uniffiMakeCall = () => {
        const jsCallback = FfiConverterTypeShellClosedCallback.lift(uniffiHandle);
        return jsCallback.onChange(FfiConverterUInt32.lift(channelId));
      };
      const uniffiResult = UniffiResult.ready();
      const uniffiHandleSuccess = obj => {};
      const uniffiHandleError = (code, errBuf) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(/*makeCall:*/uniffiMakeCall, /*handleSuccess:*/uniffiHandleSuccess, /*handleError:*/uniffiHandleError, /*lowerString:*/FfiConverterString.lower);
      return uniffiResult;
    },
    uniffiFree: uniffiHandle => {
      // ShellClosedCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeShellClosedCallback.drop(uniffiHandle);
    }
  },
  register: () => {
    nativeModule().ubrn_uniffi_uniffi_russh_fn_init_callback_vtable_shellclosedcallback(uniffiCallbackInterfaceShellClosedCallback.vtable);
  }
};
export class ShellListenerImpl extends UniffiAbstractObject {
  [uniffiTypeNameSymbol] = 'ShellListenerImpl';
  // No primary constructor declared for this class.
  constructor(pointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeShellListenerImplObjectFactory.bless(pointer);
  }
  onEvent(ev) {
    uniffiCaller.rustCall(/*caller:*/callStatus => {
      nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shelllistener_on_event(uniffiTypeShellListenerImplObjectFactory.clonePointer(this), FfiConverterTypeShellEvent.lower(ev), callStatus);
    }, /*liftString:*/FfiConverterString.lift);
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy() {
    const ptr = this[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeShellListenerImplObjectFactory.pointer(this);
      uniffiTypeShellListenerImplObjectFactory.freePointer(pointer);
      uniffiTypeShellListenerImplObjectFactory.unbless(ptr);
      delete this[destructorGuardSymbol];
    }
  }
  static instanceOf(obj) {
    return uniffiTypeShellListenerImplObjectFactory.isConcreteType(obj);
  }
}
const uniffiTypeShellListenerImplObjectFactory = (() => {
  return {
    create(pointer) {
      const instance = Object.create(ShellListenerImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ShellListenerImpl';
      return instance;
    },
    bless(p) {
      return uniffiCaller.rustCall(/*caller:*/status => nativeModule().ubrn_uniffi_internal_fn_method_shelllistener_ffi__bless_pointer(p, status), /*liftString:*/FfiConverterString.lift);
    },
    unbless(ptr) {
      ptr.markDestroyed();
    },
    pointer(obj) {
      if (obj[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return obj[pointerLiteralSymbol];
    },
    clonePointer(obj) {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_shelllistener(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    freePointer(pointer) {
      uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_free_shelllistener(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    isConcreteType(obj) {
      return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'ShellListenerImpl';
    }
  };
})();
// FfiConverter for ShellListener
const FfiConverterTypeShellListener = new FfiConverterObjectWithCallbacks(uniffiTypeShellListenerImplObjectFactory);

// Add a vtavble for the callbacks that go in ShellListener.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceShellListener = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onEvent: (uniffiHandle, ev) => {
      const uniffiMakeCall = () => {
        const jsCallback = FfiConverterTypeShellListener.lift(uniffiHandle);
        return jsCallback.onEvent(FfiConverterTypeShellEvent.lift(ev));
      };
      const uniffiResult = UniffiResult.ready();
      const uniffiHandleSuccess = obj => {};
      const uniffiHandleError = (code, errBuf) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(/*makeCall:*/uniffiMakeCall, /*handleSuccess:*/uniffiHandleSuccess, /*handleError:*/uniffiHandleError, /*lowerString:*/FfiConverterString.lower);
      return uniffiResult;
    },
    uniffiFree: uniffiHandle => {
      // ShellListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeShellListener.drop(uniffiHandle);
    }
  },
  register: () => {
    nativeModule().ubrn_uniffi_uniffi_russh_fn_init_callback_vtable_shelllistener(uniffiCallbackInterfaceShellListener.vtable);
  }
};
export class ShellSession extends UniffiAbstractObject {
  [uniffiTypeNameSymbol] = 'ShellSession';
  // No primary constructor declared for this class.
  constructor(pointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeShellSessionObjectFactory.bless(pointer);
  }

  /**
   * Add a listener with optional replay and live follow.
   */
  addListener(listener, opts) /*throws*/{
    return FfiConverterUInt64.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeSshError.lift.bind(FfiConverterTypeSshError), /*caller:*/callStatus => {
      return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_add_listener(uniffiTypeShellSessionObjectFactory.clonePointer(this), FfiConverterTypeShellListener.lower(listener), FfiConverterTypeListenerOptions.lower(opts), callStatus);
    }, /*liftString:*/FfiConverterString.lift));
  }

  /**
   * Buffer statistics snapshot.
   */
  bufferStats() {
    return FfiConverterTypeBufferStats.lift(uniffiCaller.rustCall(/*caller:*/callStatus => {
      return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_buffer_stats(uniffiTypeShellSessionObjectFactory.clonePointer(this), callStatus);
    }, /*liftString:*/FfiConverterString.lift));
  }

  /**
   * Close the associated shell channel and stop its reader task.
   */
  async close(asyncOpts_) /*throws*/{
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller, /*rustFutureFunc:*/() => {
        return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_close(uniffiTypeShellSessionObjectFactory.clonePointer(this));
      }, /*pollFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_poll_void, /*cancelFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_cancel_void, /*completeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_complete_void, /*freeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_free_void, /*liftFunc:*/_v => {}, /*liftString:*/FfiConverterString.lift, /*asyncOpts:*/asyncOpts_, /*errorHandler:*/FfiConverterTypeSshError.lift.bind(FfiConverterTypeSshError));
    } catch (__error) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Current next sequence number.
   */
  currentSeq() {
    return FfiConverterUInt64.lift(uniffiCaller.rustCall(/*caller:*/callStatus => {
      return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_current_seq(uniffiTypeShellSessionObjectFactory.clonePointer(this), callStatus);
    }, /*liftString:*/FfiConverterString.lift));
  }
  getInfo() {
    return FfiConverterTypeShellSessionInfo.lift(uniffiCaller.rustCall(/*caller:*/callStatus => {
      return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_get_info(uniffiTypeShellSessionObjectFactory.clonePointer(this), callStatus);
    }, /*liftString:*/FfiConverterString.lift));
  }

  /**
   * Read the ring buffer from a cursor.
   */
  readBuffer(cursor, maxBytes) {
    return FfiConverterTypeBufferReadResult.lift(uniffiCaller.rustCall(/*caller:*/callStatus => {
      return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_read_buffer(uniffiTypeShellSessionObjectFactory.clonePointer(this), FfiConverterTypeCursor.lower(cursor), FfiConverterOptionalUInt64.lower(maxBytes), callStatus);
    }, /*liftString:*/FfiConverterString.lift));
  }
  removeListener(id) {
    uniffiCaller.rustCall(/*caller:*/callStatus => {
      nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_remove_listener(uniffiTypeShellSessionObjectFactory.clonePointer(this), FfiConverterUInt64.lower(id), callStatus);
    }, /*liftString:*/FfiConverterString.lift);
  }

  /**
   * Resize the PTY window. Call when the terminal UI size changes.
   * This sends an SSH "window-change" request to the server, which will
   * deliver SIGWINCH to the remote process (e.g., tmux, vim).
   */
  async resizePty(cols, rows, pixelWidth, pixelHeight, asyncOpts_) /*throws*/{
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller, /*rustFutureFunc:*/() => {
        return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_resize_pty(uniffiTypeShellSessionObjectFactory.clonePointer(this), FfiConverterUInt32.lower(cols), FfiConverterUInt32.lower(rows), FfiConverterOptionalUInt32.lower(pixelWidth), FfiConverterOptionalUInt32.lower(pixelHeight));
      }, /*pollFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_poll_void, /*cancelFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_cancel_void, /*completeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_complete_void, /*freeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_free_void, /*liftFunc:*/_v => {}, /*liftString:*/FfiConverterString.lift, /*asyncOpts:*/asyncOpts_, /*errorHandler:*/FfiConverterTypeSshError.lift.bind(FfiConverterTypeSshError));
    } catch (__error) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send bytes to the active shell (stdin).
   */
  async sendData(data, asyncOpts_) /*throws*/{
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller, /*rustFutureFunc:*/() => {
        return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_shellsession_send_data(uniffiTypeShellSessionObjectFactory.clonePointer(this), FfiConverterArrayBuffer.lower(data));
      }, /*pollFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_poll_void, /*cancelFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_cancel_void, /*completeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_complete_void, /*freeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_free_void, /*liftFunc:*/_v => {}, /*liftString:*/FfiConverterString.lift, /*asyncOpts:*/asyncOpts_, /*errorHandler:*/FfiConverterTypeSshError.lift.bind(FfiConverterTypeSshError));
    } catch (__error) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy() {
    const ptr = this[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeShellSessionObjectFactory.pointer(this);
      uniffiTypeShellSessionObjectFactory.freePointer(pointer);
      uniffiTypeShellSessionObjectFactory.unbless(ptr);
      delete this[destructorGuardSymbol];
    }
  }
  static instanceOf(obj) {
    return uniffiTypeShellSessionObjectFactory.isConcreteType(obj);
  }
}
const uniffiTypeShellSessionObjectFactory = (() => {
  return {
    create(pointer) {
      const instance = Object.create(ShellSession.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ShellSession';
      return instance;
    },
    bless(p) {
      return uniffiCaller.rustCall(/*caller:*/status => nativeModule().ubrn_uniffi_internal_fn_method_shellsession_ffi__bless_pointer(p, status), /*liftString:*/FfiConverterString.lift);
    },
    unbless(ptr) {
      ptr.markDestroyed();
    },
    pointer(obj) {
      if (obj[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return obj[pointerLiteralSymbol];
    },
    clonePointer(obj) {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_shellsession(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    freePointer(pointer) {
      uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_free_shellsession(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    isConcreteType(obj) {
      return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'ShellSession';
    }
  };
})();
// FfiConverter for ShellSessionInterface
const FfiConverterTypeShellSession = new FfiConverterObject(uniffiTypeShellSessionObjectFactory);
export class SshConnection extends UniffiAbstractObject {
  [uniffiTypeNameSymbol] = 'SshConnection';
  // No primary constructor declared for this class.
  constructor(pointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeSshConnectionObjectFactory.bless(pointer);
  }
  async disconnect(asyncOpts_) /*throws*/{
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller, /*rustFutureFunc:*/() => {
        return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_sshconnection_disconnect(uniffiTypeSshConnectionObjectFactory.clonePointer(this));
      }, /*pollFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_poll_void, /*cancelFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_cancel_void, /*completeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_complete_void, /*freeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_free_void, /*liftFunc:*/_v => {}, /*liftString:*/FfiConverterString.lift, /*asyncOpts:*/asyncOpts_, /*errorHandler:*/FfiConverterTypeSshError.lift.bind(FfiConverterTypeSshError));
    } catch (__error) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Convenience snapshot for property-like access in TS.
   */
  getInfo() {
    return FfiConverterTypeSshConnectionInfo.lift(uniffiCaller.rustCall(/*caller:*/callStatus => {
      return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_sshconnection_get_info(uniffiTypeSshConnectionObjectFactory.clonePointer(this), callStatus);
    }, /*liftString:*/FfiConverterString.lift));
  }
  async startShell(opts, asyncOpts_) /*throws*/{
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller, /*rustFutureFunc:*/() => {
        return nativeModule().ubrn_uniffi_uniffi_russh_fn_method_sshconnection_start_shell(uniffiTypeSshConnectionObjectFactory.clonePointer(this), FfiConverterTypeStartShellOptions.lower(opts));
      }, /*pollFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_poll_pointer, /*cancelFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_cancel_pointer, /*completeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_complete_pointer, /*freeFunc:*/nativeModule().ubrn_ffi_uniffi_russh_rust_future_free_pointer, /*liftFunc:*/FfiConverterTypeShellSession.lift.bind(FfiConverterTypeShellSession), /*liftString:*/FfiConverterString.lift, /*asyncOpts:*/asyncOpts_, /*errorHandler:*/FfiConverterTypeSshError.lift.bind(FfiConverterTypeSshError));
    } catch (__error) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy() {
    const ptr = this[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSshConnectionObjectFactory.pointer(this);
      uniffiTypeSshConnectionObjectFactory.freePointer(pointer);
      uniffiTypeSshConnectionObjectFactory.unbless(ptr);
      delete this[destructorGuardSymbol];
    }
  }
  static instanceOf(obj) {
    return uniffiTypeSshConnectionObjectFactory.isConcreteType(obj);
  }
}
const uniffiTypeSshConnectionObjectFactory = (() => {
  return {
    create(pointer) {
      const instance = Object.create(SshConnection.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SshConnection';
      return instance;
    },
    bless(p) {
      return uniffiCaller.rustCall(/*caller:*/status => nativeModule().ubrn_uniffi_internal_fn_method_sshconnection_ffi__bless_pointer(p, status), /*liftString:*/FfiConverterString.lift);
    },
    unbless(ptr) {
      ptr.markDestroyed();
    },
    pointer(obj) {
      if (obj[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return obj[pointerLiteralSymbol];
    },
    clonePointer(obj) {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_clone_sshconnection(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    freePointer(pointer) {
      uniffiCaller.rustCall(/*caller:*/callStatus => nativeModule().ubrn_uniffi_uniffi_russh_fn_free_sshconnection(pointer, callStatus), /*liftString:*/FfiConverterString.lift);
    },
    isConcreteType(obj) {
      return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'SshConnection';
    }
  };
})();
// FfiConverter for SshConnectionInterface
const FfiConverterTypeSshConnection = new FfiConverterObject(uniffiTypeSshConnectionObjectFactory);

// FfiConverter for DroppedRange | undefined
const FfiConverterOptionalTypeDroppedRange = new FfiConverterOptional(FfiConverterTypeDroppedRange);

// FfiConverter for TerminalPixelSize | undefined
const FfiConverterOptionalTypeTerminalPixelSize = new FfiConverterOptional(FfiConverterTypeTerminalPixelSize);

// FfiConverter for TerminalSize | undefined
const FfiConverterOptionalTypeTerminalSize = new FfiConverterOptional(FfiConverterTypeTerminalSize);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for Array<TerminalChunk>
const FfiConverterArrayTypeTerminalChunk = new FfiConverterArray(FfiConverterTypeTerminalChunk);

// FfiConverter for Array<TerminalMode>
const FfiConverterArrayTypeTerminalMode = new FfiConverterArray(FfiConverterTypeTerminalMode);

// FfiConverter for ConnectProgressCallback | undefined
const FfiConverterOptionalTypeConnectProgressCallback = new FfiConverterOptional(FfiConverterTypeConnectProgressCallback);

// FfiConverter for ConnectionDisconnectedCallback | undefined
const FfiConverterOptionalTypeConnectionDisconnectedCallback = new FfiConverterOptional(FfiConverterTypeConnectionDisconnectedCallback);

// FfiConverter for ShellClosedCallback | undefined
const FfiConverterOptionalTypeShellClosedCallback = new FfiConverterOptional(FfiConverterTypeShellClosedCallback);

// FfiConverter for Array<TerminalMode> | undefined
const FfiConverterOptionalArrayTypeTerminalMode = new FfiConverterOptional(FfiConverterArrayTypeTerminalMode);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion = nativeModule().ubrn_ffi_uniffi_russh_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_func_connect() !== 33247) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_func_connect');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_func_extract_public_key() !== 41250) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_func_extract_public_key');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_func_generate_key_pair() !== 37501) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_func_generate_key_pair');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_func_validate_private_key() !== 49309) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_func_validate_private_key');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_connectprogresscallback_on_change() !== 17699) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_connectprogresscallback_on_change');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_connectiondisconnectedcallback_on_change() !== 43914) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_connectiondisconnectedcallback_on_change');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_serverkeycallback_on_change() !== 5111) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_serverkeycallback_on_change');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellclosedcallback_on_change() !== 56252) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_shellclosedcallback_on_change');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shelllistener_on_event() !== 12161) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_shelllistener_on_event');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_add_listener() !== 43852) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_shellsession_add_listener');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_buffer_stats() !== 11878) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_shellsession_buffer_stats');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_close() !== 22391) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_shellsession_close');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_current_seq() !== 5967) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_shellsession_current_seq');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_get_info() !== 45659) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_shellsession_get_info');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_read_buffer() !== 52380) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_shellsession_read_buffer');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_remove_listener() !== 24718) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_shellsession_remove_listener');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_resize_pty() !== 27901) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_shellsession_resize_pty');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_shellsession_send_data() !== 12893) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_shellsession_send_data');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_sshconnection_disconnect() !== 1510) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_sshconnection_disconnect');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_sshconnection_get_info() !== 31556) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_sshconnection_get_info');
  }
  if (nativeModule().ubrn_uniffi_uniffi_russh_checksum_method_sshconnection_start_shell() !== 21163) {
    throw new UniffiInternalError.ApiChecksumMismatch('uniffi_uniffi_russh_checksum_method_sshconnection_start_shell');
  }
  uniffiCallbackInterfaceConnectProgressCallback.register();
  uniffiCallbackInterfaceConnectionDisconnectedCallback.register();
  uniffiCallbackInterfaceServerKeyCallback.register();
  uniffiCallbackInterfaceShellClosedCallback.register();
  uniffiCallbackInterfaceShellListener.register();
}
export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBufferReadResult,
    FfiConverterTypeBufferStats,
    FfiConverterTypeConnectOptions,
    FfiConverterTypeConnectProgressCallback,
    FfiConverterTypeConnectionDetails,
    FfiConverterTypeConnectionDisconnectedCallback,
    FfiConverterTypeCursor,
    FfiConverterTypeDroppedRange,
    FfiConverterTypeKeyType,
    FfiConverterTypeListenerOptions,
    FfiConverterTypeSecurity,
    FfiConverterTypeServerKeyCallback,
    FfiConverterTypeServerPublicKeyInfo,
    FfiConverterTypeShellClosedCallback,
    FfiConverterTypeShellEvent,
    FfiConverterTypeShellListener,
    FfiConverterTypeShellSession,
    FfiConverterTypeShellSessionInfo,
    FfiConverterTypeSshConnection,
    FfiConverterTypeSshConnectionInfo,
    FfiConverterTypeSshConnectionInfoProgressTimings,
    FfiConverterTypeSshConnectionProgressEvent,
    FfiConverterTypeSshError,
    FfiConverterTypeStartShellOptions,
    FfiConverterTypeStreamKind,
    FfiConverterTypeTerminalChunk,
    FfiConverterTypeTerminalMode,
    FfiConverterTypeTerminalPixelSize,
    FfiConverterTypeTerminalSize,
    FfiConverterTypeTerminalType
  }
});
//# sourceMappingURL=uniffi_russh.js.map