<review_context>
<topic>Tmux Touch Scroll Copy-Mode Implementation (v5.1)</topic>
<branch>bug/2-terminal-modal-ux-fixes</branch>
<tokens>37,764</tokens>
<files>6</files>
<generated>2026-01-06</generated>
<version>5.1 - Single writer queue, bracketed paste detection, invalid cancelKey handling</version>
</review_context>

<review_instructions>
You are reviewing **v5.1** of a design for **native finger-drag scrolling** in a React Native terminal app with tmux via SSH.

## Key Changes in v5.1 (from v5 final)
1. **Confidence after first scroll key** - Not just after copy-mode entry; must emit arrow/PgUp/PgDn
2. **Invalid cancelKey handling** - If multi-byte or Esc, disable auto-exit+payload, require "Jump to live"
3. **Optimistic scrollbackActive reset** - Set `scrollbackActiveRef.current = false` after initiating exit
4. **containsBracketedPaste()** - Detect `\x1b[200~` markers, force large payload path
5. **Phase-aware input gating** - Both phases gate inputs through sendInputEnsuringLive; pill only on `active`
6. **Single Writer Queue appendix** - All PTY writes (RN + WebView) must go through same per-connection queue
7. **Recovery sequence note** - Best-effort; may cause minor movement if already in copy-mode
8. **pointerdown clears pendingPointerUp** - Handle rapid up/down cycles during entry timer
9. **New test case** - "Start drag (entering) then trigger RN paste/preset"

## Your Review Task
1. Review **Single Writer Queue** - is "no interleaving" across RN+WebView writes achievable?
2. Validate **bracketed paste detection** - is checking for `\x1b[200~` sufficient?
3. Check **invalid cancelKey fallback** - require explicit "Jump to live" before input
4. Review **optimistic scrollbackActive reset** - any race conditions?
5. Assess **phase-aware gating** - both phases gate, but pill only on `active`

## Focus Areas
- Single writer queue: how to ensure WebView `input` messages also use the queue
- Bracketed paste: what if paste starts mid-buffer? What about `\x1b[201~` (end marker)?
- Invalid cancelKey: UX when user can't type until they tap "Jump to live"
- Optimistic reset: what if exitScrollback fails silently?
</review_instructions>

This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: docs/design/tmux-touch-scroll-copy-mode.md, packages/react-native-xtermjs-webview/src/bridge.ts, packages/react-native-xtermjs-webview/src-internal/main.tsx, packages/react-native-xtermjs-webview/src/index.tsx, apps/mobile/src/app/shell/detail.tsx, docs/design/mobile-scrolling-terminal.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
apps/
  mobile/
    src/
      app/
        shell/
          detail.tsx
docs/
  design/
    mobile-scrolling-terminal.md
    tmux-touch-scroll-copy-mode.md
packages/
  react-native-xtermjs-webview/
    src/
      bridge.ts
      index.tsx
    src-internal/
      main.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/design/tmux-touch-scroll-copy-mode.md">
# Android Tablet Touch Scrolling (Tmux Copy-Mode)

**Status:** Draft design (implementation-ready, v5 final)
**Related:** [mobile-scrolling-terminal.md](./mobile-scrolling-terminal.md), [tmux-scrollback-implementation.md](./tmux-scrollback-implementation.md)

## Summary

Implement **native-feeling finger-drag scrolling** in tmux on **Android tablets** by translating touch gestures into **tmux copy-mode** key sequences. The WebView intercepts touch events, enters copy‑mode on drag, emits Up/Down (or PgUp/PgDn) keys as the user moves, and **keeps copy‑mode active** so the user can read scrollback. Copy‑mode exits only on an explicit action (e.g. typing or a “Jump to live” affordance). This provides a natural scroll experience without altering tmux config or disabling alternate screen.

## Goals

- One‑finger drag on the terminal scrolls tmux history (copy-mode) on Android tablets.
- Prevent WebView or xterm.js from performing native scroll (no “double scroll”).
- Preserve long‑press selection and existing selection overlay behavior.
- Work for existing tmux sessions without requiring user tmux config changes.
- Keep latency tolerable by coalescing and rate‑limiting scroll events.

## Non‑Goals

- iOS support in this iteration.
- Perfect pixel‑level sync between finger movement and rendered scroll.
- Multi‑pane awareness or “scroll only one pane” selection UX.
- tmux control mode or capture‑pane scrollback (see related designs).

## Constraints & Assumptions

- Android tablet devices only (enable by screen size heuristic).
- Tmux is active (connection uses `useTmux: true`).
- Default tmux prefix is `Ctrl+B` unless user overrides in settings.
- Copy‑mode cancel is **typically `q`** in tmux defaults, but users can rebind copy‑mode tables. Treat `exitKey` as configurable; default to `q`.
- Injecting `Esc` is problematic when followed by arbitrary bytes (escape-time and escape-sequence ambiguity). Prefer `q` as the **default injected cancel key**, but allow override because users can rebind copy-mode tables.
- `C-c` can also cancel in many setups but is **riskier if it leaks** (it can interrupt running programs). Prefer `q`; allow override but discourage `C-c` as the default.
- Validate `cancelKey` at runtime: it must be **one byte** and **not Esc** for auto‑exit + payload. If invalid, **disable auto‑exit + payload** and require explicit “Jump to live” (or a recovery exit) before sending input.
- Prefix mismatch will cause scroll gestures to inject keys without entering copy‑mode; mitigate by exposing a per‑connection prefix setting (MVP).

## Architecture Overview

```
Touch gesture (WebView)
   ↓
TouchScrollController (xterm.js page)
   ↓ (send input sequences)
Bridge: { type: 'input', str: "\x02[..." }
   ↓
React Native (detail.tsx onData)
   ↓
Rust SSH PTY → tmux attach → copy-mode scroll
```

### Why copy‑mode
- Tmux owns scrollback when attached; xterm.js scrollback is not authoritative.
- Copy‑mode is a supported tmux mechanism with stable keybindings.

## Gesture → Key Mapping

**Base sequences** (xterm style):
- Enter copy‑mode: `Ctrl+B` then `[` → `\x02[`
- Up arrow: `\x1b[A`
- Down arrow: `\x1b[B`
- Page Up: `\x1b[5~`
- Page Down: `\x1b[6~`
- Exit copy‑mode: typically `q` (configurable)

**Recovery exit sequence** (use only when state is uncertain):
- `prefixKey + copyModeKey + cancelKey` so tmux consumes the exit even if copy‑mode wasn’t active yet.
- When already in ScrollbackActive, prefer a **single cancel key** (no prefix) to avoid assume‑paste‑time and escape‑time issues.

**Mapping rules (direct manipulation)**:
- **Finger moves down** (`dy > 0`) → reveal **older** content: send Up or PgUp
- **Finger moves up** (`dy < 0`) → reveal **newer** content: send Down or PgDn
- **Small deltas** → line scroll (arrow keys)
- **Fast flick** → page scroll (PgUp/PgDn) + residual line scroll
Use `invertScroll` to flip direction if testing shows the device feels “reversed”.

## TouchScrollController Design

### State Machine

```
Idle
  └─ pointerdown → Tracking (startPoint, time)
      ├─ move < slop → Tracking
      ├─ move ≥ slop → Scrolling (enter copy‑mode once)
      └─ long-press → SelectionMode (existing behavior)

Scrolling
  ├─ pointermove → emit scroll steps (rate‑limited)
  ├─ pointerup → ScrollbackActive (stay in copy‑mode)
  └─ pointercancel → ScrollbackActive

ScrollbackActive (copy‑mode engaged; no pointer down)
  ├─ pointerdown → Tracking (continue scrolling)
  ├─ keyboard input → exit copy‑mode once, then forward input
  └─ explicit “Jump to live” action → exit copy‑mode
```

When returning from ScrollbackActive to Tracking/Scrolling, **do not re‑enter copy‑mode**; keep `copyModeEngaged` true and only emit arrow/PgUp/PgDn.
If using `scrollbackModeChanged.phase`, emit `phase:'active'` on the pointerup transition to ScrollbackActive.

Copy‑mode entry is **two‑phase** when `prefixKey` and `copyModeKey` are split:
`copyModeState: 'off' | 'entering' | 'on'`. While **entering**, accumulate scroll deltas but **do not emit** arrow/Pg keys until the `copyModeKey` has been sent.

`copyModeConfidence` becomes **confident** only after copy‑mode entry completes **and the first scroll key is emitted** (arrow/PgUp/PgDn). It becomes **uncertain** after WebView reload, config disable, any forced recovery exit, or a config change while active (prefix/copyMode/cancelKey). Use it to decide whether to send a single `cancelKey` vs the recovery sequence.

Pointer transitions:
- `pointerdown`: set `pointerIsDown = true`. If `copyModeState === 'entering'`, clear `pendingPointerUp = false`.
- `pointerup` while `copyModeState === 'entering'`: set `pendingPointerUp = true` so entry completes with `phase:'active'` **only if the finger is still up** when the timer fires.

### Thresholds & Tuning (defaults)

- **slopPx**: 8–12px (start scroll only after a small move)
- **pxPerLine**: ~16px (one line per 16px of drag)
- **maxLinesPerFrame**: 6 (avoid flooding)
- **flickVelocity**: > 1.2 px/ms triggers PgUp/PgDn
- **remainderPx**: keep fractional remainder so slow drags don’t feel “sticky”.
- **enterDelayMs**: 10ms between `prefixKey` and `copyModeKey` (tweakable).
Prefer rate limiting via a single `requestAnimationFrame` flush that emits up to `maxLinesPerFrame`.
Define `pageStepLines = Math.max(10, term.rows - 1)` for PgUp/PgDn handling.
Clamp `dt` (e.g. `dt = Math.max(dt, 8)`) to avoid noisy velocity spikes.
Flush once on `pointerup` to apply any remaining pendingLines before entering ScrollbackActive.
Cap `pendingLines` to ±(3–5 pages) to avoid “scroll keeps going after I stopped”.

tmux note: `assume-paste-time` can suppress key bindings if keys arrive too fast. Mitigations:
- Send `prefixKey` and `copyModeKey` as **separate sends** (tiny delay is fine).
- Do **not** emit arrow/Pg keys until `copyModeKey` has been sent (gate on `copyModeState === 'on'`).
- Avoid large `key.repeat(count)` bursts; prefer smaller batches (1–2 arrows) and PgUp/PgDn for fast movement.
- If you must send the **recovery exit sequence** (`prefix + [` + cancelKey), send it in ordered chunks (not a single burst) and only then send any payload.

### Computing Line Height

Prefer layout‑derived value to avoid hard‑coded font size:

```
lineHeightPx = term.element.clientHeight / term.rows
pxPerLine = max(12, lineHeightPx)
```

Avoid direct use of private xterm internals unless necessary.

### Preventing Native Scroll

On scroll tracking:
- Use **Pointer Events** with `pointerId` tracking and `setPointerCapture` **after slop**.
- Only call `preventDefault()` / `stopPropagation()` **after** slop is exceeded.
- Set `touch-action: none` on the terminal container **when the feature is enabled** (so the current gesture isn’t treated as a pan by WebView).
- Ignore secondary pointers (`event.isPrimary === false`) to avoid multi‑touch conflicts.

If Touch Events are used as a fallback, register `touchmove` with `{ passive: false }` so `preventDefault()` works on Android WebView.

This blocks WebView and xterm.js from moving their own scrollback.

## Integration Points (Files)

### 1) WebView Bridge Types
**File:** `packages/react-native-xtermjs-webview/src/bridge.ts`

Add outbound config:

```ts
export type TouchScrollConfig = {
	enabled: boolean;
	pxPerLine?: number;
	slopPx?: number;
	maxLinesPerFrame?: number;
	flickVelocity?: number;
	invertScroll?: boolean; // optional: invert natural direction
	enterDelayMs?: number; // delay between prefixKey and copyModeKey (default 10)
	prefixKey?: string; // default "\x02"
	copyModeKey?: string; // default "["
	exitKey?: string; // user exit key (default "q")
	cancelKey?: string; // injected cancel key (default "q"; avoid "\x1b" for auto-exit)
	debug?: boolean;
};

export type BridgeOutboundMessage =
	| { type: 'setTouchScrollConfig'; config: TouchScrollConfig }
	| { type: 'exitScrollback'; emitExit?: boolean; requestId?: number } // emitExit=false when RN already sent cancelKey
	| ...existing;

export type BridgeInboundMessage =
	| { type: 'initialized'; instanceId: string }
	| { type: 'input'; str: string; instanceId: string }
	| { type: 'selectionChanged'; text: string; instanceId: string }
	| { type: 'selection'; requestId: number; text: string; instanceId: string }
	| {
			type: 'scrollbackModeChanged';
			active: boolean;
			phase?: 'dragging' | 'active';
			instanceId: string;
			requestId?: number;
	  }
	| ...existing;
```

`scrollbackModeChanged` lets RN coordinate *all* input sources (on‑screen keyboard, paste, presets). Use `phase:'active'` (finger up) to control pill visibility.
If `phase` is omitted, emit `active:true` only on pointerup (ScrollbackActive).
`instanceId` on `initialized` and `input` prevents stale WebView messages from affecting current sessions.

### 2) WebView Controller Implementation
**File:** `packages/react-native-xtermjs-webview/src-internal/main.tsx`

Add `TouchScrollController` that:
- Installs `pointerdown/pointermove/pointerup/pointercancel` handlers on the terminal root.
- Uses config to enable/disable and tune behavior.
- Sends scroll sequences by calling `sendToRn({ type: 'input', str, instanceId })`.
- Respects `selectionModeEnabled` and exits early when selection mode is on.
- When `scrollbackActive` and the user types, sends the **cancelKey** once before forwarding the input (except when the input is the exitKey itself).
- Cancels any pending scroll flushes before exiting.
- Emits `scrollbackModeChanged` when entering/exiting (for RN UI + input coordination), including a WebView `instanceId`.
  - Emit `phase:'dragging'` when copy‑mode is first engaged (slop exceeded).
  - Emit `phase:'active'` on pointerup when entering ScrollbackActive.
- `exitScrollback` behavior:
  - `emitExit: true` (default): send **cancelKey** if copy‑mode is engaged; otherwise use the recovery exit sequence (split into ordered chunks), then clear state.
  - `emitExit: false`: clear pending scroll + state **only** (RN already sent exit bytes); cancel rAF flush, reset `pendingLines`/`remainderPx`, and release pointer capture if held.
  - If `requestId` is provided, echo it back on `scrollbackModeChanged(active:false)` so RN can await if needed.
  - `exitScrollback(emitExit:true)` may be called even if state is stale; the recovery exit sequence is **best‑effort** and may cause minor movement if already in copy‑mode.
- Exposes an `exitScrollback` handler that:
  - cancels pending scroll flushes,
  - exits copy‑mode using cancelKey or the recovery sequence,
  - clears internal state,
  - emits `scrollbackModeChanged(false)`.

Pseudocode:

```ts
let touchConfig = { enabled: false, pxPerLine: 16, slopPx: 8, ... };
type ScrollState = 'Idle' | 'Tracking' | 'Scrolling' | 'ScrollbackActive';
type CopyModeState = 'off' | 'entering' | 'on';
let state: ScrollState = 'Idle';
let copyModeState: CopyModeState = 'off';
let copyModeEngaged = false;
let copyModeConfidence: 'uncertain' | 'confident' = 'uncertain';
let enterTimer: number | null = null;
const instanceId = Math.random().toString(36).slice(2);
let pointerIsDown = false;
let pendingPointerUp = false;

function ensureCopyMode() {
	if (copyModeState !== 'off') return;
	copyModeState = 'entering';
	const delayMs = touchConfig.enterDelayMs ?? 10;
	sendToRn({ type: 'input', str: touchConfig.prefixKey, instanceId });
	enterTimer = window.setTimeout(() => {
		sendToRn({ type: 'input', str: touchConfig.copyModeKey, instanceId });
		copyModeState = 'on';
		copyModeEngaged = true;
		sendToRn({
			type: 'scrollbackModeChanged',
			active: true,
			phase: pointerIsDown ? 'dragging' : 'active',
			instanceId,
		});
		scheduleFlush(); // now safe to emit arrows/Pg keys
		if (!pointerIsDown && pendingPointerUp) {
			// Pointer already lifted; finalize ScrollbackActive and flush once.
			state = 'ScrollbackActive';
			pendingPointerUp = false;
		}
	}, delayMs);
}

function exitCopyMode({ emitExit = true, recovery = false } = {}) {
	if (enterTimer) {
		clearTimeout(enterTimer);
		enterTimer = null;
	}
	cancelPendingScroll(); // clear rAF, pendingLines, remainderPx
	copyModeState = 'off';
	if (emitExit) {
		const delayMs = touchConfig.enterDelayMs ?? 10;
		const cancelKey = touchConfig.cancelKey ?? 'q';
		const exitKey = touchConfig.exitKey ?? 'q';
		if (copyModeEngaged && copyModeConfidence === 'confident' && !recovery) {
			// Single-key cancel when we believe copy-mode is active.
			sendToRn({ type: 'input', str: cancelKey, instanceId });
		} else {
		// Recovery exit sequence, sent in ordered chunks (no burst). Best-effort; may cause minor movement if already in copy-mode.
			sendToRn({ type: 'input', str: touchConfig.prefixKey, instanceId });
			window.setTimeout(() => {
				sendToRn({ type: 'input', str: touchConfig.copyModeKey, instanceId });
				window.setTimeout(() => {
					sendToRn({ type: 'input', str: cancelKey, instanceId });
				}, delayMs);
			}, delayMs);
		}
	}
	copyModeEngaged = false;
	copyModeConfidence = 'uncertain';
	state = 'Idle';
	sendToRn({ type: 'scrollbackModeChanged', active: false, instanceId });
}

function emitLines(deltaLines: number) {
	if (deltaLines === 0) return;
	ensureCopyMode();
	if (copyModeState !== 'on') return; // gate until copy-mode entered
	if (copyModeConfidence !== 'confident') {
		copyModeConfidence = 'confident';
	}
	// deltaLines > 0 means finger moved down (natural), scroll back (Up).
	const natural = touchConfig.invertScroll ? -1 : 1;
	const key = deltaLines * natural > 0 ? '\x1b[A' : '\x1b[B';
	const count = Math.min(Math.abs(deltaLines), touchConfig.maxLinesPerFrame);
	// Avoid huge repeats; emit small batches if tmux assume-paste-time is sensitive.
	sendToRn({ type: 'input', str: key.repeat(count), instanceId });
}

// When the user types while scrollbackActive:
// If input matches exitKey/Esc: send exitKey only, mark inactive (no forward).
// Otherwise: exitCopyMode(); then send the original input data.
```

### Rate limiting + flick rule (explicit)

Suggested algorithm:

```
onPointerMove:
  accumulate dy into remainderPx
  convert to pendingLines = trunc(remainderPx / pxPerLine)
  remainderPx -= pendingLines * pxPerLine
  ensureCopyMode()
  if copyModeState !== 'on': return // wait for copy-mode entry before emitting
  if |velocity| >= flickVelocity && |pendingLines| >= 4:
    send one PgUp/PgDn immediately
    set copyModeConfidence = 'confident'
    pendingLines = pendingLines % pageStepLines
  schedule rAF flush if not scheduled

onFlush (rAF):
  if copyModeState !== 'on': return
  emit up to maxLinesPerFrame via arrows (prefer small batches to avoid assume-paste-time)
  set copyModeConfidence = 'confident' once a scroll key is emitted
  keep any remaining pendingLines for next frame
```

### 3) React Native Prop Surface
**File:** `packages/react-native-xtermjs-webview/src/index.tsx`

Add prop:

```ts
export type XtermJsWebViewProps = {
	// ...existing
	touchScrollConfig?: TouchScrollConfig;
	onScrollbackModeChange?: (event: {
		active: boolean;
		phase?: 'dragging' | 'active';
		instanceId: string;
		requestId?: number;
	}) => void;
};
```

On mount / config change, send `setTouchScrollConfig` to WebView.
Send only after `{ type: 'initialized' }` has been received.

Add imperative handle for exit:

```ts
export type XtermWebViewHandle = {
  // ...existing
  exitScrollback: (opts?: { emitExit?: boolean; requestId?: number }) => void;
};
```

### 4) Mobile Integration
**File:** `apps/mobile/src/app/shell/detail.tsx`

- Compute `isTablet` via screen size heuristic (e.g. `min(width, height) >= 600`).
- Enable touch scroll only on Android tablets and tmux sessions:

```ts
const shouldEnableTouchScroll = Platform.OS === 'android' && isTablet && useTmux;
```

Pass config:

```tsx
<XtermJsWebView
  // ...existing
  touchScrollConfig={{
    enabled: shouldEnableTouchScroll,
    pxPerLine: 16,
    slopPx: 10,
    maxLinesPerFrame: 6,
    flickVelocity: 1.2,
    invertScroll: false,
    enterDelayMs: 10,
    prefixKey: tmuxPrefixKey, // from connection settings (default '\x02')
    copyModeKey: '[',
    exitKey: tmuxCopyModeExitKey, // default 'q' unless user overrides
    cancelKey: tmuxCancelKey, // injected cancel key (default 'q')
    debug: false,
  }}
/>

Handle scrollback state + inputs:

- Store `currentInstanceId` from `{ type:'initialized', instanceId }`.
- Ignore **all** WebView messages (`input`, `scrollbackModeChanged`, selection) whose `instanceId` does not match `currentInstanceId`.
- Store `scrollbackActive` from `scrollbackModeChanged` (phase‑aware if provided).
- Treat `active:true` in **both phases** as “gate inputs through sendInputEnsuringLive”; show the pill only when `phase === 'active'`.
- Reset `scrollbackActive=false` on WebView `initialized` (new `instanceId`) and on reconnect.
- If `touchScrollConfig.enabled` flips to false while active, request `exitScrollback({ emitExit: true })`.
- Before any RN‑originated input (TerminalKeyboard, paste, presets, commander), if `scrollbackActive`:
  - RN sends **cancelKey** (single key) directly to SSH (ordering guarantee),
  - then sends the intended bytes/text (combine only if cancelKey is a single non-Esc byte),
  - then calls `exitScrollback({ emitExit: false })` to clear WebView state/UI (no extra exit bytes).
  - Use the **recovery exit sequence** only when you are not confident copy-mode is active.
  - Optimistically set `scrollbackActiveRef.current = false` after initiating exit to avoid double‑cancel on back‑to‑back actions.

Ordering guarantee helper (recommended):

```
function sendInputEnsuringLive(bytes: Uint8Array) {
  if (scrollbackActiveRef.current) {
    if (isExactExitKey(bytes, exitKey)) {
      sendBytesRaw(exitKeyBytes);
      xtermRef.current?.exitScrollback({ emitExit: false });
      return;
    }
    const isLargePayload =
      bytes.length > 32 ||
      bytes.includes(0x0a) || // \n
      bytes.includes(0x0d) || // \r
      containsBracketedPaste(bytes); // \x1b[200~
    // Combine only if cancelKey is a single non-Esc byte and payload is small.
    if (canCombineCancelKey(cancelKeyBytes, bytes) && !isLargePayload) {
      sendBytesRaw(concatBytes(cancelKeyBytes, bytes));
    } else {
      // Ordered queue or small delay to avoid assume-paste-time / escape-time issues.
      sendBytesQueued([cancelKeyBytes, bytes]);
    }
    xtermRef.current?.exitScrollback({ emitExit: false });
    return;
  }
  sendBytesRaw(bytes);
}
```

Notes:
- `cancelKeyBytes` should be a single non-Esc byte to allow safe concatenation.
- If `cancelKey` is invalid (multi‑byte or Esc), **skip auto‑exit + payload** and require explicit “Jump to live” before sending input.
- `containsBracketedPaste(bytes)` should detect bracketed paste markers (e.g. `\x1b[200~`) and force the “large payload” path.
- `sendBytesQueued` is a per-connection ordered queue (or small-delay sequencer) used when concatenation is unsafe.
  - Guarantees **no interleaving** with other writes while draining.
  - Supports an **optional delay** between segments (>= `enterDelayMs`).
  - Treats large payloads as a single segment even if chunked internally.
  - **All PTY writes** (RN and WebView forwarded) must go through the same writer/queue so queued segments cannot be interleaved by “raw” writes.

## Selection Mode Interactions

- If selection mode is active, **ignore** touch scrolling.
- If a long‑press is in progress and the user starts dragging beyond `slopPx`, **cancel long‑press** and start scroll.
- Selection mode does **not** exit copy‑mode; users can select text while scrolled up.

Implementation note: expose a `cancelLongPress()` hook from the long‑press handler (or consolidate into a single gesture manager) so scroll takeover reliably cancels the timer.

## Exit‑on‑typing Semantics

- Triggered for **user typing** (`term.onData`) and RN‑originated inputs (paste, presets, on‑screen keyboard).
- If the next input **equals the configured exit key** (`q` or `Esc`), send only the **exitKey** and mark scrollback inactive (avoid “exit then stray q”).
- Treat it as a match only for an **exact single-key payload** (`bytes.length === exitKey.length`).
- For `term.onData` (WebView‑originated): call `exitScrollback({ emitExit: true })`, then forward the input (unless it matched exitKey).
- For RN‑originated input: use `sendInputEnsuringLive` (RN sends cancelKey directly, then input).
- Auto‑exit uses `cancelKey` (not `exitKey`) to avoid `Esc` injection before arbitrary payloads.
- Optional: keep navigation keys (`\x1b[A`, `\x1b[B`, `\x1b[5~`, `\x1b[6~`) inside scrollback if hardware keyboard UX matters.

## Scrollback UI (Jump‑to‑Live)

MVP‑friendly affordance:
- When `scrollbackActive` is true, show a small overlay pill: **“Scrollback • Jump to live”**.
- Tapping it calls `exitScrollback()` (cancelKey if engaged; recovery sequence if not), clears pending scroll.
- Show the pill only in `ScrollbackActive` (finger up), not while actively dragging.
- Optional: single tap anywhere on terminal (no movement) can also exit, but only if it doesn’t interfere with long‑press selection.

If using `scrollbackModeChanged.phase`, show the pill only when `phase === 'active'`.

## Error Handling & Edge Cases

| Case | Behavior |
| --- | --- |
| Not in tmux | Touch scroll disabled by config. |
| Multi‑touch gesture | Ignore (no scroll). |
| Fast repeated drags | Reuse `scrollbackActive`; pointer capture ensures continuity. |
| Prefix mismatch | Scroll gestures inject keys; require prefix config or disable feature. |
| Cancel key unsafe | Prefer `q` (C‑c discouraged); if `cancelKey` is invalid, disable auto‑exit+payload and require explicit “Jump to live.” |
| Copy‑mode already active | Still send arrows; avoid re‑entering. |
| Full‑screen app inside tmux | Copy‑mode handles scroll; tmux remains source of truth. |
| Network latency spikes | Coalesce input, limit rate, avoid flooding. |

## UX Notes (Android Tablet)

- Scrolling should feel similar to a document view, but with **line‑based steps**.
- Keep velocity‑based page jumps conservative (tablet users prefer predictability).
- Provide a toggle in settings later if needed (not in MVP).

## Testing Plan

**Manual (device):**
- Drag up/down to scroll tmux history (tmux session active).
- Release finger → scrollback stays (copy‑mode remains active).
- Start typing → exits copy‑mode once, then input is delivered.
- Trigger paste / preset / on‑screen keyboard while in scrollback → exits copy‑mode once, then input is delivered.
- Short drags → line scroll; fast flicks → page scroll.
- Long‑press selection still works; selection handles appear and scroll is suppressed.
- Non‑tmux session: drag does not inject tmux keys.
- While keyboard is open: drag still scrolls and does not type characters.
- Fast flick + immediate finger up: no arrows before copy‑mode entry.
- Start drag (copyModeState=entering) then trigger RN paste/preset: cancel + payload go to live; pending scroll cleared.
- exitKey configured as Esc: exit still works; no Esc-prefixed payload issues.
- Large paste while in scrollback with default `assume-paste-time`: cancel still happens before paste.
- WebView reload mid‑scrollback: stale messages ignored; UI resets.

**Instrumentation:**
- Optional debug logs in WebView: start/stop scroll, emitted line counts.

## Appendix: Single Writer Queue (Required)

To guarantee **no interleaving** between cancel/payload and late scroll emissions, **all PTY writes must go through a single per‑connection writer/queue**, including:

- RN‑originated input (keyboard, paste, presets, commander).
- WebView‑originated `{ type:'input' }` (scroll arrows/PgUp/PgDn, recovery sequences).

**Rule:** if the queue is draining, “raw” writes must **enqueue as single segments** (not bypass the queue).

**Queue requirements (minimum):**
- Preserve **global ordering** across all writes.
- Support **batched segments** with an optional inter‑segment delay (>= `enterDelayMs`).
- Treat large payloads (paste/macro) as a **single segment** even if internally chunked.

## Rollout Plan

1. Land bridge + WebView controller (behind `touchScrollConfig.enabled`).
2. Add scrollback‑active behavior (no auto exit), `scrollbackModeChanged`, and exit‑on‑typing for *all* input paths.
3. Enable on Android tablets only for tmux sessions.
4. Tune thresholds and direction on device.

## Decisions & Follow‑ups

- **MVP:** add a per‑connection tmux prefix setting (default C‑b); auto‑detect can follow once an exec channel exists.
- **MVP:** add a per‑connection `exitKey` setting (default `q`) and `cancelKey` (default `q`) to handle custom copy‑mode bindings.
- **MVP:** add `cancelKey` (default `q`) for auto‑exit; avoid injecting `Esc` before arbitrary payloads.
- Consider two‑finger scrolling if selection conflicts persist.
- Optional: UI hint (“Scrollback • tap to live”) if discoverability is an issue.
- Optional: set xterm `scrollback: 0` while touch scroll is enabled to avoid confusing dual scroll paths.
</file>

<file path="docs/design/mobile-scrolling-terminal.md">
# Mobile Terminal Scrolling Feature - Deep Research Request

## Problem Statement

I have a React Native mobile app that connects to remote SSH servers and opens Tmux sessions. The terminal is rendered using xterm.js inside a WebView. I want **native tablet finger-drag scrolling** to control the **Tmux scrollback buffer** - so users can put their finger on the screen and drag up/down to scroll through terminal history, just like scrolling through any mobile app content.

**Current behavior:** Terminal scrolling is handled entirely within xterm.js (CSS overflow), and native touch gestures are blocked (`bounces: false`, `overScrollMode: 'never'`).

**Desired behavior:** Touch-drag gestures should scroll through Tmux's scrollback history (not just xterm.js's local buffer). The goal is ~3 pages of scrollback accessible via intuitive finger-drag, similar to scrolling a web page or document.

## Architecture Overview

### Stack
- **React Native** (Expo) mobile app
- **WebView** containing **xterm.js** terminal
- **Rust SSH client** (via UniFFI bindings) connecting to remote servers
- **Tmux** sessions on the remote server

### Data Flow
```
User's Tablet
     ↓
React Native App
     ↓
WebView (xterm.js renders terminal output)
     ↓
Rust SSH Bridge (ring buffer of terminal output)
     ↓
SSH Connection → Remote Server → Tmux Session
```

### Key Components

1. **xterm.js** - Renders terminal in WebView, has its own `scrollback: 10000` buffer, handles rendering and cursor positioning

2. **Tmux** - Runs on remote server, has separate scrollback buffer, copy-mode for scrolling (`prefix + [`), responds to mouse wheel events (if mouse mode enabled)

3. **WebView Bridge** - Messages between React Native and xterm.js via postMessage/injectJavaScript

4. **Rust SSH Shell** - Ring buffer stores terminal output locally, supports `readBuffer()` for replay

## Technical Challenges

### Challenge 1: Two Separate Scroll Buffers
- **xterm.js buffer**: Local in WebView, stores what was rendered
- **Tmux buffer**: Remote on server, authoritative source of scrollback
- These are NOT synchronized - xterm.js only knows what Tmux sent to display

### Challenge 2: Tmux Scroll Requires Copy-Mode
- Normal Tmux scroll requires entering "copy-mode" (`prefix + [`)
- In copy-mode, terminal enters alternate mode where normal input is blocked
- Scroll commands are `C-u`/`C-d` (half page), `PgUp`/`PgDn`, or mouse wheel
- This changes terminal state and visual appearance

### Challenge 3: Touch Gesture Translation
- Native touch scrolling expects immediate visual feedback
- Tmux scroll requires sending commands to remote server, waiting for response
- Round-trip latency (50-200ms) would make scrolling feel sluggish/unresponsive

### Challenge 4: Viewport Sync Problem
- If we scroll xterm.js locally, it shows stale content
- If we scroll Tmux remotely, we need to sync viewport position
- No direct way to query Tmux's current scroll position

## Potential Approaches (Need Research)

### Approach A: Fake Larger Terminal Screen
Idea: Configure Tmux/xterm with many more rows than visible, show only bottom portion, let native scroll show upper content.

Questions:
- Can we set terminal to 200 rows but only render 40 visible?
- How does xterm.js handle rendering with scrollback visible?
- Would Tmux alt-screen apps (vim, htop) break this?

### Approach B: Intercept Touch → Send Tmux Commands
Idea: Capture touch velocity, translate to Tmux copy-mode scroll commands, enter/exit copy-mode automatically.

Questions:
- Can we make copy-mode entry/exit seamless and invisible?
- How to handle latency (predictive scrolling? local estimation?)
- What about apps that use mouse tracking (vim, htop)?

### Approach C: Local Buffer Expansion
Idea: Store much more terminal output locally in Rust ring buffer, scroll through local history without touching Tmux.

Questions:
- Can we replay arbitrary positions from ring buffer to xterm.js?
- How to handle terminal state (colors, cursor) at arbitrary scroll positions?
- What about applications that clear screen or use alternate buffer?

### Approach D: Hybrid - Local Cache + Tmux Sync
Idea: Cache recent output locally, allow instant local scroll for cached content, sync with Tmux when scrolling beyond cache.

Questions:
- How to determine cache validity?
- How to handle divergence between local cache and Tmux state?
- What triggers refresh/resync?

### Approach E: Mouse Wheel Event Injection
Idea: Translate touch velocity to synthetic mouse wheel events, send to Tmux.

Questions:
- Does Tmux respond to mouse wheel outside copy-mode? (yes, with mouse mode)
- Can we enable Tmux mouse mode transparently?
- How to handle apps that disable mouse mode?

## Research Questions for GPT-5 Pro

1. **Tmux Internals**: What's the best way to programmatically scroll Tmux and retrieve scrollback content? Can we use `tmux capture-pane` or similar commands?

2. **xterm.js Capabilities**: Can xterm.js be configured to show a "virtual" larger buffer that we populate incrementally? Does it have APIs for injecting historical content at specific scroll positions?

3. **Terminal Protocol**: Are there escape sequences or control codes that allow scrolling viewport without entering copy-mode? ANSI scroll regions?

4. **Mobile UX Patterns**: How do other mobile terminal apps (Termux, iSH, Prompt, Blink) handle touch scrolling with remote connections?

5. **Latency Mitigation**: What techniques exist for making remote scroll feel responsive? (Predictive rendering, optimistic UI, rubber-banding?)

6. **Implementation Recommendation**: Given the architecture, what's the most practical approach that:
   - Works with 50-200ms latency
   - Doesn't break full-screen apps (vim, htop)
   - Provides intuitive finger-drag UX
   - Keeps Tmux as source of truth

## Constraints

- Must work with existing Tmux sessions (can't require special Tmux config)
- Must not break alternate screen buffer apps
- Should handle reconnection gracefully (scroll position preserved or reset)
- Target: ~3 pages of scrollback (enough to see recent command output)
- Acceptable latency for scroll response: < 100ms perceived

## Desired Output

Please provide:
1. Analysis of each approach's feasibility
2. Recommended approach with rationale
3. High-level implementation plan
4. Key technical challenges and solutions
5. Any prior art or reference implementations to study

---

## Attached Code Files

The following files show the current terminal implementation:

### File: packages/react-native-xtermjs-webview/src/index.tsx

React Native component wrapping WebView with xterm.js. Key points:
- `bounces: false` and `overScrollMode: 'never'` disable native scroll
- `scrollback: 10000` configured for xterm.js
- Bridge sends/receives messages via postMessage

### File: packages/react-native-xtermjs-webview/src-internal/main.tsx

xterm.js initialization inside WebView. Key points:
- Terminal created with FitAddon
- Touch handling for selection mode (overlay captures touch events)
- Message handler processes write/resize/fit commands

### File: packages/react-native-xtermjs-webview/src/bridge.ts

Type definitions for WebView ↔ React Native communication:
- `write`, `writeMany` - send terminal data
- `resize`, `fit` - terminal sizing
- Selection mode messages

### File: packages/react-native-uniffi-russh/src/api.ts

SSH connection and shell management:
- `startShell({ useTmux: true, tmuxSessionName })` - creates Tmux session
- `readBuffer({ mode: 'head' })` - replay terminal output from ring buffer
- `addListener()` - stream live terminal data
</file>

<file path="packages/react-native-xtermjs-webview/src/bridge.ts">
import { Base64 } from 'js-base64';
type ITerminalOptions = import('@xterm/xterm').ITerminalOptions;
type ITerminalInitOnlyOptions = import('@xterm/xterm').ITerminalInitOnlyOptions;
// Messages posted from the WebView (xterm page) to React Native
export type BridgeInboundMessage =
	| { type: 'initialized' }
	| { type: 'input'; str: string }
	| { type: 'debug'; message: string }
	| { type: 'sizeChanged'; cols: number; rows: number }
	| { type: 'selection'; requestId: number; text: string }
	| { type: 'selectionChanged'; text: string }
	| { type: 'selectionModeChanged'; enabled: boolean };

// Messages injected from React Native into the WebView (xterm page)
export type BridgeOutboundMessage =
	| { type: 'write'; bStr: string }
	| { type: 'writeMany'; chunks: string[] }
	| { type: 'resize'; cols: number; rows: number }
	| { type: 'fit' }
	| { type: 'getSelection'; requestId: number }
	| { type: 'setSelectionMode'; enabled: boolean }
	| {
			type: 'setOptions';
			opts: Partial<Omit<ITerminalOptions, keyof ITerminalInitOnlyOptions>>;
	  }
	| { type: 'clear' }
	| { type: 'focus' };

export const binaryToBStr = (binary: Uint8Array): string =>
	Base64.fromUint8Array(binary);
export const bStrToBinary = (bStr: string): Uint8Array =>
	Base64.toUint8Array(bStr);
</file>

<file path="packages/react-native-xtermjs-webview/src/index.tsx">
import React, {
	useEffect,
	useImperativeHandle,
	useMemo,
	useRef,
	useCallback,
	useState,
} from 'react';
import { WebView, type WebViewMessageEvent } from 'react-native-webview';
import htmlString from '../dist-internal/index.html?raw';

// React Native global for development mode detection
declare const __DEV__: boolean | undefined;
import {
	binaryToBStr,
	bStrToBinary,
	type BridgeInboundMessage,
	type BridgeOutboundMessage,
} from './bridge';
import { jetBrainsMonoTtfBase64 } from './jetbrains-mono';

export { bStrToBinary, binaryToBStr };

let didLogHtmlFingerprint = false;
if (__DEV__ && !didLogHtmlFingerprint) {
	didLogHtmlFingerprint = true;
	try {
		console.log(
			`[xtermjs-webview] htmlString includes light blue lollipop: ${htmlString.includes(
				'#60a5fa',
			)}`,
		);
	} catch {}
}

type StrictOmit<T, K extends keyof T> = Omit<T, K>;
type ITerminalOptions = import('@xterm/xterm').ITerminalOptions;
type WebViewOptions = React.ComponentProps<typeof WebView>;

const defaultCoalescingThreshold = 8 * 1024;
const jetBrainsMonoStyleId = 'fressh-jetbrains-mono';
const jetBrainsMonoFontCss = `
@font-face {
	font-family: 'JetBrains Mono';
	src: url(data:font/ttf;base64,${jetBrainsMonoTtfBase64}) format('truetype');
	font-weight: 400;
	font-style: normal;
	font-display: swap;
}
`;

/**
 * Message from this pkg to calling RN
 */
export type XtermInbound =
	| { type: 'initialized' }
	| { type: 'data'; data: Uint8Array }
	| { type: 'debug'; message: string }
	| { type: 'selectionChanged'; text: string }
	| { type: 'selectionModeChanged'; enabled: boolean };

export type XtermWebViewHandle = {
	write: (data: Uint8Array) => void; // bytes in (batched)
	// Efficiently write many chunks in one postMessage (for initial replay)
	writeMany: (chunks: Uint8Array[]) => void;
	flush: () => void; // force-flush outgoing writes
	clear: () => void;
	focus: () => void;
	setSystemKeyboardEnabled: (enabled: boolean) => void;
	setSelectionModeEnabled: (enabled: boolean) => void;
	getSelection: () => Promise<string>;
	resize: (size: { cols: number; rows: number }) => void;
	fit: () => void;
};

const defaultWebViewProps: WebViewOptions = {
	// WebView behavior that suits terminals
	// ios
	keyboardDisplayRequiresUserAction: false,
	pullToRefreshEnabled: false,
	bounces: false,
	textInteractionEnabled: false,
	allowsLinkPreview: false,
	// android
	setSupportMultipleWindows: false,
	overScrollMode: 'never',
	setBuiltInZoomControls: false,
	setDisplayZoomControls: false,
	textZoom: 100,
	// both
	originWhitelist: ['*'],
	scalesPageToFit: false,
	contentMode: 'mobile',
};

const defaultXtermOptions: Partial<ITerminalOptions> = {
	allowProposedApi: true,
	convertEol: true,
	scrollback: 10000,
	cursorBlink: true,
	// Tablet focus-mode defaults (JetBrains Mono preferred).
	// Note: WebView must have the font available or it will fall back.
	fontFamily:
		'"JetBrains Mono", "Roboto Mono", ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", monospace',
	fontSize: 16,
};

type UserControllableWebViewProps = StrictOmit<
	WebViewOptions,
	'source' | 'style' | 'injectedJavaScriptBeforeContentLoaded'
>;

export type XtermJsWebViewProps = {
	ref: React.RefObject<XtermWebViewHandle | null>;
	style?: WebViewOptions['style'];
	webViewOptions?: UserControllableWebViewProps;
	xtermOptions?: Partial<ITerminalOptions>;
	/** Dev-only override for loading the internal WebView HTML via a Vite dev server. */
	devServerUrl?: string;
	onInitialized?: () => void;
	onData?: (data: string) => void;
	onSelection?: (text: string) => void;
	onSelectionModeChange?: (enabled: boolean) => void;
	/** Called when terminal size changes (cols/rows). Use for PTY resize. */
	onResize?: (cols: number, rows: number) => void;
	logger?: {
		debug?: (...args: unknown[]) => void;
		log?: (...args: unknown[]) => void;
		warn?: (...args: unknown[]) => void;
		error?: (...args: unknown[]) => void;
	};
	coalescingThreshold?: number;
	size?: {
		cols: number;
		rows: number;
	};
	autoFit?: boolean;
};

function xTermOptionsEquals(
	a: Partial<ITerminalOptions> | null,
	b: Partial<ITerminalOptions> | null,
): boolean {
	if (a == b) return true;
	if (a == null && b == null) return true;
	if (a == null || b == null) return false;
	const keys = new Set<string>([
		...Object.keys(a as object),
		...Object.keys(b as object),
	]);
	for (const k of keys) {
		const key = k as keyof ITerminalOptions;
		if (a[key] !== b[key]) return false;
	}
	return true;
}

export function XtermJsWebView({
	ref,
	style,
	webViewOptions = defaultWebViewProps,
	xtermOptions = defaultXtermOptions,
	onInitialized,
	onData,
	onSelection,
	onSelectionModeChange,
	onResize,
	coalescingThreshold = defaultCoalescingThreshold,
	logger,
	size,
	autoFit = true,
	devServerUrl,
}: XtermJsWebViewProps) {
	const webRef = useRef<WebView>(null);
	const [initialized, setInitialized] = useState(false);
	const selectionRequestIdRef = useRef(0);
	const pendingSelectionRef = useRef(
		new Map<number, { resolve: (value: string) => void }>(),
	);

	// ---- RN -> WebView message sender
	const sendToWebView = useCallback(
		(obj: BridgeOutboundMessage) => {
			const webViewRef = webRef.current;
			if (!webViewRef) return;
			const payload = JSON.stringify(obj);
			logger?.debug?.(`sending msg to webview: ${payload}`);
			const js = `window.dispatchEvent(new MessageEvent('message',{data:${payload}})); true;`;
			webViewRef.injectJavaScript(js);
		},
		[logger],
	);

	// ---- rAF + 8KB coalescer for writes
	const bufRef = useRef<Uint8Array | null>(null);
	const rafRef = useRef<number | null>(null);

	const flush = useCallback(() => {
		if (!bufRef.current) return;
		const bStr = binaryToBStr(bufRef.current);
		bufRef.current = null;
		if (rafRef.current != null) {
			cancelAnimationFrame(rafRef.current);
			rafRef.current = null;
		}
		sendToWebView({ type: 'write', bStr });
	}, [sendToWebView]);

	const schedule = useCallback(() => {
		if (rafRef.current != null) return;
		rafRef.current = requestAnimationFrame(() => {
			rafRef.current = null;
			flush();
		});
	}, [flush]);

	const write = useCallback(
		(data: Uint8Array) => {
			if (!data || data.length === 0) return;
			if (!bufRef.current) {
				bufRef.current = data;
			} else {
				const a = bufRef.current;
				const merged = new Uint8Array(a.length + data.length);
				merged.set(a, 0);
				merged.set(data, a.length);
				bufRef.current = merged;
			}
			if ((bufRef.current?.length ?? 0) >= coalescingThreshold) flush();
			else schedule();
		},
		[coalescingThreshold, flush, schedule],
	);

	const writeMany = useCallback(
		(chunks: Uint8Array[]) => {
			if (!chunks || chunks.length === 0) return;
			flush(); // Ensure any pending small buffered write is flushed before bulk write
			const bStrs = chunks.map(binaryToBStr);
			sendToWebView({ type: 'writeMany', chunks: bStrs });
		},
		[flush, sendToWebView],
	);

	// Cleanup pending rAF on unmount
	useEffect(() => {
		const pendingSelectionMap = pendingSelectionRef.current;
		return () => {
			if (rafRef.current != null) cancelAnimationFrame(rafRef.current);
			rafRef.current = null;
			bufRef.current = null;
			pendingSelectionMap.clear();
		};
	}, []);

	const fit = useCallback(() => {
		sendToWebView({ type: 'fit' });
	}, [sendToWebView]);

	const setSystemKeyboardEnabled = useCallback((enabled: boolean) => {
		const webViewRef = webRef.current;
		if (!webViewRef) return;
		const js = `
(() => {
	const ta = document.querySelector('.xterm-helper-textarea');
	if (!ta) return true;
	ta.setAttribute('inputmode', ${enabled ? "'verbatim'" : "'none'"});
	ta.tabIndex = ${enabled ? 0 : -1};
	if (${enabled ? 'true' : 'false'}) {
		ta.removeAttribute('readonly');
		ta.focus();
	} else {
		ta.setAttribute('readonly', 'true');
		ta.blur();
	}
	return true;
})();`;
		webViewRef.injectJavaScript(js);
		if (enabled) {
			webViewRef.requestFocus();
		}
	}, []);

	const getSelection = useCallback((): Promise<string> => {
		if (!initialized) return Promise.resolve('');
		const requestId = selectionRequestIdRef.current + 1;
		selectionRequestIdRef.current = requestId;
		return new Promise((resolve) => {
			pendingSelectionRef.current.set(requestId, { resolve });
			sendToWebView({ type: 'getSelection', requestId });
			// Timeout after 5s to prevent hanging if WebView is unresponsive
			setTimeout(() => {
				if (pendingSelectionRef.current.has(requestId)) {
					pendingSelectionRef.current.delete(requestId);
					resolve('');
				}
			}, 5000);
		});
	}, [initialized, sendToWebView]);

	const setSelectionModeEnabled = useCallback(
		(enabled: boolean) => {
			sendToWebView({ type: 'setSelectionMode', enabled });
		},
		[sendToWebView],
	);

	const autoFitFn = useCallback(() => {
		if (!autoFit) return;
		fit();
	}, [autoFit, fit]);

	const appliedSizeRef = useRef<{ cols: number; rows: number } | null>(null);

	useEffect(() => {
		if (!initialized) return;
		const appliedSize = appliedSizeRef.current;
		if (!size) return;
		if (appliedSize?.cols === size.cols && appliedSize?.rows === size.rows)
			return;

		logger?.log?.(`calling resize`, size);
		sendToWebView({ type: 'resize', cols: size.cols, rows: size.rows });
		autoFitFn();

		appliedSizeRef.current = size;
	}, [size, sendToWebView, logger, autoFitFn, initialized]);

	useImperativeHandle(ref, () => ({
		write,
		writeMany,
		flush,
		clear: () => sendToWebView({ type: 'clear' }),
		focus: () => {
			sendToWebView({ type: 'focus' });
			webRef.current?.requestFocus();
		},
		setSystemKeyboardEnabled,
		setSelectionModeEnabled,
		getSelection,
		resize: (size: { cols: number; rows: number }) => {
			sendToWebView({ type: 'resize', cols: size.cols, rows: size.rows });
			autoFitFn();
			appliedSizeRef.current = size;
		},
		fit,
	}));

	const mergedXTermOptions = useMemo(
		() => ({
			...defaultXtermOptions,
			...xtermOptions,
		}),
		[xtermOptions],
	);

	const appliedXtermOptionsRef = useRef<Partial<ITerminalOptions> | null>(null);

	useEffect(() => {
		if (!initialized) return;
		const appliedXtermOptions = appliedXtermOptionsRef.current;
		if (xTermOptionsEquals(appliedXtermOptions, mergedXTermOptions)) return;
		logger?.log?.(`setting options: `, mergedXTermOptions);
		sendToWebView({ type: 'setOptions', opts: mergedXTermOptions });
		autoFitFn();

		appliedXtermOptionsRef.current = mergedXTermOptions;
	}, [mergedXTermOptions, sendToWebView, logger, initialized, autoFitFn]);

	const onMessage = useCallback(
		(e: WebViewMessageEvent) => {
			try {
				const msg: BridgeInboundMessage = JSON.parse(e.nativeEvent.data);
				logger?.log?.(`received msg from webview: `, msg);
				if (msg.type === 'initialized') {
					onInitialized?.();
					autoFitFn();
					setInitialized(true);
					return;
				}
				if (msg.type === 'input') {
					// const bytes = bStrToBinary(msg.bStr);
					// onData?.(bytes);
					onData?.(msg.str);
					return;
				}
				if (msg.type === 'debug') {
					logger?.log?.(`received debug msg from webview: `, msg.message);
					return;
				}
				if (msg.type === 'sizeChanged') {
					logger?.log?.(`terminal size changed: ${msg.cols}x${msg.rows}`);
					onResize?.(msg.cols, msg.rows);
					return;
				}
				if (msg.type === 'selection') {
					const pending = pendingSelectionRef.current.get(msg.requestId);
					if (pending) {
						pendingSelectionRef.current.delete(msg.requestId);
						pending.resolve(msg.text);
					}
					return;
				}
				if (msg.type === 'selectionChanged') {
					onSelection?.(msg.text);
					return;
				}
				if (msg.type === 'selectionModeChanged') {
					onSelectionModeChange?.(msg.enabled);
					return;
				}
				webViewOptions?.onMessage?.(e);
			} catch (error) {
				logger?.warn?.(
					`received unknown msg from webview: `,
					e.nativeEvent.data,
					error,
				);
			}
		},
		[
			logger,
			webViewOptions,
			onInitialized,
			autoFitFn,
			onData,
			onResize,
			onSelection,
			onSelectionModeChange,
		],
	);

	const onContentProcessDidTerminate = useCallback<
		NonNullable<WebViewOptions['onContentProcessDidTerminate']>
	>(
		(e) => {
			logger?.warn?.('WebView Crashed on iOS! onContentProcessDidTerminate');
			webViewOptions?.onContentProcessDidTerminate?.(e);
		},
		[logger, webViewOptions],
	);

	const onRenderProcessGone = useCallback<
		NonNullable<WebViewOptions['onRenderProcessGone']>
	>(
		(e) => {
			logger?.warn?.('WebView Crashed on Android! onRenderProcessGone');
			webViewOptions?.onRenderProcessGone?.(e);
		},
		[logger, webViewOptions],
	);

	const onLoadEnd = useCallback<NonNullable<WebViewOptions['onLoadEnd']>>(
		(e) => {
			logger?.log?.('WebView onLoadEnd');
			webViewOptions?.onLoadEnd?.(e);
		},
		[logger, webViewOptions],
	);

	const mergedWebViewOptions = useMemo(
		() => ({
			...defaultWebViewProps,
			...webViewOptions,
			onContentProcessDidTerminate,
			onRenderProcessGone,
			onLoadEnd,
		}),
		[
			webViewOptions,
			onContentProcessDidTerminate,
			onRenderProcessGone,
			onLoadEnd,
		],
	);

	// Inject JetBrains Mono into the WebView document so xterm can use it reliably,
	// and set the background early to avoid white flashes.
	const injectedJavaScriptBeforeContentLoaded = useMemo(() => {
		const backgroundScript = mergedXTermOptions.theme?.background
			? `document.body.style.backgroundColor = '${mergedXTermOptions.theme.background}';`
			: '';
		const optionsScript = `window.__FRESSH_XTERM_OPTIONS__ = ${JSON.stringify(
			mergedXTermOptions,
		)};`;

		return `
			(function () {
				var styleId = '${jetBrainsMonoStyleId}';
				if (!document.getElementById(styleId)) {
					var style = document.createElement('style');
					style.id = styleId;
					style.type = 'text/css';
					style.textContent = ${JSON.stringify(jetBrainsMonoFontCss)};
					(document.head || document.documentElement).appendChild(style);
				}
				${optionsScript}
				${backgroundScript}
			})();
			true;
		`;
	}, [mergedXTermOptions]);

	const webViewSource = useMemo(() => {
		if (__DEV__ && devServerUrl) {
			const normalized =
				devServerUrl.startsWith('http://') ||
				devServerUrl.startsWith('https://')
					? devServerUrl
					: `http://${devServerUrl}`;
			return { uri: normalized };
		}
		return { html: htmlString };
	}, [devServerUrl, htmlString]);

	return (
		<WebView
			ref={webRef}
			source={webViewSource}
			onMessage={onMessage}
			style={style}
			injectedJavaScriptObject={mergedXTermOptions}
			injectedJavaScriptBeforeContentLoaded={
				injectedJavaScriptBeforeContentLoaded
			}
			{...mergedWebViewOptions}
		/>
	);
}
</file>

<file path="apps/mobile/src/app/shell/detail.tsx">
import { type ListenerEvent } from '@fressh/react-native-uniffi-russh';
import {
	XtermJsWebView,
	type XtermWebViewHandle,
} from '@fressh/react-native-xtermjs-webview';

import * as Clipboard from 'expo-clipboard';
import * as Linking from 'expo-linking';
import {
	Stack,
	useLocalSearchParams,
	useRouter,
	useFocusEffect,
} from 'expo-router';
import * as LucideIcons from 'lucide-react-native';
import React, {
	startTransition,
	useCallback,
	useEffect,
	useMemo,
	useRef,
	useState,
} from 'react';
import {
	Alert,
	Animated,
	AppState,
	Keyboard,
	KeyboardAvoidingView,
	Modal,
	Platform,
	Pressable,
	ScrollView,
	Text,
	TextInput,
	View,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import {
	ACTIVE_KEYBOARD_IDS,
	DEFAULT_KEYBOARD_ID,
	KEYBOARDS_BY_ID,
	MACROS_BY_KEYBOARD_ID,
	type KeyboardDefinition,
	type KeyboardSlot,
	type MacroDef,
	type ModifierKey,
} from '@/generated/keyboard-config';
import { useAutoConnectStore } from '@/lib/auto-connect';
import {
	commandPresets,
	type CommandPreset,
	type CommandStep,
} from '@/lib/command-presets';
import { getStoredConnectionId } from '@/lib/connection-utils';
import {
	CONFIGURATOR_URL,
	HANDLE_DEV_SERVER_URL,
	runAction,
	type ActionContext,
	type ActionId,
} from '@/lib/keyboard-actions';
import { runMacro } from '@/lib/keyboard-runtime';
import { rootLogger } from '@/lib/logger';
import { useSshStore } from '@/lib/ssh-store';
import { useTheme } from '@/lib/theme';

const logger = rootLogger.extend('TabsShellDetail');

export default function TabsShellDetail() {
	const [ready, setReady] = useState(false);

	useFocusEffect(
		React.useCallback(() => {
			startTransition(() => {
				setTimeout(() => {
					// TODO: This is gross. It would be much better to switch
					// after the navigation animation completes.
					setReady(true);
				}, 16);
			});

			return () => {
				setReady(false);
			};
		}, []),
	);

	if (!ready) return <RouteSkeleton />;
	return <ShellDetail />;
}

function RouteSkeleton() {
	const theme = useTheme();
	return (
		<View
			style={{
				flex: 1,
				justifyContent: 'center',
				alignItems: 'center',
				backgroundColor: theme.colors.background,
			}}
		>
			<Text style={{ color: theme.colors.textPrimary, fontSize: 20 }}>
				Loading
			</Text>
		</View>
	);
}

type TmuxAttachErrorScreenProps = {
	sessionName: string;
	onEdit: () => void;
};

function TmuxAttachErrorScreen({
	sessionName,
	onEdit,
}: TmuxAttachErrorScreenProps) {
	const theme = useTheme();
	return (
		<View
			style={{
				flex: 1,
				justifyContent: 'center',
				alignItems: 'center',
				backgroundColor: theme.colors.background,
				padding: 24,
			}}
		>
			<Text
				style={{
					color: theme.colors.textPrimary,
					fontSize: 20,
					fontWeight: '700',
					marginBottom: 12,
					textAlign: 'center',
				}}
			>
				Tmux session not found
			</Text>
			<Text
				style={{
					color: theme.colors.textSecondary,
					fontSize: 14,
					textAlign: 'center',
					marginBottom: 20,
				}}
			>
				We could not attach to tmux session "{sessionName}". Create it
				on the server and try again.
			</Text>
			<Pressable
				onPress={onEdit}
				style={{
					backgroundColor: theme.colors.primary,
					borderRadius: 10,
					paddingVertical: 12,
					paddingHorizontal: 20,
				}}
			>
				<Text style={{ color: '#fff', fontWeight: '700' }}>
					Edit Connection
				</Text>
			</Pressable>
		</View>
	);
}

type TerminalErrorBoundaryProps = {
	children: React.ReactNode;
	onRetry: () => void;
};

type TerminalErrorBoundaryState = {
	hasError: boolean;
};

class TerminalErrorBoundary extends React.Component<
	TerminalErrorBoundaryProps,
	TerminalErrorBoundaryState
> {
	constructor(props: TerminalErrorBoundaryProps) {
		super(props);
		this.state = { hasError: false };
	}

	static getDerivedStateFromError(): TerminalErrorBoundaryState {
		return { hasError: true };
	}

	override componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
		logger.error('Terminal crashed', error, errorInfo);
	}

	handleRetry = () => {
		this.setState({ hasError: false });
		this.props.onRetry();
	};

	override render() {
		if (this.state.hasError) {
			return <TerminalErrorFallback onRetry={this.handleRetry} />;
		}
		return this.props.children;
	}
}

function TerminalErrorFallback({ onRetry }: { onRetry: () => void }) {
	const theme = useTheme();
	return (
		<View
			style={{
				flex: 1,
				justifyContent: 'center',
				alignItems: 'center',
				backgroundColor: theme.colors.background,
				padding: 20,
			}}
		>
			<Text
				style={{
					color: theme.colors.textPrimary,
					fontSize: 18,
					marginBottom: 12,
				}}
			>
				Terminal crashed
			</Text>
			<Pressable
				onPress={onRetry}
				style={{
					paddingHorizontal: 20,
					paddingVertical: 10,
					borderRadius: 8,
					backgroundColor: theme.colors.primary,
				}}
			>
				<Text style={{ color: '#fff', fontSize: 16 }}>Tap to retry</Text>
			</Pressable>
		</View>
	);
}

const encoder = new TextEncoder();
const ALL_KEYBOARD_IDS = Object.keys(KEYBOARDS_BY_ID);
const ACTIVE_KEYBOARD_IDS_FALLBACK: readonly string[] =
	ACTIVE_KEYBOARD_IDS.length > 0 ? ACTIVE_KEYBOARD_IDS : ALL_KEYBOARD_IDS;
const DEFAULT_KEYBOARD_ID_FALLBACK =
	DEFAULT_KEYBOARD_ID || ACTIVE_KEYBOARD_IDS_FALLBACK[0] || '';

function ShellDetail() {
	const xtermRef = useRef<XtermWebViewHandle>(null);
	const listenerIdRef = useRef<bigint | null>(null);

	const searchParams = useLocalSearchParams<{
		connectionId?: string;
		channelId?: string;
		tmuxError?: string;
		tmuxSessionName?: string;
		storedConnectionId?: string;
	}>();

	const connectionId = searchParams.connectionId;
	const channelId = parseInt(searchParams.channelId ?? '');

	if (!connectionId || isNaN(channelId))
		throw new Error('Missing or invalid connectionId/channelId');
	const hasTmuxAttachError = searchParams.tmuxError === 'attach-failed';
	const tmuxSessionName = searchParams.tmuxSessionName;

	const router = useRouter();
	const theme = useTheme();
	const insets = useSafeAreaInsets();

	const shell = useSshStore(
		(s) => s.shells[`${connectionId}-${channelId}` as const],
	);
	const connection = useSshStore((s) => s.connections[connectionId]);
	const storedConnectionId =
		searchParams.storedConnectionId ??
		(connection
			? getStoredConnectionId(connection.connectionDetails)
			: undefined);
	const isAutoConnecting = useAutoConnectStore((s) => s.isAutoConnecting);
	const isReconnecting = useAutoConnectStore((s) => s.isReconnecting);

	useEffect(() => {
		if (hasTmuxAttachError) return;
		if (shell && connection) return;
		const autoState = useAutoConnectStore.getState();
		if (autoState.isAutoConnecting || autoState.isReconnecting) return;
		logger.info('shell or connection not found, replacing route with /shell');
		router.back();
	}, [
		connection,
		hasTmuxAttachError,
		isAutoConnecting,
		isReconnecting,
		router,
		shell,
	]);

	useEffect(() => {
		const xterm = xtermRef.current;
		return () => {
			if (shell && listenerIdRef.current != null)
				shell.removeListener(listenerIdRef.current);
			listenerIdRef.current = null;
			if (xterm) xterm.flush();
		};
	}, [shell]);

	useEffect(() => {
		return () => {
			commandTimeoutsRef.current.forEach((timeout) => {
				clearTimeout(timeout);
			});
			commandTimeoutsRef.current = [];
		};
	}, []);

	const [selectedKeyboardId, setSelectedKeyboardId] = useState<string>(
		DEFAULT_KEYBOARD_ID_FALLBACK,
	);
	const availableKeyboardIds = useMemo(() => new Set(ALL_KEYBOARD_IDS), []);

	const currentKeyboard = useMemo<KeyboardDefinition | null>(() => {
		if (selectedKeyboardId && KEYBOARDS_BY_ID[selectedKeyboardId]) {
			return KEYBOARDS_BY_ID[selectedKeyboardId];
		}
		if (
			DEFAULT_KEYBOARD_ID_FALLBACK &&
			KEYBOARDS_BY_ID[DEFAULT_KEYBOARD_ID_FALLBACK]
		) {
			return KEYBOARDS_BY_ID[DEFAULT_KEYBOARD_ID_FALLBACK];
		}
		const fallbackId = ACTIVE_KEYBOARD_IDS_FALLBACK[0];
		return fallbackId ? (KEYBOARDS_BY_ID[fallbackId] ?? null) : null;
	}, [selectedKeyboardId]);

	const currentMacros = useMemo<MacroDef[]>(
		() =>
			currentKeyboard ? (MACROS_BY_KEYBOARD_ID[currentKeyboard.id] ?? []) : [],
		[currentKeyboard],
	);

	// Flash message for keyboard switching
	const [flashKeyboardName, setFlashKeyboardName] = useState<string | null>(
		null,
	);
	const flashOpacity = useRef(new Animated.Value(0)).current;
	const isFirstMount = useRef(true);

	useEffect(() => {
		// Skip the flash on first mount
		if (isFirstMount.current) {
			isFirstMount.current = false;
			return;
		}

		if (!currentKeyboard) return;

		// eslint-disable-next-line @eslint-react/hooks-extra/no-direct-set-state-in-use-effect -- Animation state requires direct set in effect
		setFlashKeyboardName(currentKeyboard.name);
		flashOpacity.setValue(1);

		const animation = Animated.timing(flashOpacity, {
			toValue: 0,
			duration: 800,
			delay: 400,
			useNativeDriver: true,
		});

		animation.start(({ finished }) => {
			if (finished) {
				setFlashKeyboardName(null);
			}
		});

		return () => {
			animation.stop();
		};
	}, [currentKeyboard, flashOpacity]);

	const [modifierKeysActive, setModifierKeysActive] = useState<ModifierKey[]>(
		[],
	);
	const [systemKeyboardEnabled, setSystemKeyboardEnabled] = useState(false);
	const [selectionModeEnabled, setSelectionModeEnabled] = useState(false);
	const [commandPresetsOpen, setCommandPresetsOpen] = useState(false);
	const [commanderOpen, setCommanderOpen] = useState(false);
	const commandTimeoutsRef = useRef<ReturnType<typeof setTimeout>[]>([]);
	const lastSelectionRef = useRef<{ text: string; at: number } | null>(null);

	const exitSelectionMode = useCallback(() => {
		setSelectionModeEnabled(false);
		xtermRef.current?.setSelectionModeEnabled(false);
	}, []);

	const sendBytesRaw = useCallback(
		(bytes: Uint8Array<ArrayBuffer>) => {
			if (!shell) return;
			shell.sendData(bytes.buffer).catch((e: unknown) => {
				logger.warn('sendData failed', e);
				router.back();
			});
		},
		[shell, router],
	);

	const sendBytesWithModifiers = useCallback(
		(bytes: Uint8Array<ArrayBuffer>) => {
			if (!shell) return;
			let next = bytes;
			modifierKeysActive
				.map((key) => MODIFIER_DEFS[key])
				.sort((a, b) => a.orderPreference - b.orderPreference)
				.forEach((modifier) => {
					if (!modifier.canApplyModifierToBytes(next)) return;
					next = modifier.applyModifierToBytes(next);
				});
			sendBytesRaw(next);
		},
		[modifierKeysActive, sendBytesRaw, shell],
	);

	const sendTextRaw = useCallback(
		(value: string) => {
			sendBytesRaw(encoder.encode(value));
		},
		[sendBytesRaw],
	);

	const sendTextWithModifiers = useCallback(
		(value: string) => {
			sendBytesWithModifiers(encoder.encode(value));
		},
		[sendBytesWithModifiers],
	);

	const clearCommandTimeouts = useCallback(() => {
		commandTimeoutsRef.current.forEach((timeout) => {
			clearTimeout(timeout);
		});
		commandTimeoutsRef.current = [];
	}, []);

	const sendCommandStep = useCallback(
		(step: CommandStep) => {
			const times = step.repeat ?? 1;
			for (let i = 0; i < times; i += 1) {
				switch (step.type) {
					case 'text':
						sendTextRaw(step.data);
						break;
					case 'enter':
						sendBytesRaw(encoder.encode('\r'));
						break;
					case 'arrowDown':
						sendBytesRaw(encoder.encode('\x1b[B'));
						break;
					case 'arrowUp':
						sendBytesRaw(encoder.encode('\x1b[A'));
						break;
					case 'esc':
						sendBytesRaw(encoder.encode('\x1b'));
						break;
					case 'space':
						sendBytesRaw(encoder.encode(' '));
						break;
					case 'tab':
						sendBytesRaw(encoder.encode('\t'));
						break;
					default:
						break;
				}
			}
		},
		[sendBytesRaw, sendTextRaw],
	);

	const runCommandPreset = useCallback(
		(preset: CommandPreset) => {
			exitSelectionMode();
			clearCommandTimeouts();
			let delay = 0;
			const baseDelay = 50;
			preset.steps.forEach((step) => {
				const stepDelay = step.delayMs ?? baseDelay;
				const timeoutId = setTimeout(() => {
					sendCommandStep(step);
				}, delay);
				commandTimeoutsRef.current.push(timeoutId);
				delay += stepDelay * (step.repeat ?? 1);
			});
			setCommandPresetsOpen(false);
		},
		[clearCommandTimeouts, exitSelectionMode, sendCommandStep],
	);

	const toggleModifier = useCallback((modifier: ModifierKey) => {
		setModifierKeysActive((prev) =>
			prev.includes(modifier)
				? prev.filter((entry) => entry !== modifier)
				: [...prev, modifier],
		);
	}, []);

	const rotateKeyboard = useCallback(() => {
		if (ACTIVE_KEYBOARD_IDS_FALLBACK.length <= 1) return;
		setSelectedKeyboardId((current) => {
			const idx = Math.max(0, ACTIVE_KEYBOARD_IDS_FALLBACK.indexOf(current));
			const nextIdx = (idx + 1) % ACTIVE_KEYBOARD_IDS_FALLBACK.length;
			return ACTIVE_KEYBOARD_IDS_FALLBACK[nextIdx] ?? current;
		});
	}, []);

	const selectKeyboardIfExists = useCallback(
		(id: string) => {
			if (!availableKeyboardIds.has(id)) return;
			setSelectedKeyboardId(id);
		},
		[availableKeyboardIds],
	);

	const handlePasteClipboard = useCallback(async () => {
		try {
			const text = await Clipboard.getStringAsync();
			if (text) sendTextRaw(text);
			if (selectionModeEnabled) {
				exitSelectionMode();
			}
		} catch (error) {
			logger.warn('clipboard read failed', error);
		}
	}, [exitSelectionMode, sendTextRaw, selectionModeEnabled]);

	const handleCopySelection = useCallback(() => {
		const xr = xtermRef.current;
		if (!xr) return;
		void (async () => {
			const selection = await xr.getSelection();
			if (!selection) {
				logger.info('no selection to copy');
				return;
			}
			lastSelectionRef.current = { text: selection, at: Date.now() };
			await Clipboard.setStringAsync(selection);
			logger.info('copied selection', selection.length);
			exitSelectionMode();
		})();
	}, [exitSelectionMode]);

	const handleSelectionChanged = useCallback((text: string) => {
		if (!text) return;
		const now = Date.now();
		if (lastSelectionRef.current?.text === text) return;
		lastSelectionRef.current = { text, at: now };
	}, []);

	const openConfigDialog = useCallback(() => {
		const editConnectionId = storedConnectionId ?? connectionId;
		Alert.alert(
			'Configure',
			'Choose where to go',
			[
				{
					text: 'Keyboard config',
					onPress: () => {
						void Linking.openURL(CONFIGURATOR_URL);
					},
				},
				{
					text: 'Handle dev server',
					onPress: () => {
						void Linking.openURL(HANDLE_DEV_SERVER_URL);
					},
				},
				{
					text: 'Host config',
					onPress: () => {
						router.replace({
							pathname: '/',
							params: { editConnectionId },
						});
					},
				},
				{ text: 'Cancel', style: 'cancel' },
			],
			{ cancelable: true },
		);
	}, [connectionId, router, storedConnectionId]);

	const actionContext = useMemo<ActionContext>(
		() => ({
			availableKeyboardIds,
			selectKeyboard: selectKeyboardIfExists,
			rotateKeyboard,
			openConfigurator: openConfigDialog,
			sendBytes: sendBytesRaw,
			pasteClipboard: handlePasteClipboard,
			copySelection: handleCopySelection,
			toggleCommandPresets: () => {
				setCommanderOpen(false);
				setCommandPresetsOpen((prev) => !prev);
			},
			openCommander: () => {
				setCommandPresetsOpen(false);
				setCommanderOpen(true);
			},
		}),
		[
			availableKeyboardIds,
			handleCopySelection,
			handlePasteClipboard,
			openConfigDialog,
			rotateKeyboard,
			selectKeyboardIfExists,
			sendBytesRaw,
		],
	);

	const handleAction = useCallback(
		(actionId: ActionId) => {
			void runAction(actionId, actionContext);
		},
		[actionContext],
	);

	const handleSlotPress = useCallback(
		(slot: KeyboardSlot) => {
			if (
				selectionModeEnabled &&
				!(slot.type === 'action' && slot.actionId === 'COPY_SELECTION')
			) {
				// Any input/command should exit selection first, except explicit copy.
				exitSelectionMode();
			}
			if (slot.type === 'modifier') {
				toggleModifier(slot.modifier);
				return;
			}
			if (slot.type === 'text') {
				sendTextWithModifiers(slot.text);
				return;
			}
			if (slot.type === 'bytes') {
				sendBytesWithModifiers(new Uint8Array(slot.bytes));
				return;
			}
			if (slot.type === 'macro') {
				const macro = currentMacros.find((entry) => entry.id === slot.macroId);
				if (!macro) return;
				runMacro(macro, {
					sendBytes: sendBytesRaw,
					sendText: sendTextRaw,
					onAction: handleAction,
				});
				return;
			}
			if (slot.type === 'action') {
				handleAction(slot.actionId);
				return;
			}
		},
		[
			currentMacros,
			exitSelectionMode,
			handleAction,
			sendBytesRaw,
			sendBytesWithModifiers,
			sendTextRaw,
			sendTextWithModifiers,
			selectionModeEnabled,
			toggleModifier,
		],
	);

	// Debounced PTY resize handler
	const resizeTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
	const lastSizeRef = useRef<{ cols: number; rows: number } | null>(null);

	const handleTerminalResize = useCallback(
		(cols: number, rows: number) => {
			// Skip if same size
			if (
				lastSizeRef.current?.cols === cols &&
				lastSizeRef.current?.rows === rows
			) {
				return;
			}
			lastSizeRef.current = { cols, rows };

			// Clear pending resize
			if (resizeTimeoutRef.current) {
				clearTimeout(resizeTimeoutRef.current);
			}

			// Debounce resize calls (100ms)
			resizeTimeoutRef.current = setTimeout(() => {
				if (!shell) return;
				logger.info(`Resizing PTY to ${cols}x${rows}`);
				shell.resizePty(cols, rows).catch((e: unknown) => {
					logger.warn('resizePty failed', e);
				});
			}, 100);
		},
		[shell],
	);

	// Cleanup resize timeout on unmount
	useEffect(() => {
		return () => {
			if (resizeTimeoutRef.current) {
				clearTimeout(resizeTimeoutRef.current);
			}
		};
	}, []);

	useEffect(() => {
		if (Platform.OS !== 'android') return;
		const dismissKeyboard = () => Keyboard.dismiss();
		dismissKeyboard();
		if (!systemKeyboardEnabled) {
			xtermRef.current?.setSystemKeyboardEnabled(false);
		}
		// eslint-disable-next-line @eslint-react/web-api/no-leaked-event-listener -- React Native AppState cleans up via subscription.remove()
		const subscription = AppState.addEventListener('change', (nextState) => {
			if (nextState === 'active') {
				if (!systemKeyboardEnabled) {
					xtermRef.current?.setSystemKeyboardEnabled(false);
					dismissKeyboard();
				}
			}
		});
		return () => {
			subscription.remove();
		};
	}, [systemKeyboardEnabled]);

	const disableSystemKeyboard = useCallback(() => {
		if (Platform.OS !== 'android') return;
		xtermRef.current?.setSystemKeyboardEnabled(false);
		Keyboard.dismiss();
		setSystemKeyboardEnabled(false);
	}, []);

	const toggleSystemKeyboard = useCallback(() => {
		if (Platform.OS !== 'android') return;
		const next = !systemKeyboardEnabled;
		setSystemKeyboardEnabled(next);
		xtermRef.current?.setSystemKeyboardEnabled(next);
		if (next) {
			exitSelectionMode();
			// Defer focus until after the button press releases.
			setTimeout(() => {
				xtermRef.current?.focus();
			}, 0);
		} else {
			Keyboard.dismiss();
		}
	}, [exitSelectionMode, systemKeyboardEnabled]);

	const handleSelectionModeChange = useCallback(
		(enabled: boolean) => {
			setSelectionModeEnabled(enabled);
			if (enabled) disableSystemKeyboard();
		},
		[disableSystemKeyboard],
	);

	const handleTerminalCrashRetry = useCallback(() => {
		// Navigate back to trigger auto-reconnect flow
		router.back();
	}, [router]);

	if (hasTmuxAttachError) {
		return (
			<TmuxAttachErrorScreen
				sessionName={tmuxSessionName ?? 'main'}
				onEdit={() => {
					router.replace({
						pathname: '/',
						params: { editConnectionId: storedConnectionId ?? connectionId },
					});
				}}
			/>
		);
	}

	const shouldRenderTerminal = Boolean(shell && connection);
	if (!shouldRenderTerminal) {
		return isAutoConnecting || isReconnecting ? <RouteSkeleton /> : null;
	}

	return (
		<>
			<Stack.Screen options={{ headerShown: false }} />
			<KeyboardAvoidingView
				// On Android, window resizing already handles keyboard avoidance.
				// Keep KeyboardAvoidingView behavior only for iOS.
				behavior={Platform.OS === 'ios' ? 'height' : undefined}
				keyboardVerticalOffset={0}
				style={{
					flex: 1,
					backgroundColor: theme.colors.background,
					// Respect system status/navigation bars on Android.
					paddingTop: Platform.OS === 'android' ? insets.top : 0,
					// Keep a small breathing gap above the Android navigation bar.
					paddingBottom: Platform.OS === 'android' ? insets.bottom + 4 : 0,
				}}
			>
				<TerminalErrorBoundary onRetry={handleTerminalCrashRetry}>
					<XtermJsWebView
						ref={xtermRef}
						style={{ flex: 1 }}
						webViewOptions={{
							// Prevent iOS from adding automatic top inset inside WebView
							contentInsetAdjustmentBehavior: 'never',
							onLayout: () => {
								// Refit terminal when container size changes
								xtermRef.current?.fit();
							},
						}}
						logger={{
							log: logger.info,
							// debug: logger.debug,
							warn: logger.warn,
							error: logger.error,
						}}
						xtermOptions={{
							theme: {
								background: theme.colors.background,
								foreground: theme.colors.textPrimary,
								...(Platform.OS === 'android'
									? {
											// Android: reverse-style selection for readability; iOS keeps the default blue highlight.
											selectionBackground: '#F5F5F5',
											selectionForeground: '#000000',
											selectionInactiveBackground: 'rgba(255, 255, 255, 0.6)',
										}
									: {
											selectionBackground: 'rgba(37, 99, 235, 0.35)',
											selectionInactiveBackground: 'rgba(37, 99, 235, 0.2)',
										}),
							},
						}}
						onResize={handleTerminalResize}
						onSelection={handleSelectionChanged}
						onSelectionModeChange={handleSelectionModeChange}
						onInitialized={() => {
							if (!shell) throw new Error('Shell not found');
							if (Platform.OS === 'android') {
								xtermRef.current?.setSystemKeyboardEnabled(false);
								setSystemKeyboardEnabled(false);
							}
							xtermRef.current?.setSelectionModeEnabled(selectionModeEnabled);

							// Replay from head, then attach live listener
							void (async () => {
								const res = shell.readBuffer({ mode: 'head' });
								logger.info('readBuffer(head)', {
									chunks: res.chunks.length,
									nextSeq: res.nextSeq,
									dropped: res.dropped,
								});
								if (res.chunks.length) {
									const chunks = res.chunks.map((c) => c.bytes);
									const xr = xtermRef.current;
									if (xr) {
										xr.writeMany(chunks.map((c) => new Uint8Array(c)));
										xr.flush();
									}
								}
								const id = shell.addListener(
									(ev: ListenerEvent) => {
										if ('kind' in ev) {
											logger.warn('listener.dropped', ev);
											return;
										}
										const chunk = ev;
										const xr3 = xtermRef.current;
										if (xr3) xr3.write(new Uint8Array(chunk.bytes));
									},
									{ cursor: { mode: 'seq', seq: res.nextSeq } },
								);
								logger.info('shell listener attached', id.toString());
								listenerIdRef.current = id;
							})();
							// Focus to pop the keyboard (iOS needs the prop we set)
							const xr2 = xtermRef.current;
							if (xr2 && Platform.OS === 'ios') xr2.focus();
						}}
						onData={(terminalMessage) => {
							if (!shell) return;
							if (selectionModeEnabled) exitSelectionMode();
							sendBytesRaw(encoder.encode(terminalMessage));
						}}
					/>
				</TerminalErrorBoundary>
				<TerminalKeyboard
					keyboard={currentKeyboard}
					modifierKeysActive={modifierKeysActive}
					onSlotPress={handleSlotPress}
					selectionModeEnabled={selectionModeEnabled}
					onCopySelection={handleCopySelection}
					onPasteClipboard={handlePasteClipboard}
					showSystemKeyboardToggle={Platform.OS === 'android'}
					systemKeyboardEnabled={systemKeyboardEnabled}
					onToggleSystemKeyboard={toggleSystemKeyboard}
				/>
				<CommandPresetsModal
					open={commandPresetsOpen}
					presets={commandPresets}
					bottomOffset={Platform.OS === 'android' ? insets.bottom + 24 : 24}
					onClose={() => {
						setCommandPresetsOpen(false);
					}}
					onSelect={runCommandPreset}
				/>
				<TerminalCommanderModal
					open={commanderOpen}
					bottomOffset={Platform.OS === 'android' ? insets.bottom + 24 : 24}
					onClose={() => {
						setCommanderOpen(false);
					}}
					onExecuteCommand={(value) => {
						if (!value.trim()) return;
						sendTextRaw(value);
						sendBytesRaw(encoder.encode('\r'));
					}}
					onPasteText={(value) => {
						if (!value.trim()) return;
						sendTextRaw(value);
					}}
					onSendShortcut={(sequence) => {
						sendBytesRaw(encoder.encode(sequence));
					}}
				/>
				{flashKeyboardName && (
					<Animated.View
						pointerEvents="none"
						style={{
							position: 'absolute',
							top: '40%',
							left: 0,
							right: 0,
							alignItems: 'center',
							opacity: flashOpacity,
						}}
					>
						<View
							style={{
								backgroundColor: 'rgba(0, 0, 0, 0.75)',
								paddingHorizontal: 20,
								paddingVertical: 10,
								borderRadius: 8,
							}}
						>
							<Text
								style={{
									color: '#fff',
									fontSize: 16,
									fontWeight: '600',
								}}
							>
								{flashKeyboardName}
							</Text>
						</View>
					</Animated.View>
				)}
			</KeyboardAvoidingView>
		</>
	);
}
type ModifierContract = {
	canApplyModifierToBytes: (bytes: Uint8Array<ArrayBuffer>) => boolean;
	applyModifierToBytes: (
		bytes: Uint8Array<ArrayBuffer>,
	) => Uint8Array<ArrayBuffer>;
	orderPreference: number;
};

const escapeByte = 27;

const shiftModifier: ModifierContract = {
	orderPreference: 5,
	canApplyModifierToBytes: (bytes) =>
		bytes.some((byte) => byte >= 97 && byte <= 122),
	applyModifierToBytes: (bytes) => {
		const next = new Uint8Array(bytes.length);
		for (let i = 0; i < bytes.length; i += 1) {
			const byte = bytes[i];
			if (byte === undefined) continue;
			next[i] = byte >= 97 && byte <= 122 ? byte - 32 : byte;
		}
		return next;
	},
};

const ctrlModifier: ModifierContract = {
	orderPreference: 10,
	canApplyModifierToBytes: (bytes) => {
		const firstByte = bytes[0];
		if (firstByte === undefined) return false;
		return mapByteToCtrl(firstByte) != null;
	},
	applyModifierToBytes: (bytes) => {
		const firstByte = bytes[0];
		if (firstByte === undefined) return bytes;
		const ctrlByte = mapByteToCtrl(firstByte);
		if (ctrlByte == null) return bytes;
		return new Uint8Array([ctrlByte]);
	},
};

const altModifier: ModifierContract = {
	orderPreference: 20,
	canApplyModifierToBytes: (bytes) => {
		return bytes.length > 0 && bytes[0] !== escapeByte;
	},
	applyModifierToBytes: (bytes) => {
		const result = new Uint8Array(bytes.length + 1);
		result[0] = escapeByte;
		result.set(bytes, 1);
		return result;
	},
};

function mapByteToCtrl(byte: number): number | null {
	if (byte === 32) return 0; // Ctrl+Space
	const uppercase = byte & 0b1101_1111; // Fold to uppercase / control range
	if (uppercase >= 64 && uppercase <= 95) {
		return uppercase & 0x1f;
	}
	if (byte === 63) return 127; // Ctrl+?
	return null;
}

const cmdModifier: ModifierContract = {
	orderPreference: 30,
	canApplyModifierToBytes: () => false,
	applyModifierToBytes: (bytes) => bytes,
};

const MODIFIER_DEFS: Record<ModifierKey, ModifierContract> = {
	SHIFT: shiftModifier,
	CTRL: ctrlModifier,
	ALT: altModifier,
	CMD: cmdModifier,
};

type LucideIconComponent = React.ComponentType<{
	color?: string;
	size?: number;
}>;

function resolveLucideIcon(name: string | null): LucideIconComponent | null {
	if (!name) return null;
	const iconMap = LucideIcons as unknown as Record<string, LucideIconComponent>;
	const Icon = iconMap[name];
	return Icon ?? null;
}

function TerminalKeyboard({
	keyboard,
	modifierKeysActive,
	onSlotPress,
	selectionModeEnabled,
	onCopySelection,
	onPasteClipboard,
	showSystemKeyboardToggle,
	systemKeyboardEnabled,
	onToggleSystemKeyboard,
}: {
	keyboard: KeyboardDefinition | null;
	modifierKeysActive: ModifierKey[];
	onSlotPress: (slot: KeyboardSlot) => void;
	selectionModeEnabled: boolean;
	onCopySelection: () => void;
	onPasteClipboard: () => void;
	showSystemKeyboardToggle: boolean;
	systemKeyboardEnabled: boolean;
	onToggleSystemKeyboard: () => void;
}) {
	const theme = useTheme();
	const KeyboardIcon = resolveLucideIcon('Keyboard');
	const CopyIcon = resolveLucideIcon('Copy');
	const PasteIcon = resolveLucideIcon('ClipboardPaste');

	if (!keyboard) {
		return (
			<View
				style={{
					borderTopWidth: 1,
					borderColor: theme.colors.border,
					padding: 12,
				}}
			>
				<Text style={{ color: theme.colors.textSecondary }}>
					No keyboard configuration. Generate code to enable shortcuts.
				</Text>
			</View>
		);
	}

	/* eslint-disable @eslint-react/no-array-index-key */
	const rows = keyboard.grid.map((row, rowIndex) => (
		<View key={`row-${rowIndex}`} style={{ flexDirection: 'row' }}>
			{row.map((slot, colIndex) => {
				if (!slot) {
					return (
						<View
							key={`slot-${rowIndex}-${colIndex}`}
							style={{ flex: 1, margin: 2 }}
						/>
					);
				}

				const modifierActive =
					slot.type === 'modifier' &&
					modifierKeysActive.includes(slot.modifier);
				const Icon = resolveLucideIcon(slot.icon);

				return (
					<Pressable
						key={`slot-${rowIndex}-${colIndex}`}
						onPress={() => onSlotPress(slot)}
						style={[
							{
								flex: 1,
								margin: 2,
								paddingVertical: 6,
								borderRadius: 8,
								borderWidth: 1,
								borderColor: theme.colors.border,
								alignItems: 'center',
								justifyContent: 'center',
							},
							modifierActive && {
								backgroundColor: theme.colors.primary,
							},
						]}
					>
						{Icon ? <Icon color={theme.colors.textPrimary} size={18} /> : null}
						<Text
							numberOfLines={1}
							style={{
								color: theme.colors.textPrimary,
								fontSize: 10,
								marginTop: Icon ? 2 : 0,
							}}
						>
							{slot.label}
						</Text>
					</Pressable>
				);
			})}
		</View>
	));
	/* eslint-enable @eslint-react/no-array-index-key */

	const copyToggle = (
		<Pressable
			onPress={onCopySelection}
			style={{
				flex: 1,
				margin: 2,
				paddingVertical: 6,
				borderRadius: 8,
				borderWidth: 1,
				borderColor: theme.colors.border,
				alignItems: 'center',
				justifyContent: 'center',
			}}
		>
			{CopyIcon ? (
				<CopyIcon color={theme.colors.textPrimary} size={18} />
			) : null}
			<Text
				numberOfLines={1}
				style={{
					color: theme.colors.textPrimary,
					fontSize: 10,
					marginTop: CopyIcon ? 2 : 0,
				}}
			>
				Copy
			</Text>
		</Pressable>
	);

	const pasteToggle = (
		<Pressable
			onPress={onPasteClipboard}
			style={{
				flex: 1,
				margin: 2,
				paddingVertical: 6,
				borderRadius: 8,
				borderWidth: 1,
				borderColor: theme.colors.border,
				alignItems: 'center',
				justifyContent: 'center',
			}}
		>
			{PasteIcon ? (
				<PasteIcon color={theme.colors.textPrimary} size={18} />
			) : null}
			<Text
				numberOfLines={1}
				style={{
					color: theme.colors.textPrimary,
					fontSize: 10,
					marginTop: PasteIcon ? 2 : 0,
				}}
			>
				Paste
			</Text>
		</Pressable>
	);

	const systemKeyboardToggle = showSystemKeyboardToggle ? (
		<Pressable
			onPress={onToggleSystemKeyboard}
			style={[
				{
					flex: 1,
					margin: 2,
					paddingVertical: 6,
					borderRadius: 8,
					borderWidth: 1,
					borderColor: theme.colors.border,
					alignItems: 'center',
					justifyContent: 'center',
				},
				systemKeyboardEnabled && { backgroundColor: theme.colors.primary },
			]}
		>
			{KeyboardIcon ? (
				<KeyboardIcon color={theme.colors.textPrimary} size={18} />
			) : null}
			<Text
				numberOfLines={1}
				style={{
					color: theme.colors.textPrimary,
					fontSize: 10,
					marginTop: KeyboardIcon ? 2 : 0,
				}}
			>
				OS Keyboard
			</Text>
		</Pressable>
	) : null;

	const toggleRow =
		selectionModeEnabled || showSystemKeyboardToggle ? (
			<View style={{ flexDirection: 'row' }}>
				{selectionModeEnabled ? copyToggle : null}
				{selectionModeEnabled ? pasteToggle : null}
				{systemKeyboardToggle}
			</View>
		) : null;

	return (
		<View
			style={{
				borderTopWidth: 1,
				borderColor: theme.colors.border,
				padding: 6,
			}}
		>
			{toggleRow}
			{rows}
		</View>
	);
}

const COMMANDER_SHORTCUTS = [
	{
		name: 'Ctrl+C',
		sequence: '\x03',
		description: 'Interrupt/Cancel current process',
	},
	{
		name: 'Ctrl+D',
		sequence: '\x04',
		description: 'End of file (EOF) / Exit',
	},
	{
		name: 'Ctrl+Z',
		sequence: '\x1a',
		description: 'Suspend current process',
	},
	{
		name: 'Ctrl+A',
		sequence: '\x01',
		description: 'Move cursor to beginning of line',
	},
	{
		name: 'Ctrl+E',
		sequence: '\x05',
		description: 'Move cursor to end of line',
	},
	{
		name: 'Ctrl+K',
		sequence: '\x0b',
		description: 'Kill/Delete from cursor to end of line',
	},
	{
		name: 'Ctrl+U',
		sequence: '\x15',
		description: 'Kill/Delete from cursor to beginning of line',
	},
	{
		name: 'Ctrl+W',
		sequence: '\x17',
		description: 'Delete word before cursor',
	},
	{
		name: 'Ctrl+L',
		sequence: '\x0c',
		description: 'Clear screen',
	},
	{
		name: 'Ctrl+R',
		sequence: '\x12',
		description: 'Reverse search command history',
	},
	{
		name: 'Tab',
		sequence: '\t',
		description: 'Auto-complete',
	},
	{
		name: 'Escape',
		sequence: '\x1b',
		description: 'Escape key',
	},
];

function CommandPresetsModal({
	open,
	presets,
	bottomOffset,
	onClose,
	onSelect,
}: {
	open: boolean;
	presets: CommandPreset[];
	bottomOffset: number;
	onClose: () => void;
	onSelect: (preset: CommandPreset) => void;
}) {
	const theme = useTheme();
	const uniquePresets = useMemo(() => {
		const seen = new Set<string>();
		return presets.filter((preset) => {
			const key = preset.label.trim();
			if (seen.has(key)) return false;
			seen.add(key);
			return true;
		});
	}, [presets]);

	return (
		<Modal
			transparent
			visible={open}
			animationType="slide"
			onRequestClose={onClose}
		>
			<Pressable
				onPress={onClose}
				style={{
					flex: 1,
					backgroundColor: theme.colors.overlay,
					justifyContent: 'flex-end',
					alignItems: 'flex-end',
				}}
			>
				<View
					onStartShouldSetResponder={() => true}
					style={{
						backgroundColor: theme.colors.background,
						borderTopLeftRadius: 16,
						padding: 16,
						borderColor: theme.colors.borderStrong,
						borderWidth: 1,
						maxHeight: '80%',
						width: '70%',
						maxWidth: 320,
						minWidth: 240,
						marginRight: 8,
						marginBottom: bottomOffset,
					}}
				>
					<View
						style={{
							flexDirection: 'row',
							alignItems: 'center',
							justifyContent: 'space-between',
							marginBottom: 12,
						}}
					>
						<Text
							style={{
								color: theme.colors.textPrimary,
								fontSize: 18,
								fontWeight: '700',
							}}
						>
							Command Presets
						</Text>
						<Pressable
							onPress={onClose}
							style={{
								paddingHorizontal: 10,
								paddingVertical: 6,
								borderRadius: 8,
								borderWidth: 1,
								borderColor: theme.colors.border,
							}}
						>
							<Text style={{ color: theme.colors.textSecondary }}>Close</Text>
						</Pressable>
					</View>
					{uniquePresets.length === 0 ? (
						<Text style={{ color: theme.colors.textSecondary }}>
							No command presets configured.
						</Text>
					) : (
						<ScrollView>
							{uniquePresets.map((preset, index) => (
								<Pressable
									key={`${preset.label}-${index.toString()}`}
									onPress={() => onSelect(preset)}
									style={{
										paddingVertical: 12,
										paddingHorizontal: 12,
										borderRadius: 10,
										borderWidth: 1,
										borderColor: theme.colors.border,
										backgroundColor: theme.colors.surface,
										marginBottom: 8,
									}}
								>
									<Text
										style={{
											color: theme.colors.textPrimary,
											fontSize: 14,
											fontWeight: '600',
										}}
									>
										{preset.label}
									</Text>
								</Pressable>
							))}
						</ScrollView>
					)}
				</View>
			</Pressable>
		</Modal>
	);
}

function TerminalCommanderModal({
	open,
	bottomOffset,
	onClose,
	onExecuteCommand,
	onPasteText,
	onSendShortcut,
}: {
	open: boolean;
	bottomOffset: number;
	onClose: () => void;
	onExecuteCommand: (value: string) => void;
	onPasteText: (value: string) => void;
	onSendShortcut: (sequence: string) => void;
}) {
	const theme = useTheme();
	const [commandInput, setCommandInput] = useState('');
	const [pasteInput, setPasteInput] = useState('');

	const handleClose = useCallback(() => {
		setCommandInput('');
		setPasteInput('');
		onClose();
	}, [onClose]);

	return (
		<Modal
			transparent
			visible={open}
			animationType="slide"
			onRequestClose={handleClose}
		>
			<Pressable
				onPress={handleClose}
				style={{
					flex: 1,
					backgroundColor: theme.colors.overlay,
				}}
			>
				<KeyboardAvoidingView
					behavior={Platform.OS === 'ios' ? 'padding' : undefined}
					style={{ flex: 1, justifyContent: 'flex-end' }}
				>
					<View
						onStartShouldSetResponder={() => true}
						style={{
							backgroundColor: theme.colors.background,
							borderTopLeftRadius: 16,
							padding: 16,
							borderColor: theme.colors.borderStrong,
							borderWidth: 1,
							maxHeight: '85%',
							width: '70%',
							maxWidth: 360,
							minWidth: 260,
							alignSelf: 'flex-end',
							marginRight: 8,
							marginBottom: bottomOffset,
						}}
					>
						<View
							style={{
								flexDirection: 'row',
								alignItems: 'center',
								justifyContent: 'space-between',
								marginBottom: 12,
							}}
						>
							<Text
								style={{
									color: theme.colors.textPrimary,
									fontSize: 18,
									fontWeight: '700',
								}}
							>
								Terminal Commander
							</Text>
							<Pressable
								onPress={handleClose}
								style={{
									paddingHorizontal: 10,
									paddingVertical: 6,
									borderRadius: 8,
									borderWidth: 1,
									borderColor: theme.colors.border,
								}}
							>
								<Text style={{ color: theme.colors.textSecondary }}>Close</Text>
							</Pressable>
						</View>
						<ScrollView>
							<Text
								style={{
									color: theme.colors.textSecondary,
									fontSize: 14,
									fontWeight: '600',
									marginBottom: 6,
								}}
							>
								Execute Command
							</Text>
							<TextInput
								value={commandInput}
								onChangeText={setCommandInput}
								placeholder="ls -la"
								placeholderTextColor={theme.colors.muted}
								style={{
									borderWidth: 1,
									borderColor: theme.colors.border,
									backgroundColor: theme.colors.inputBackground,
									color: theme.colors.textPrimary,
									borderRadius: 10,
									paddingHorizontal: 12,
									paddingVertical: 10,
									marginBottom: 10,
								}}
							/>
							<Pressable
								onPress={() => {
									if (!commandInput.trim()) return;
									onExecuteCommand(commandInput);
									handleClose();
								}}
								style={{
									backgroundColor: theme.colors.primary,
									borderRadius: 10,
									paddingVertical: 12,
									alignItems: 'center',
									marginBottom: 16,
								}}
							>
								<Text
									style={{
										color: theme.colors.buttonTextOnPrimary,
										fontWeight: '700',
									}}
								>
									Execute
								</Text>
							</Pressable>
							<Text
								style={{
									color: theme.colors.textSecondary,
									fontSize: 14,
									fontWeight: '600',
									marginBottom: 6,
								}}
							>
								Paste Text
							</Text>
							<TextInput
								value={pasteInput}
								onChangeText={setPasteInput}
								placeholder="Enter text to paste..."
								placeholderTextColor={theme.colors.muted}
								style={{
									borderWidth: 1,
									borderColor: theme.colors.border,
									backgroundColor: theme.colors.inputBackground,
									color: theme.colors.textPrimary,
									borderRadius: 10,
									paddingHorizontal: 12,
									paddingVertical: 10,
									minHeight: 90,
									textAlignVertical: 'top',
									marginBottom: 10,
								}}
								multiline
							/>
							<Pressable
								onPress={() => {
									if (!pasteInput.trim()) return;
									onPasteText(pasteInput);
									handleClose();
								}}
								style={{
									backgroundColor: theme.colors.primary,
									borderRadius: 10,
									paddingVertical: 12,
									alignItems: 'center',
									marginBottom: 16,
								}}
							>
								<Text
									style={{
										color: theme.colors.buttonTextOnPrimary,
										fontWeight: '700',
									}}
								>
									Paste
								</Text>
							</Pressable>
							<Text
								style={{
									color: theme.colors.textSecondary,
									fontSize: 14,
									fontWeight: '600',
									marginBottom: 6,
								}}
							>
								Shortcuts
							</Text>
							{COMMANDER_SHORTCUTS.map((shortcut) => (
								<Pressable
									key={shortcut.name}
									onPress={() => {
										onSendShortcut(shortcut.sequence);
										handleClose();
									}}
									style={{
										paddingVertical: 12,
										paddingHorizontal: 12,
										borderRadius: 10,
										borderWidth: 1,
										borderColor: theme.colors.border,
										backgroundColor: theme.colors.surface,
										marginBottom: 8,
									}}
								>
									<Text
										style={{
											color: theme.colors.textPrimary,
											fontSize: 14,
											fontWeight: '600',
										}}
									>
										{shortcut.name}
									</Text>
									<Text
										style={{
											color: theme.colors.textSecondary,
											fontSize: 12,
											marginTop: 2,
										}}
									>
										{shortcut.description}
									</Text>
								</Pressable>
							))}
						</ScrollView>
					</View>
				</KeyboardAvoidingView>
			</Pressable>
		</Modal>
	);
}
</file>

<file path="packages/react-native-xtermjs-webview/src-internal/main.tsx">
import { FitAddon } from '@xterm/addon-fit';
import { Terminal, type ITerminalOptions } from '@xterm/xterm';
import '@xterm/xterm/css/xterm.css';
import {
	bStrToBinary,
	type BridgeInboundMessage,
	type BridgeOutboundMessage,
} from '../src/bridge';

declare global {
	interface Window {
		terminal?: Terminal;
		fitAddon?: FitAddon;
		terminalWriteBase64?: (data: string) => void;
		__FRESSH_XTERM_OPTIONS__?: ITerminalOptions;
		ReactNativeWebView?: {
			postMessage?: (data: string) => void;
			injectedObjectJson?: () => string | undefined;
		};
		__FRESSH_XTERM_BRIDGE__?: boolean;
		__FRESSH_XTERM_MSG_HANDLER__?: (
			e: MessageEvent<BridgeOutboundMessage>,
		) => void;
	}
}

const sendToRn = (msg: BridgeInboundMessage) =>
	window.ReactNativeWebView?.postMessage?.(JSON.stringify(msg));

/**
 * Idempotent boot guard: ensure we only install once.
 * If the script happens to run twice (dev reloads, double-mounts), we bail out early.
 */
window.onload = () => {
	try {
		if (window.__FRESSH_XTERM_BRIDGE__) {
			sendToRn({
				type: 'debug',
				message: 'bridge already installed; ignoring duplicate boot',
			});
			return;
		}

		const injectedObjectJson =
			window.ReactNativeWebView?.injectedObjectJson?.();
		let injectedObject: ITerminalOptions = {};
		if (injectedObjectJson) {
			try {
				injectedObject = JSON.parse(injectedObjectJson) as ITerminalOptions;
			} catch (err) {
				if (window.__FRESSH_XTERM_OPTIONS__) {
					injectedObject = window.__FRESSH_XTERM_OPTIONS__;
					sendToRn({
						type: 'debug',
						message: 'injectedObjectJson invalid; using preloaded options',
					});
				} else {
					sendToRn({
						type: 'debug',
						message: `injectedObjectJson invalid; using defaults (${String(
							err,
						)})`,
					});
				}
			}
		} else if (window.__FRESSH_XTERM_OPTIONS__) {
			injectedObject = window.__FRESSH_XTERM_OPTIONS__;
			sendToRn({
				type: 'debug',
				message: 'injectedObjectJson not found; using preloaded options',
			});
		} else {
			sendToRn({
				type: 'debug',
				message: 'injectedObjectJson not found; using defaults',
			});
		}

		window.__FRESSH_XTERM_BRIDGE__ = true;

		// ---- Xterm setup
		const term = new Terminal(injectedObject);
		const fitAddon = new FitAddon();
		term.loadAddon(fitAddon);

		const root = document.getElementById('terminal')!;
		term.open(root);
		fitAddon.fit();
		if (document.documentElement) {
			document.documentElement.style.overflow = 'hidden';
		}
		if (document.body) {
			document.body.style.overflow = 'hidden';
		}
		if (term.element) {
			term.element.style.position = 'relative';
			term.element.style.overflow = 'hidden';
		}
		root.style.position = 'relative';
		root.style.overflow = 'hidden';

		if (!window.ReactNativeWebView) {
			const devTheme = {
				background: '#0b1220',
				foreground: '#e2e8f0',
				selectionBackground: 'rgba(26, 115, 232, 0.35)',
				selectionInactiveBackground: 'rgba(26, 115, 232, 0.2)',
			};
			term.options.theme = {
				...(term.options.theme ?? {}),
				...devTheme,
			};
			if (document.body) {
				document.body.style.backgroundColor = devTheme.background;
			}
			term.writeln('Fressh handle dev view');
			term.writeln('Long-press to enter selection mode.');
			term.writeln('Use this page to tune selection handles.');
			term.writeln('');
			term.writeln('The quick brown fox jumps over the lazy dog.');
			term.writeln('0123456789 []{}() <>,.?/ +-*/');
		}

		// Send initial size after first fit
		if (term.cols >= 2 && term.rows >= 1) {
			sendToRn({ type: 'sizeChanged', cols: term.cols, rows: term.rows });
		}

		const applyFontFamily = (family?: string) => {
			if (!family) return;
			const rootEl = (term.element ??
				document.querySelector('.xterm')) as HTMLElement | null;
			if (rootEl) rootEl.style.fontFamily = family;
			const helper = document.querySelector(
				'.xterm-helper-textarea',
			) as HTMLElement | null;
			if (helper) helper.style.fontFamily = family;
			const measure = document.querySelector(
				'.xterm-char-measure-element',
			) as HTMLElement | null;
			if (measure) measure.style.fontFamily = family;
		};

		applyFontFamily(injectedObject.fontFamily);

		const selectionModeClass = 'fressh-selection-mode';
		const selectionModeStyleId = 'fressh-selection-mode-style';
		const baseSelectionOptions = {
			disableStdin: Boolean(term.options.disableStdin),
			screenReaderMode: Boolean(term.options.screenReaderMode),
		};
		let selectionModeEnabled = false;
		let selectionModeShownAt = 0;
		let lastSelectionText = '';
		let longPressCleanup: (() => void) | null = null;
		let touchCleanup: (() => void) | null = null;
		let selectionOverlay: HTMLDivElement | null = null;
		let startHandle: HTMLDivElement | null = null;
		let endHandle: HTMLDivElement | null = null;
		let activeHandle: 'start' | 'end' | null = null;
		let activePointerId: number | null = null;
		const selectionOverlayTint = 'rgba(0, 0, 0, 0)';
		const minHandleGapPx = 36;
		// Toggle handle debug visuals + oversized hitboxes (tuning aid).
		const debugSelectionHandles = false;
		// Lollipop handle geometry; anchor is where the circle meets the stem.
		const selectionHandleScale = debugSelectionHandles ? 5 : 1;
		const selectionHandleSizePx = 48 * selectionHandleScale;
		const selectionHandleCircleBelowStart = true;
		const lollipopViewboxWidth = 48;
		const lollipopViewboxHeight = 52;
		const lollipopViewboxMinX = 0;
		const lollipopViewboxMinY = -4;
		const lollipopViewboxMaxY =
			lollipopViewboxMinY + lollipopViewboxHeight;
		const lollipopViewboxCenterX =
			lollipopViewboxMinX + lollipopViewboxWidth / 2;
		const lollipopViewboxCenterY =
			lollipopViewboxMinY + lollipopViewboxHeight / 2;
		const lollipopViewboxFlipSumY =
			lollipopViewboxMinY + lollipopViewboxMaxY;
		const selectionHandleGlyphWidthPx =
			lollipopViewboxWidth * selectionHandleScale;
		const selectionHandleGlyphHeightPx =
			lollipopViewboxHeight * selectionHandleScale;
		const selectionHandleGlyphLeftPx = 0;
		const selectionHandleGlyphTopPx = 0;
		const selectionHandleBorder = debugSelectionHandles
			? '1px dashed #ff3b30'
			: 'none';
		const selectionHandleClipBorder = debugSelectionHandles
			? '1px solid #22c55e'
			: 'none';
		const selectionHandleClipDisplay = debugSelectionHandles ? 'block' : 'none';
		const lollipopCircleCenter = { x: 24, y: 9 };
		const lollipopCircleRadius = 10.5;
		const lollipopJunction = { x: 24, y: 17 };
		const lollipopStemWidth = 2;
		const lollipopStemTop = 15;
		const lollipopStemBottom = 36;
		const longPressTimeoutMs = 500;
		const longPressSlopPx = 8;
		// Guard against immediate hide right after long-press selection activates.
		const selectionHideGuardMs = 300;

		const ensureSelectionModeStyle = () => {
			if (document.getElementById(selectionModeStyleId)) return;
			const style = document.createElement('style');
			style.id = selectionModeStyleId;
			style.type = 'text/css';
			style.textContent = `
.${selectionModeClass} .xterm .xterm-accessibility {
	pointer-events: auto !important;
}
.${selectionModeClass} .xterm .xterm-accessibility-tree {
	user-select: text !important;
	-webkit-user-select: text !important;
}
.${selectionModeClass} .fressh-selection-handle {
	position: absolute;
	/* Hitbox scales up only when debugSelectionHandles is true. */
	width: ${selectionHandleSizePx}px;
	height: ${selectionHandleSizePx}px;
	background: transparent;
	box-sizing: border-box;
	border: ${selectionHandleBorder};
	touch-action: none;
	z-index: 30;
	pointer-events: auto;
}
.${selectionModeClass} .fressh-selection-handle-glyph {
	position: absolute;
	left: ${selectionHandleGlyphLeftPx}px;
	top: ${selectionHandleGlyphTopPx}px;
	width: ${selectionHandleGlyphWidthPx}px;
	height: ${selectionHandleGlyphHeightPx}px;
}
.${selectionModeClass} .fressh-selection-handle-glyph path,
.${selectionModeClass} .fressh-selection-handle-glyph circle,
.${selectionModeClass} .fressh-selection-handle-glyph rect {
	fill: #60a5fa;
	pointer-events: none;
}
.${selectionModeClass} .fressh-selection-handle-clip {
	position: absolute;
	border: ${selectionHandleClipBorder};
	box-sizing: border-box;
	pointer-events: none;
	display: ${selectionHandleClipDisplay};
}
`;
			(document.head || document.documentElement).appendChild(style);
		};

		type WorkCell = { getWidth: () => number; getChars?: () => string };
		type LineLike = {
			getCell?: (col: number) => WorkCell | null;
			loadCell?: (col: number, cell: WorkCell) => WorkCell;
		};

		const getSelectionCore = () => {
			const core = term as unknown as {
				_mouseService?: {
					getCoords: (
						event: { clientX: number; clientY: number },
						element: HTMLElement,
						cols: number,
						rows: number,
						isSelection?: boolean,
					) => [number, number] | undefined;
				};
				screenElement?: HTMLElement;
				_bufferService?: {
					cols: number;
					rows: number;
					buffer: {
						ydisp: number;
						lines: {
							get: (idx: number) =>
								| {
										getCell: (col: number) => {
											getWidth: () => number;
											getChars?: () => string;
										} | null;
								  }
								| undefined;
						};
					};
				};
				_selectionService?: {
					clearSelection: () => void;
					refresh: (isTextLayout: boolean) => void;
					_fireEventIfSelectionChanged?: () => void;
					_model: {
						selectionStart?: [number, number];
						selectionEnd?: [number, number];
						selectionStartLength: number;
						clearSelection: () => void;
					};
				};
				_core?: {
					_mouseService?: {
						getCoords: (
							event: { clientX: number; clientY: number },
							element: HTMLElement,
							cols: number,
							rows: number,
							isSelection?: boolean,
						) => [number, number] | undefined;
					};
					_screenElement?: HTMLElement;
					_bufferService?: {
						cols: number;
						rows: number;
						buffer: {
							ydisp: number;
							lines: {
								get: (idx: number) =>
									| {
											getCell: (col: number) => {
												getWidth: () => number;
												getChars?: () => string;
											} | null;
									  }
									| undefined;
							};
						};
					};
					_selectionService?: {
						clearSelection: () => void;
						refresh: (isTextLayout: boolean) => void;
						_fireEventIfSelectionChanged?: () => void;
						_model: {
							selectionStart?: [number, number];
							selectionEnd?: [number, number];
							selectionStartLength: number;
							clearSelection: () => void;
						};
					};
				};
			};

			const mouseService = core._mouseService ?? core._core?._mouseService;
			const screenElement =
				core.screenElement ??
				core._core?._screenElement ??
				(term.element?.querySelector('.xterm-screen') as HTMLElement | null);
			const bufferService = core._bufferService ?? core._core?._bufferService;
			const selectionService =
				core._selectionService ?? core._core?._selectionService;
			const workCell = (
				selectionService as { _workCell?: WorkCell } | undefined
			)?._workCell;

			if (
				!mouseService ||
				!screenElement ||
				!bufferService ||
				!selectionService
			) {
				return null;
			}
			return {
				mouseService,
				screenElement,
				bufferService,
				selectionService,
				workCell,
			};
		};

		const getCellDimensions = () => {
			const renderService =
				(
					term as unknown as {
						_core?: {
							_renderService?: {
								dimensions?: {
									css?: { cell?: { width?: number; height?: number } };
								};
							};
						};
						_renderService?: {
							dimensions?: {
								css?: { cell?: { width?: number; height?: number } };
							};
						};
					}
				)._renderService ??
				(
					term as unknown as {
						_core?: {
							_renderService?: {
								dimensions?: {
									css?: { cell?: { width?: number; height?: number } };
								};
							};
						};
					}
				)._core?._renderService;
			const cellWidth = renderService?.dimensions?.css?.cell?.width;
			const cellHeight = renderService?.dimensions?.css?.cell?.height;
			if (!cellWidth || !cellHeight) return null;
			return { cellWidth, cellHeight };
		};

		const getHandleGapPx = (
			start: [number, number],
			end: [number, number],
			dims: { cellWidth: number; cellHeight: number },
		) => {
			const dx = (end[0] - start[0]) * dims.cellWidth;
			const dy = (end[1] - start[1]) * dims.cellHeight;
			return Math.hypot(dx, dy);
		};

		const stepBufferPos = (
			pos: [number, number],
			dir: -1 | 1,
			cols: number,
		): [number, number] => {
			let [x, y] = pos;
			if (dir > 0) {
				x += 1;
				if (x >= cols) {
					x = 0;
					y += 1;
				}
			} else {
				x -= 1;
				if (x < 0) {
					x = cols - 1;
					y -= 1;
				}
			}
			return [x, y];
		};

		const moveUntilMinGap = (
			anchor: [number, number],
			moving: [number, number],
			dir: -1 | 1,
			dims: { cellWidth: number; cellHeight: number },
			bounds: { minRow: number; maxRow: number; cols: number },
		) => {
			let next = moving;
			let gap = getHandleGapPx(anchor, next, dims);
			let steps = 0;
			const maxSteps = bounds.cols * 2;
			while (gap < minHandleGapPx && steps < maxSteps) {
				const candidate = stepBufferPos(next, dir, bounds.cols);
				if (candidate[1] < bounds.minRow || candidate[1] > bounds.maxRow) break;
				next = candidate;
				gap = getHandleGapPx(anchor, next, dims);
				steps += 1;
			}
			return { pos: next, achieved: gap >= minHandleGapPx };
		};

		const toInclusiveEnd = (
			endExclusive: [number, number],
			cols: number,
			minRow: number,
		): [number, number] => {
			const [x, y] = endExclusive;
			if (x > 0) return [x - 1, y];
			if (y <= minRow) return [0, y];
			return [cols - 1, y - 1];
		};

		// Lollipop glyph in a padded viewBox: circle above the anchor, stem crosses it.

		const ensureHandleGlyph = (
			handle: HTMLDivElement,
			kind: 'start' | 'end',
		) => {
			if (handle.dataset.glyph === kind) return;
			handle.textContent = '';
			handle.dataset.glyph = kind;
			const isFlipped = kind === 'end' || selectionHandleCircleBelowStart;
			const glyph = document.createElement('div');
			glyph.className = 'fressh-selection-handle-glyph';
			const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			svg.setAttribute('width', String(selectionHandleGlyphWidthPx));
			svg.setAttribute('height', String(selectionHandleGlyphHeightPx));
			svg.setAttribute(
				'viewBox',
				`${lollipopViewboxMinX} ${lollipopViewboxMinY} ${lollipopViewboxWidth} ${lollipopViewboxHeight}`,
			);
			const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
			if (isFlipped) {
				// Vertical mirror: circle below the anchor.
				g.setAttribute(
					'transform',
					`translate(0 ${lollipopViewboxFlipSumY}) scale(1 -1)`,
				);
			}
			const stem = document.createElementNS(
				'http://www.w3.org/2000/svg',
				'rect',
			);
			stem.setAttribute(
				'x',
				String(lollipopJunction.x - lollipopStemWidth / 2),
			);
			stem.setAttribute('y', String(lollipopStemTop));
			stem.setAttribute('width', String(lollipopStemWidth));
			stem.setAttribute(
				'height',
				String(lollipopStemBottom - lollipopStemTop),
			);
			const circle = document.createElementNS(
				'http://www.w3.org/2000/svg',
				'circle',
			);
			circle.setAttribute('cx', String(lollipopCircleCenter.x));
			circle.setAttribute('cy', String(lollipopCircleCenter.y));
			circle.setAttribute('r', String(lollipopCircleRadius));
			// Draw stem first so the circle can cover any seam at the join.
			g.appendChild(stem);
			g.appendChild(circle);
			svg.appendChild(g);
			glyph.appendChild(svg);
			handle.appendChild(glyph);
			const clip = document.createElement('div');
			clip.className = 'fressh-selection-handle-clip';
			handle.appendChild(clip);
		};

		const getHandleGlyphBounds = (handle: HTMLDivElement) => {
			const scaleX = selectionHandleGlyphWidthPx / lollipopViewboxWidth;
			const scaleY = selectionHandleGlyphHeightPx / lollipopViewboxHeight;
			const kind = handle.dataset.glyph as 'start' | 'end' | undefined;
			const isFlipped =
				kind === 'end' || (kind === 'start' && selectionHandleCircleBelowStart);
			const circleMinX = lollipopCircleCenter.x - lollipopCircleRadius;
			const circleMaxX = lollipopCircleCenter.x + lollipopCircleRadius;
			const circleMinY = lollipopCircleCenter.y - lollipopCircleRadius;
			const circleMaxY = lollipopCircleCenter.y + lollipopCircleRadius;
			const stemMinX = lollipopJunction.x - lollipopStemWidth / 2;
			const stemMaxX = lollipopJunction.x + lollipopStemWidth / 2;
			const stemMinY = lollipopStemTop;
			const stemMaxY = lollipopStemBottom;
			const minX = Math.min(circleMinX, stemMinX);
			const maxX = Math.max(circleMaxX, stemMaxX);
			const minY = Math.min(circleMinY, stemMinY);
			const maxY = Math.max(circleMaxY, stemMaxY);
			const flippedMinY = isFlipped ? lollipopViewboxFlipSumY - maxY : minY;
			const flippedMaxY = isFlipped ? lollipopViewboxFlipSumY - minY : maxY;
			return {
				left: (minX - lollipopViewboxMinX) * scaleX,
				top: (flippedMinY - lollipopViewboxMinY) * scaleY,
				width: (maxX - minX) * scaleX,
				height: (flippedMaxY - flippedMinY) * scaleY,
			};
		};

		const getHandleLayout = (kind: 'start' | 'end') => {
			const isFlipped =
				kind === 'end' || (kind === 'start' && selectionHandleCircleBelowStart);
			const circleY =
				isFlipped
					? lollipopViewboxFlipSumY - lollipopCircleCenter.y
					: lollipopCircleCenter.y;
			const junctionY =
				isFlipped
					? lollipopViewboxFlipSumY - lollipopJunction.y
					: lollipopJunction.y;
			const glyphOffsetX =
				(lollipopViewboxCenterX - lollipopCircleCenter.x) *
				selectionHandleScale;
			const glyphOffsetY =
				(lollipopViewboxCenterY - circleY) * selectionHandleScale;
			const anchorOffsetX =
				glyphOffsetX +
				(lollipopJunction.x - lollipopViewboxMinX) * selectionHandleScale;
			const anchorOffsetY =
				glyphOffsetY +
				(junctionY - lollipopViewboxMinY) * selectionHandleScale;
			return {
				glyphLeft: selectionHandleGlyphLeftPx + glyphOffsetX,
				glyphTop: selectionHandleGlyphTopPx + glyphOffsetY,
				anchorOffsetX,
				anchorOffsetY,
			};
		};

		const ensureHandleInDom = (handle: HTMLDivElement, root: HTMLElement) => {
			if (handle.parentElement) return;
			handle.style.visibility = 'hidden';
			handle.style.left = '0px';
			handle.style.top = '0px';
			root.appendChild(handle);
		};

		const setHandleGlyphLeft = (handle: HTMLDivElement, leftPx: number) => {
			const glyph = handle.querySelector<HTMLDivElement>(
				'.fressh-selection-handle-glyph',
			);
			if (!glyph) return;
			// Allow the glyph to overflow the hitbox so we can center the circle.
			glyph.style.left = `${leftPx}px`;
		};

		const setHandleGlyphTop = (handle: HTMLDivElement, topPx: number) => {
			const glyph = handle.querySelector<HTMLDivElement>(
				'.fressh-selection-handle-glyph',
			);
			if (!glyph) return;
			// Allow the glyph to overflow the hitbox so we can center the circle.
			glyph.style.top = `${topPx}px`;
		};

		const setHandleClipRect = (
			handle: HTMLDivElement,
			left: number,
			top: number,
			width: number,
			height: number,
		) => {
			const clip = handle.querySelector<HTMLDivElement>(
				'.fressh-selection-handle-clip',
			);
			if (!clip) return;
			clip.style.left = `${left}px`;
			clip.style.top = `${top}px`;
			clip.style.width = `${width}px`;
			clip.style.height = `${height}px`;
		};

		const getBufferCoords = (
			clientX: number,
			clientY: number,
		): [number, number] | null => {
			const core = getSelectionCore();
			if (!core) return null;
			const coords = core.mouseService.getCoords(
				{ clientX, clientY },
				core.screenElement,
				core.bufferService.cols,
				core.bufferService.rows,
				true,
			);
			if (!coords) return null;
			coords[0] -= 1;
			coords[1] -= 1;
			coords[1] += core.bufferService.buffer.ydisp;
			return coords as [number, number];
		};

		const getCellData = (
			line: LineLike,
			col: number,
			core: { workCell?: WorkCell },
		) => {
			if (typeof line.getCell === 'function') {
				return line.getCell(col) ?? null;
			}
			if (typeof line.loadCell === 'function' && core.workCell) {
				return line.loadCell(col, core.workCell);
			}
			return null;
		};

		const normalizeSelectionColumn = (
			line: LineLike,
			col: number,
			core: { workCell?: WorkCell },
		) => {
			let c = Math.max(0, col);
			const initial = getCellData(line, c, core);
			if (!initial) return c;
			if (initial.getWidth() !== 0) return c;
			while (c > 0) {
				c -= 1;
				const cell = getCellData(line, c, core);
				if (cell && cell.getWidth() > 0) return c;
			}
			return c;
		};

		const expandToWord = (
			coords: [number, number],
		): { start: [number, number]; end: [number, number] } => {
			const core = getSelectionCore();
			if (!core) return { start: coords, end: coords };
			const [xRaw, y] = coords;
			const line = core.bufferService.buffer.lines.get(y);
			if (!line) {
				return { start: coords, end: coords };
			}
			const x = normalizeSelectionColumn(line, xRaw, core);
			const cell = getCellData(line, x, core);
			const char = cell?.getChars?.() ?? '';
			const separators = term.options.wordSeparator ?? '';
			const isSeparator = (value: string) =>
				value.trim().length === 0 || separators.includes(value);
			if (!char || isSeparator(char)) {
				return { start: [x, y], end: [x, y] };
			}
			let left = x;
			let right = x;
			while (left > 0) {
				const nextCol = normalizeSelectionColumn(line, left - 1, core);
				const nextCell = getCellData(line, nextCol, core);
				const nextChar = nextCell?.getChars?.() ?? '';
				if (!nextChar || isSeparator(nextChar)) break;
				left = nextCol;
				if (nextCol === 0) break;
			}
			while (right < core.bufferService.cols - 1) {
				const nextCol = normalizeSelectionColumn(line, right + 1, core);
				if (nextCol <= right) break;
				const nextCell = getCellData(line, nextCol, core);
				const nextChar = nextCell?.getChars?.() ?? '';
				if (!nextChar || isSeparator(nextChar)) break;
				right = nextCol;
				if (right >= core.bufferService.cols - 1) break;
			}
			return { start: [left, y], end: [right, y] };
		};

		const emitSelectionChanged = () => {
			let text = '';
			try {
				text = term.getSelection() || '';
			} catch {
				text = '';
			}
			if (text === lastSelectionText) return;
			lastSelectionText = text;
			sendToRn({ type: 'selectionChanged', text });
		};

		const renderSelectionHandles = () => {
			if (!selectionModeEnabled) {
				if (startHandle) startHandle.style.display = 'none';
				if (endHandle) endHandle.style.display = 'none';
				return;
			}
			const core = getSelectionCore();
			if (!core) return;
			const selectionService =
				core.selectionService as typeof core.selectionService & {
					selectionStart?: [number, number];
					selectionEnd?: [number, number];
				};
			const model = selectionService._model;
			const selectionStart =
				selectionService.selectionStart ?? model.selectionStart;
			const selectionEnd = selectionService.selectionEnd ?? model.selectionEnd;
			if (!selectionStart || !selectionEnd) {
				if (startHandle) startHandle.style.display = 'none';
				if (endHandle) endHandle.style.display = 'none';
				return;
			}
			const dims = getCellDimensions();
			const cellWidth = dims?.cellWidth;
			const cellHeight = dims?.cellHeight;
			if (!cellWidth || !cellHeight) return;

			const rootEl = term.element;
			const screenRect = core.screenElement.getBoundingClientRect();
			const rootRect = rootEl?.getBoundingClientRect();
			if (!rootEl || !rootRect) return;

			const offsetX = screenRect.left - rootRect.left;
			const offsetY = screenRect.top - rootRect.top;
			const ydisp = core.bufferService.buffer.ydisp;
			const startRow = selectionStart[1] - ydisp;
			const endRow = selectionEnd[1] - ydisp;
			if (startRow < 0 || startRow >= core.bufferService.rows) {
				if (startHandle) startHandle.style.display = 'none';
			} else {
				const startX = offsetX + selectionStart[0] * cellWidth - 1;
				const startY =
					offsetY +
					(startRow + (selectionHandleCircleBelowStart ? 1 : 0)) *
						cellHeight;
				startHandle = startHandle ?? document.createElement('div');
				startHandle.className = 'fressh-selection-handle';
				ensureHandleGlyph(startHandle, 'start');
				ensureHandleInDom(startHandle, rootEl);
				const startBounds = getHandleGlyphBounds(startHandle) ?? {
					left: 0,
					top: 0,
					width: selectionHandleGlyphWidthPx,
					height: selectionHandleGlyphHeightPx,
				};
				const startLayout = getHandleLayout('start');
				setHandleGlyphLeft(startHandle, startLayout.glyphLeft);
				setHandleGlyphTop(startHandle, startLayout.glyphTop);
				setHandleClipRect(
					startHandle,
					startLayout.glyphLeft + startBounds.left,
					startLayout.glyphTop + startBounds.top,
					startBounds.width,
					startBounds.height,
				);
				startHandle.style.display = 'block';
				startHandle.style.left = `${startX - startLayout.anchorOffsetX}px`;
				startHandle.style.top = `${startY - startLayout.anchorOffsetY}px`;
				startHandle.style.visibility = 'visible';
				if (!startHandle.parentElement) rootEl.appendChild(startHandle);
			}

			const endRowVisible = endRow >= 0 && endRow < core.bufferService.rows;
			if (!endRowVisible) {
				if (endHandle) endHandle.style.display = 'none';
			} else {
				const endX = offsetX + selectionEnd[0] * cellWidth;
				const endY = offsetY + (endRow + 1) * cellHeight;
				endHandle = endHandle ?? document.createElement('div');
				endHandle.className = 'fressh-selection-handle';
				ensureHandleGlyph(endHandle, 'end');
				ensureHandleInDom(endHandle, rootEl);
				const endBounds = getHandleGlyphBounds(endHandle) ?? {
					left: 0,
					top: 0,
					width: selectionHandleGlyphWidthPx,
					height: selectionHandleGlyphHeightPx,
				};
				const endLayout = getHandleLayout('end');
				setHandleGlyphLeft(endHandle, endLayout.glyphLeft);
				setHandleGlyphTop(endHandle, endLayout.glyphTop);
				setHandleClipRect(
					endHandle,
					endLayout.glyphLeft + endBounds.left,
					endLayout.glyphTop + endBounds.top,
					endBounds.width,
					endBounds.height,
				);
				endHandle.style.display = 'block';
				endHandle.style.left = `${endX - endLayout.anchorOffsetX}px`;
				endHandle.style.top = `${endY - endLayout.anchorOffsetY}px`;
				endHandle.style.visibility = 'visible';
				if (!endHandle.parentElement) rootEl.appendChild(endHandle);
			}
			if (startHandle || endHandle) ensureHandleListeners();
		};

		const updateSelectionRange = (
			start: [number, number],
			end: [number, number],
		) => {
			const core = getSelectionCore();
			if (!core) return;
			sendToRn({
				type: 'debug',
				message: `updateSelectionRange start=${start[0]},${start[1]} end=${end[0]},${end[1]}`,
			});
			try {
				const maxRow =
					core.bufferService.buffer.ydisp + core.bufferService.rows - 1;
				const minRow = core.bufferService.buffer.ydisp;
				const startRow = Math.max(minRow, Math.min(start[1], maxRow));
				const endRow = Math.max(minRow, Math.min(end[1], maxRow));
				const clampColInclusive = (value: number) =>
					Math.max(0, Math.min(value, core.bufferService.cols - 1));
				let [sx, sy] = [clampColInclusive(start[0]), startRow];
				let [exInclusive, ey] = [clampColInclusive(end[0]), endRow];
				if (sy > ey || (sy === ey && sx > exInclusive)) {
					if (activeHandle === 'start') {
						sy = ey;
						sx = exInclusive;
					} else if (activeHandle === 'end') {
						ey = sy;
						exInclusive = sx;
					}
				}
				const dims = getCellDimensions();
				if (dims) {
					const bounds = {
						minRow,
						maxRow,
						cols: core.bufferService.cols,
					};
					const gap = getHandleGapPx([sx, sy], [exInclusive, ey], dims);
					if (gap < minHandleGapPx) {
						if (activeHandle === 'start' || activeHandle === 'end') {
							const isStartActive = activeHandle === 'start';
							const anchor: [number, number] = isStartActive
								? [exInclusive, ey]
								: [sx, sy];
							const moving: [number, number] = isStartActive
								? [sx, sy]
								: [exInclusive, ey];
							const dir: -1 | 1 = isStartActive ? -1 : 1;
							const result = moveUntilMinGap(anchor, moving, dir, dims, bounds);
							if (result.achieved) {
								if (isStartActive) {
									sx = result.pos[0];
									sy = result.pos[1];
								} else {
									exInclusive = result.pos[0];
									ey = result.pos[1];
								}
							} else {
								const fallback = moveUntilMinGap(
									moving,
									anchor,
									(dir * -1) as -1 | 1,
									dims,
									bounds,
								);
								if (fallback.achieved) {
									if (isStartActive) {
										exInclusive = fallback.pos[0];
										ey = fallback.pos[1];
									} else {
										sx = fallback.pos[0];
										sy = fallback.pos[1];
									}
								}
							}
						} else {
							const result = moveUntilMinGap(
								[sx, sy],
								[exInclusive, ey],
								1,
								dims,
								bounds,
							);
							if (result.achieved) {
								exInclusive = result.pos[0];
								ey = result.pos[1];
							} else {
								const fallback = moveUntilMinGap(
									[exInclusive, ey],
									[sx, sy],
									-1,
									dims,
									bounds,
								);
								if (fallback.achieved) {
									sx = fallback.pos[0];
									sy = fallback.pos[1];
								}
							}
						}
					}
				}
				const endExclusive =
					exInclusive < core.bufferService.cols - 1
						? exInclusive + 1
						: core.bufferService.cols;
				const ex = endExclusive;
				const length = Math.max(
					1,
					(ey - sy) * core.bufferService.cols + (ex - sx),
				);
				const selectionService =
					core.selectionService as typeof core.selectionService & {
						setSelection?: (col: number, row: number, length: number) => void;
					};
				if (selectionService.setSelection) {
					selectionService.setSelection(sx, sy, length);
				} else {
					core.selectionService._model.selectionStart = [sx, sy];
					core.selectionService._model.selectionEnd = [ex, ey];
					core.selectionService._model.selectionStartLength = 0;
					core.selectionService.refresh(true);
					core.selectionService._fireEventIfSelectionChanged?.();
				}
				try {
					const selectionText = term.getSelection() || '';
					sendToRn({
						type: 'debug',
						message: `selection updated len=${selectionText.length} start=${sx},${sy} end=${ex},${ey} ydisp=${core.bufferService.buffer.ydisp}`,
					});
				} catch {
					sendToRn({
						type: 'debug',
						message: `selection updated start=${sx},${sy} end=${ex},${ey} ydisp=${core.bufferService.buffer.ydisp}`,
					});
				}
				renderSelectionHandles();
			} catch (err) {
				sendToRn({
					type: 'debug',
					message: `selection update error: ${String(err)}`,
				});
			}
		};

		const ensureHandleListeners = () => {
			const rootEl = term.element;
			if (!rootEl) return;
			const attach = (handle: HTMLDivElement, kind: 'start' | 'end') => {
				if (handle.dataset.listenersAttached === 'true') return;
				let dragStart: { x: number; y: number } | null = null;
				let dragOffset: { x: number; y: number } | null = null;
				let dragging = false;

				const resetDrag = () => {
					dragStart = null;
					dragOffset = null;
					dragging = false;
				};

				const onPointerDown = (event: PointerEvent) => {
					if (!selectionModeEnabled) return;
					activeHandle = kind;
					activePointerId = event.pointerId;
					const layout = getHandleLayout(kind);
					const rect = handle.getBoundingClientRect();
					const anchorX = rect.left + layout.anchorOffsetX;
					const anchorY = rect.top + layout.anchorOffsetY;
					// Keep the handle anchor fixed relative to the finger until dragging begins.
					dragStart = { x: event.clientX, y: event.clientY };
					dragOffset = {
						x: event.clientX - anchorX,
						y: event.clientY - anchorY,
					};
					dragging = false;
					handle.setPointerCapture(event.pointerId);
					event.preventDefault();
					event.stopPropagation();
				};
				const onPointerMove = (event: PointerEvent) => {
					if (!selectionModeEnabled) return;
					if (activeHandle !== kind || activePointerId !== event.pointerId)
						return;
					if (!dragStart || !dragOffset) return;
					const dx = event.clientX - dragStart.x;
					const dy = event.clientY - dragStart.y;
					if (!dragging) {
						if (Math.hypot(dx, dy) <= longPressSlopPx) {
							event.preventDefault();
							event.stopPropagation();
							return;
						}
						dragging = true;
					}
					const core = getSelectionCore();
					if (!core) return;
					const screenRect = core.screenElement.getBoundingClientRect();
					// Clamp to the screen bounds so getBufferCoords stays valid.
					const adjustedX = event.clientX - dragOffset.x;
					const adjustedY = event.clientY - dragOffset.y;
					const maxX = Math.max(screenRect.left, screenRect.right - 1);
					const maxY = Math.max(screenRect.top, screenRect.bottom - 1);
					const clampedX = Math.min(
						Math.max(adjustedX, screenRect.left),
						maxX,
					);
					const clampedY = Math.min(
						Math.max(adjustedY, screenRect.top),
						maxY,
					);
					const coords = getBufferCoords(clampedX, clampedY);
					if (!coords) return;
					const line = core.bufferService.buffer.lines.get(coords[1]);
					const normalizedCol = line
						? normalizeSelectionColumn(line, coords[0], core)
						: coords[0];
					const selectionService =
						core.selectionService as typeof core.selectionService & {
							selectionStart?: [number, number];
							selectionEnd?: [number, number];
						};
					const model = selectionService._model;
					const start =
						selectionService.selectionStart ?? model.selectionStart ?? coords;
					const endExclusive =
						selectionService.selectionEnd ?? model.selectionEnd ?? coords;
					const end = toInclusiveEnd(
						endExclusive,
						core.bufferService.cols,
						core.bufferService.buffer.ydisp,
					);
					if (kind === 'start') {
						updateSelectionRange([normalizedCol, coords[1]], end);
					} else {
						updateSelectionRange(start, [normalizedCol, coords[1]]);
					}
					event.preventDefault();
					event.stopPropagation();
				};
				const onPointerUp = (event: PointerEvent) => {
					if (activePointerId !== event.pointerId) return;
					activeHandle = null;
					activePointerId = null;
					resetDrag();
					handle.releasePointerCapture(event.pointerId);
					emitSelectionChanged();
					event.preventDefault();
					event.stopPropagation();
				};
				const onPointerCancel = (event: PointerEvent) => {
					if (activePointerId !== event.pointerId) return;
					activeHandle = null;
					activePointerId = null;
					resetDrag();
					handle.releasePointerCapture(event.pointerId);
					event.preventDefault();
					event.stopPropagation();
				};
				handle.addEventListener('pointerdown', onPointerDown);
				handle.addEventListener('pointermove', onPointerMove);
				handle.addEventListener('pointerup', onPointerUp);
				handle.addEventListener('pointercancel', onPointerCancel);
				handle.dataset.listenersAttached = 'true';
			};
			if (startHandle) attach(startHandle, 'start');
			if (endHandle) attach(endHandle, 'end');
		};

		const applySelectionMode = (
			enabled: boolean,
			opts: { force?: boolean } = {},
		) => {
			if (!enabled && selectionModeEnabled && !opts.force) {
				if (Date.now() - selectionModeShownAt < selectionHideGuardMs) return;
			}
			if (selectionModeEnabled === enabled) return;
			selectionModeEnabled = enabled;
			if (enabled) selectionModeShownAt = Date.now();
			ensureSelectionModeStyle();
			const rootEl = document.body || document.documentElement;
			rootEl?.classList.toggle(selectionModeClass, enabled);
			if (document.body) {
				document.body.style.boxShadow = '';
			}
			sendToRn({ type: 'selectionModeChanged', enabled });
			sendToRn({
				type: 'debug',
				message: `selection mode ${enabled ? 'enabled' : 'disabled'}`,
			});

			const termInternals = term as unknown as {
				_selectionService?: { enable?: () => void; disable?: () => void };
				_core?: {
					_selectionService?: { enable?: () => void; disable?: () => void };
				};
			};
			const selectionService =
				termInternals._selectionService ??
				termInternals._core?._selectionService;

			let mouseTrackingActive = false;
			try {
				const mode = term.modes?.mouseTrackingMode;
				mouseTrackingActive = Boolean(mode && mode !== 'none');
			} catch {
				mouseTrackingActive = false;
			}

			if (enabled) {
				try {
					term.options.disableStdin = true;
					term.options.screenReaderMode = true;
				} catch (err) {
					sendToRn({
						type: 'debug',
						message: `selection options set error: ${String(err)}`,
					});
				}
				selectionService?.enable?.();
				term.element?.classList.remove('enable-mouse-events');
				sendToRn({
					type: 'debug',
					message: `selection internals ${selectionService ? 'ok' : 'missing'}`,
				});
				if (!touchCleanup) {
					touchCleanup = (() => {
						const target = term.element;
						if (!target) return null;

						const ensureOverlay = () => {
							if (selectionOverlay) return selectionOverlay;
							const overlay = document.createElement('div');
							overlay.style.position = 'absolute';
							overlay.style.left = '0';
							overlay.style.right = '0';
							overlay.style.top = '0';
							overlay.style.bottom = '0';
							overlay.style.background = selectionOverlayTint;
							overlay.style.border = 'none';
							overlay.style.zIndex = '20';
							overlay.style.touchAction = 'none';
							overlay.style.pointerEvents = 'auto';
							const computed = window.getComputedStyle(target);
							if (computed.position === 'static') {
								target.style.position = 'relative';
							}
							target.appendChild(overlay);
							selectionOverlay = overlay;
							return overlay;
						};

						const overlay = ensureOverlay();
						term.element?.style.setProperty('outline', 'none');

						let tapStart: { x: number; y: number } | null = null;
						const onTouchStart = (event: TouchEvent) => {
							if (!selectionModeEnabled) return;
							if (event.touches.length !== 1) return;
							const touch = event.touches.item(0);
							if (!touch) return;
							tapStart = { x: touch.clientX, y: touch.clientY };
							event.preventDefault();
						};
						const onTouchMove = (event: TouchEvent) => {
							if (!tapStart) return;
							const touch = event.touches.item(0);
							if (!touch) return;
							const dx = touch.clientX - tapStart.x;
							const dy = touch.clientY - tapStart.y;
							if (Math.hypot(dx, dy) > longPressSlopPx) {
								tapStart = null;
							}
							event.preventDefault();
						};
						const onTouchEnd = (event: TouchEvent) => {
							if (!tapStart) return;
							tapStart = null;
							applySelectionMode(false);
							event.preventDefault();
						};
						const onTouchCancel = (event: TouchEvent) => {
							tapStart = null;
							event.preventDefault();
						};

						overlay.addEventListener('touchstart', onTouchStart, {
							passive: false,
						});
						overlay.addEventListener('touchmove', onTouchMove, {
							passive: false,
						});
						overlay.addEventListener('touchend', onTouchEnd, {
							passive: false,
						});
						overlay.addEventListener('touchcancel', onTouchCancel, {
							passive: false,
						});

						return () => {
							overlay.removeEventListener('touchstart', onTouchStart);
							overlay.removeEventListener('touchmove', onTouchMove);
							overlay.removeEventListener('touchend', onTouchEnd);
							overlay.removeEventListener('touchcancel', onTouchCancel);
							overlay.style.pointerEvents = 'none';
							overlay.style.display = 'none';
							term.element?.style.setProperty('outline', 'none');
						};
					})();
				}
				if (selectionOverlay) {
					selectionOverlay.style.pointerEvents = 'auto';
					selectionOverlay.style.display = 'block';
				}
				renderSelectionHandles();
			} else {
				try {
					term.options.disableStdin = baseSelectionOptions.disableStdin;
					term.options.screenReaderMode = baseSelectionOptions.screenReaderMode;
				} catch (err) {
					sendToRn({
						type: 'debug',
						message: `selection options reset error: ${String(err)}`,
					});
				}
				if (mouseTrackingActive) {
					selectionService?.disable?.();
					term.element?.classList.add('enable-mouse-events');
				} else {
					selectionService?.enable?.();
					term.element?.classList.remove('enable-mouse-events');
				}
				activeHandle = null;
				activePointerId = null;
				term.clearSelection();
				if (startHandle) startHandle.style.display = 'none';
				if (endHandle) endHandle.style.display = 'none';
				emitSelectionChanged();
				if (touchCleanup) {
					touchCleanup();
					touchCleanup = null;
				}
			}
		};

		const installLongPressHandlers = () => {
			if (longPressCleanup) return;
			const target = getSelectionCore()?.screenElement ?? term.element;
			if (!target) return;

			let longPressTimer: ReturnType<typeof setTimeout> | null = null;
			let startPoint: { x: number; y: number } | null = null;
			let longPressFired = false;
			let activePointerId: number | null = null;

			const clearLongPress = () => {
				if (longPressTimer) {
					clearTimeout(longPressTimer);
					longPressTimer = null;
				}
				startPoint = null;
				longPressFired = false;
				activePointerId = null;
			};

			const startLongPress = (x: number, y: number) => {
				if (selectionModeEnabled) return;
				startPoint = { x, y };
				longPressFired = false;
				longPressTimer = setTimeout(() => {
					if (!startPoint) return;
					const coords = getBufferCoords(startPoint.x, startPoint.y);
					if (!coords) {
						sendToRn({
							type: 'debug',
							message: `long-press coords unavailable at ${startPoint.x},${startPoint.y}`,
						});
						return;
					}
					// Enter selection mode on long-press and seed selection around the touch.
					applySelectionMode(true, { force: true });
					sendToRn({
						type: 'debug',
						message: `long-press coords ${coords[0]},${coords[1]}`,
					});
					let expanded = { start: coords, end: coords };
					try {
						expanded = expandToWord(coords);
						sendToRn({
							type: 'debug',
							message: `expandToWord start=${expanded.start[0]},${expanded.start[1]} end=${expanded.end[0]},${expanded.end[1]}`,
						});
					} catch (err) {
						sendToRn({
							type: 'debug',
							message: `expandToWord error: ${String(err)}`,
						});
					}
					sendToRn({
						type: 'debug',
						message: `apply selection start=${expanded.start[0]},${expanded.start[1]} end=${expanded.end[0]},${expanded.end[1]}`,
					});
					updateSelectionRange(expanded.start, expanded.end);
					renderSelectionHandles();
					emitSelectionChanged();
					longPressFired = true;
				}, longPressTimeoutMs);
			};

			const moveLongPress = (x: number, y: number) => {
				if (!startPoint || !longPressTimer) return;
				const dx = x - startPoint.x;
				const dy = y - startPoint.y;
				if (Math.hypot(dx, dy) > longPressSlopPx) {
					clearLongPress();
				}
			};

			const finishLongPress = (event?: Event) => {
				if (longPressFired) {
					event?.preventDefault?.();
				}
				clearLongPress();
			};

			if ('PointerEvent' in window) {
				const onPointerDown = (event: PointerEvent) => {
					if (selectionModeEnabled) return;
					if (event.pointerType && event.pointerType !== 'touch') return;
					activePointerId = event.pointerId;
					startLongPress(event.clientX, event.clientY);
				};
				const onPointerMove = (event: PointerEvent) => {
					if (activePointerId !== event.pointerId) return;
					moveLongPress(event.clientX, event.clientY);
				};
				const onPointerUp = (event: PointerEvent) => {
					if (activePointerId !== event.pointerId) return;
					finishLongPress(event);
				};
				const onPointerCancel = (event: PointerEvent) => {
					if (activePointerId !== event.pointerId) return;
					clearLongPress();
				};
				target.addEventListener('pointerdown', onPointerDown);
				target.addEventListener('pointermove', onPointerMove);
				target.addEventListener('pointerup', onPointerUp);
				target.addEventListener('pointercancel', onPointerCancel);

				longPressCleanup = () => {
					target.removeEventListener('pointerdown', onPointerDown);
					target.removeEventListener('pointermove', onPointerMove);
					target.removeEventListener('pointerup', onPointerUp);
					target.removeEventListener('pointercancel', onPointerCancel);
					clearLongPress();
				};
				return;
			}

			const onTouchStart = (event: TouchEvent) => {
				if (selectionModeEnabled) return;
				if (event.touches.length !== 1) return;
				const touch = event.touches.item(0);
				if (!touch) return;
				startLongPress(touch.clientX, touch.clientY);
			};
			const onTouchMove = (event: TouchEvent) => {
				if (!startPoint || !longPressTimer) return;
				const touch = event.touches.item(0);
				if (!touch) return;
				moveLongPress(touch.clientX, touch.clientY);
			};
			const onTouchEnd = (event: TouchEvent) => {
				finishLongPress(event);
			};
			const onTouchCancel = () => {
				clearLongPress();
			};

			target.addEventListener('touchstart', onTouchStart, { passive: true });
			target.addEventListener('touchmove', onTouchMove, { passive: true });
			target.addEventListener('touchend', onTouchEnd, { passive: false });
			target.addEventListener('touchcancel', onTouchCancel, {
				passive: true,
			});

			longPressCleanup = () => {
				target.removeEventListener('touchstart', onTouchStart);
				target.removeEventListener('touchmove', onTouchMove);
				target.removeEventListener('touchend', onTouchEnd);
				target.removeEventListener('touchcancel', onTouchCancel);
				clearLongPress();
			};
		};

		installLongPressHandlers();
		term.onResize(() => {
			if (selectionModeEnabled) renderSelectionHandles();
		});

		// Expose for debugging (typed)
		window.terminal = term;
		window.fitAddon = fitAddon;

		term.onData((data) => {
			sendToRn({ type: 'input', str: data });
		});

		// Report terminal size changes back to RN (for PTY resize)
		term.onResize(({ cols, rows }) => {
			if (cols >= 2 && rows >= 1) {
				sendToRn({ type: 'sizeChanged', cols, rows });
			}
		});

		// Remove old handler if any (just in case)
		if (window.__FRESSH_XTERM_MSG_HANDLER__)
			window.removeEventListener(
				'message',
				window.__FRESSH_XTERM_MSG_HANDLER__!,
			);

		// RN -> WebView handler (write, resize, setFont, setTheme, setOptions, clear, focus)
		const handler = (e: MessageEvent<BridgeOutboundMessage>) => {
			try {
				const msg = e.data;

				if (!msg || typeof msg.type !== 'string') return;

				// TODO: https://xtermjs.org/docs/guides/flowcontrol/#ideas-for-a-better-mechanism
				const termWrite = (bStr: string) => {
					const bytes = bStrToBinary(bStr);
					term.write(bytes);
				};

				switch (msg.type) {
					case 'write': {
						termWrite(msg.bStr);
						break;
					}
					case 'writeMany': {
						for (const bStr of msg.chunks) {
							termWrite(bStr);
						}
						break;
					}
					case 'resize': {
						term.resize(msg.cols, msg.rows);
						break;
					}
					case 'fit': {
						fitAddon.fit();
						// Report new size after fit (onResize may not fire if size unchanged)
						if (term.cols >= 2 && term.rows >= 1) {
							sendToRn({
								type: 'sizeChanged',
								cols: term.cols,
								rows: term.rows,
							});
						}
						break;
					}
					case 'getSelection': {
						const text = term.getSelection();
						sendToRn({ type: 'selection', requestId: msg.requestId, text });
						break;
					}
					case 'setSelectionMode': {
						sendToRn({
							type: 'debug',
							message: `setSelectionMode ${msg.enabled ? 'on' : 'off'}`,
						});
						applySelectionMode(msg.enabled, { force: true });
						break;
					}
					case 'setOptions': {
						const { theme, ...rest } = msg.opts;
						for (const key in rest) {
							if (key === 'cols' || key === 'rows') continue;
							const value = rest[key as keyof typeof rest];
							// eslint-disable-next-line @typescript-eslint/no-explicit-any
							(term.options as any)[key] = value;
						}
						if (theme) {
							term.options.theme = {
								...term.options.theme,
								...theme,
							};
						}
						applyFontFamily(msg.opts.fontFamily);
						if (theme?.background) {
							document.body.style.backgroundColor = theme.background;
						}
						break;
					}
					case 'clear': {
						term.clear();
						break;
					}
					case 'focus': {
						term.focus();
						break;
					}
				}
			} catch (err) {
				sendToRn({
					type: 'debug',
					message: `message handler error: ${String(err)}`,
				});
			}
		};

		window.__FRESSH_XTERM_MSG_HANDLER__ = handler;
		window.addEventListener('message', handler);

		// Initial handshake (send once)
		setTimeout(() => {
			const ta = document.querySelector(
				'.xterm-helper-textarea',
			) as HTMLTextAreaElement | null;
			if (!ta) throw new Error('xterm-helper-textarea not found');
			ta.setAttribute('autocomplete', 'off');
			ta.setAttribute('autocorrect', 'off');
			ta.setAttribute('autocapitalize', 'none');
			ta.setAttribute('spellcheck', 'false');
			ta.setAttribute('inputmode', 'verbatim');

			return sendToRn({ type: 'initialized' });
		}, 200);
	} catch (e) {
		sendToRn({
			type: 'debug',
			message: `error in xtermjs-webview: ${String(e)}`,
		});
	}
};
</file>

</files>
